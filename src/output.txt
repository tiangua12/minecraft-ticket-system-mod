package com.easttown.ticketsystem.block;

import net.minecraft.util.StringRepresentable;

public enum GateType implements StringRepresentable {
    IN("in"),       // 仅入站
    OUT("out"),      // 仅出站
    BIDIRECTIONAL("bidirectional");  // 双向
    
    private final String name;
    
    GateType(String name) {
        this.name = name;
    }
    
    @Override
    public String getSerializedName() {
        return name;
    }
}
package com.easttown.ticketsystem.block;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.init.BlockEntityInit;
import com.easttown.ticketsystem.init.ItemInit;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.ticks.TickPriority;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.Entity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.context.BlockPlaceContext;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.BaseEntityBlock;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.RenderShape;
import net.minecraft.world.level.block.SimpleWaterloggedBlock;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.entity.BlockEntityTicker;
import net.minecraft.world.level.block.entity.BlockEntityType;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.BooleanProperty;
import net.minecraft.world.level.block.state.properties.DirectionProperty;
import net.minecraft.world.level.material.FluidState;
import net.minecraft.world.level.material.Fluids;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraft.world.phys.shapes.CollisionContext;
import net.minecraft.world.phys.shapes.EntityCollisionContext;
import net.minecraft.world.phys.shapes.Shapes;
import net.minecraft.world.phys.shapes.VoxelShape;
import net.minecraft.world.phys.AABB;
import net.minecraftforge.network.NetworkHooks;

import javax.annotation.Nullable;
import java.util.Map;

public class GateBlock extends BaseEntityBlock implements SimpleWaterloggedBlock {
    public static final DirectionProperty FACING = BlockStateProperties.HORIZONTAL_FACING;
    public static final BooleanProperty OPEN = BooleanProperty.create("open");
    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;
    
    // 关闭状态下的碰撞箱（H形）
    private static final Map<Direction, VoxelShape> CLOSED_SHAPES = Map.of(
        Direction.NORTH, Shapes.or(
            Block.box(0, 0, 0, 1, 32, 16),   // 左柱
            Block.box(15, 0, 0, 16, 32, 16), // 右柱
            Block.box(1, 0, 7, 15, 32, 8)    // 横梁
        ),
        Direction.SOUTH, Shapes.or(
            Block.box(15, 0, 0, 16, 32, 16),
            Block.box(0, 0, 0, 1, 32, 16),
            Block.box(1, 0, 8, 15, 32, 9)
        ),
        Direction.EAST, Shapes.or(
            Block.box(0, 0, 0, 16, 32, 1),
            Block.box(0, 0, 15, 16, 32, 16),
            Block.box(8, 0, 0, 9, 32, 16)
        ),
        Direction.WEST, Shapes.or(
            Block.box(0, 0, 15, 16, 32, 16),
            Block.box(0, 0, 0, 16, 32, 1),
            Block.box(7, 0, 0, 8, 32, 16)
        )
    );

    // 开启状态下的碰撞箱（只有两侧立柱）
    private static final Map<Direction, VoxelShape> OPEN_SHAPES = Map.of(
        Direction.NORTH, Shapes.or(
            Block.box(0, 0, 0, 1, 32, 16),
            Block.box(15, 0, 0, 16, 32, 16)
        ),
        Direction.SOUTH, Shapes.or(
            Block.box(15, 0, 0, 16, 32, 16),
            Block.box(0, 0, 0, 1, 32, 16)
        ),
        Direction.EAST, Shapes.or(
            Block.box(0, 0, 0, 16, 32, 1),
            Block.box(0, 0, 15, 16, 32, 16)
        ),
        Direction.WEST, Shapes.or(
            Block.box(0, 0, 15, 16, 32, 16),
            Block.box(0, 0, 0, 16, 32, 1)
        )
    );

    public GateBlock(Properties properties) {
        super(properties);
        this.registerDefaultState(this.stateDefinition.any()
                .setValue(FACING, Direction.NORTH)
                .setValue(OPEN, false)
                .setValue(WATERLOGGED, false));
    }
    
    @Override
    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
        Direction direction = state.getValue(FACING);
        boolean isOpen = state.getValue(OPEN);
        
        // 根据OPEN状态返回不同的碰撞箱
        if (isOpen) {
            return OPEN_SHAPES.get(direction);
        } else {
            return CLOSED_SHAPES.get(direction);
        }
    }

    // 获取碰撞形状（只返回闸机主体的碰撞箱）
    @Override
    public VoxelShape getCollisionShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
        Direction direction = state.getValue(FACING);
        boolean isOpen = state.getValue(OPEN);
        
        return isOpen ? OPEN_SHAPES.get(direction) : CLOSED_SHAPES.get(direction);
    }
    
    @Override
    public BlockState getStateForPlacement(BlockPlaceContext context) {
        FluidState fluidState = context.getLevel().getFluidState(context.getClickedPos());
        return this.defaultBlockState()
                .setValue(FACING, context.getHorizontalDirection().getOpposite())
                .setValue(WATERLOGGED, fluidState.getType() == Fluids.WATER);
    }
    
    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        builder.add(FACING, OPEN, WATERLOGGED);
    }
    
    @Override
    public FluidState getFluidState(BlockState state) {
        return state.getValue(WATERLOGGED) ? Fluids.WATER.getSource(false) : super.getFluidState(state);
    }
    
    @Override
    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player,
            InteractionHand hand, BlockHitResult hit) {
        if (!level.isClientSide && player instanceof ServerPlayer serverPlayer) {
            BlockEntity blockEntity = level.getBlockEntity(pos);
            if (blockEntity instanceof GateBlockEntity gate) {
                // 检查是否有管理员钥匙
                boolean isAdmin = player.getItemInHand(hand).getItem() == ItemInit.ADMIN_KEY.get();
                
                if (isAdmin) {
                    // 管理员打开配置界面
                    gate.openConfigGui(serverPlayer);
                    return InteractionResult.SUCCESS;
                } else {
                    // 普通玩家尝试通过闸机
                    gate.tryPassThrough(player);
                    return InteractionResult.SUCCESS;
                }
            }
        }
        return InteractionResult.sidedSuccess(level.isClientSide);
    }
    
    @Override
    public RenderShape getRenderShape(BlockState state) {
        return RenderShape.MODEL;
    }
    
    @Nullable
    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        return BlockEntityInit.GATE.get().create(pos, state);
    }

    @Nullable
    @Override
    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> type) {
        return level.isClientSide ? null : createTickerHelper(type, BlockEntityInit.GATE.get(), GateBlockEntity::tick);
    }
    
    @Override
    public void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean isMoving) {
        super.onPlace(state, level, pos, oldState, isMoving);
        
        // 确保只在服务器端执行
        if (!level.isClientSide) {
            TicketSystemMod.LOGGER.info("闸机方块已放置于位置: " + pos);
            
            // 获取方块实体并初始化
            BlockEntity blockEntity = level.getBlockEntity(pos);
            if (blockEntity instanceof GateBlockEntity gate) {
                TicketSystemMod.LOGGER.info("闸机方块实体初始化完成");
            } else {
                TicketSystemMod.LOGGER.warn("闸机方块放置后未找到方块实体！位置: " + pos);
            }
        }
    }
    
    // 添加闸机关闭的tick处理
    @Override
    public void tick(BlockState state, ServerLevel level, BlockPos pos, net.minecraft.util.RandomSource random) {
        BlockEntity blockEntity = level.getBlockEntity(pos);
        if (blockEntity instanceof GateBlockEntity gate) {
            gate.closeGate();
        }
    }
}
package com.easttown.ticketsystem.block;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.init.BlockEntityInit;
import com.easttown.ticketsystem.item.TicketItem;
import com.easttown.ticketsystem.screen.GateConfigMenu;
import com.easttown.ticketsystem.util.GateUtil;
import com.easttown.ticketsystem.util.TicketSystemLogger;
import net.minecraft.world.ticks.TickPriority;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.Connection;
import net.minecraft.network.chat.Component;
import net.minecraft.network.protocol.Packet;
import net.minecraft.network.protocol.game.ClientGamePacketListener;
import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.phys.AABB;
import net.minecraftforge.network.NetworkHooks;

import javax.annotation.Nullable;
import java.util.UUID;

public class GateBlockEntity extends BlockEntity implements MenuProvider {
    // 闸机配置属性
    private String gateId = "G-" + UUID.randomUUID().toString().substring(0, 8);
    private String stationId = "";
    private GateType gateType = GateType.BIDIRECTIONAL;
    private boolean allowReentry = false;
    private int maxTravelMinutes = 1440; // 默认24小时
    private boolean destroyTicket = true;
    private boolean enabled = true; // 闸机是否启用
    private Direction lastFacing = null;

    // 状态变量
    private long lastPassTime = 0;
    private int cooldownTicks = 20; // 默认1秒冷却

    // 玩家通行管理
    private UUID currentPlayerId; // 当前正在通过的玩家
    private int timeoutTicks = 0; // 超时计时器（1分钟=1200 ticks）
    private static final String GATE_TAG_PREFIX = "ticketsystem_gate_"; // 玩家标签前缀

    // AABB检测区域
    private AABB entryDetectionArea; // 入站检测面（正面）
    private AABB exitDetectionArea; // 出站检测面（背面）
    private static final double DETECTION_THICKNESS = 0.1; // 检测面厚度

    public GateBlockEntity(BlockPos pos, BlockState state) {
        super(BlockEntityInit.GATE.get(), pos, state);
    }

    @Override
    public Component getDisplayName() {
        return Component.translatable("block.ticketsystem.gate");
    }

    @Nullable
    @Override
    public AbstractContainerMenu createMenu(int containerId, Inventory inventory, Player player) {
        return new GateConfigMenu(containerId, inventory, this);
    }

    public void openConfigGui(Player player) {
        if (player instanceof ServerPlayer serverPlayer) {
            NetworkHooks.openScreen(serverPlayer, this, buf -> {
                buf.writeBlockPos(worldPosition);
            });
        }
    }

    @Override
    public void onLoad() {
        super.onLoad();
        updateDetectionAreas();
        TicketSystemMod.LOGGER.info("闸机方块实体加载完成，位置: {}", worldPosition);
    }

    // 更新检测区域
    private void updateDetectionAreas() {
        if (level == null)
            return;

        Direction facing = getBlockState().getValue(GateBlock.FACING);

        // 创建入站检测面（正面）
        entryDetectionArea = createFacingAABB(worldPosition, facing, DETECTION_THICKNESS);

        // 创建出站检测面（背面）
        exitDetectionArea = createFacingAABB(worldPosition, facing.getOpposite(), DETECTION_THICKNESS);

        // 调试日志
        TicketSystemMod.LOGGER.debug("更新闸机检测区域 - 位置: {}, 朝向: {}", worldPosition, facing);
        TicketSystemMod.LOGGER.debug("入站检测面: {}", entryDetectionArea);
        TicketSystemMod.LOGGER.debug("出站检测面: {}", exitDetectionArea);
    }

    // 创建面向指定方向的AABB
    private AABB createFacingAABB(BlockPos pos, Direction direction, double thickness) {
        double minX = pos.getX();
        double minY = pos.getY();
        double minZ = pos.getZ();
        double maxX = minX + 1;
        double maxY = minY + 1;
        double maxZ = minZ + 1;

        return switch (direction) {
            case NORTH -> new AABB(minX, minY, maxZ - thickness, maxX, maxY, maxZ);
            case SOUTH -> new AABB(minX, minY, minZ, maxX, maxY, minZ + thickness);
            case WEST -> new AABB(maxX - thickness, minY, minZ, maxX, maxY, maxZ);
            case EAST -> new AABB(minX, minY, minZ, minX + thickness, maxY, maxZ);
            case UP -> new AABB(minX, maxY - thickness, minZ, maxX, maxY, maxZ);
            case DOWN -> new AABB(minX, minY, minZ, maxX, minY + thickness, maxZ);
            default -> new AABB(minX, minY, minZ, maxX, maxY, maxZ);
        };
    }

    public void tryPassThrough(Player player) {
        if (!enabled || !(level instanceof ServerLevel serverLevel))
            return;

        // 检查当前是否有玩家正在通过
        if (currentPlayerId != null) {
            player.displayClientMessage(Component.translatable("ticketsystem.gate.busy"), false);
            TicketSystemMod.LOGGER.debug("闸机繁忙，已有玩家通过: {}", currentPlayerId);
            return;
        }

        // 检查冷却时间
        if (serverLevel.getGameTime() - lastPassTime < cooldownTicks) {
            TicketSystemMod.LOGGER.debug("闸机冷却中，跳过处理");
            return;
        }

        ItemStack heldItem = player.getMainHandItem();
        GatePassResult result = checkTicket(heldItem, player);

        if (result.success) {
            TicketSystemMod.LOGGER.info("玩家 {} 使用有效车票，准备通过闸机", player.getName().getString());

            // 设置当前玩家和超时计时器
            currentPlayerId = player.getUUID();
            timeoutTicks = 1200; // 1分钟超时
            player.addTag(getPlayerTag());
            handleSuccess(player, heldItem);
        } else {
            TicketSystemMod.LOGGER.info("玩家 {} 车票无效: {}", player.getName().getString(), result.reason);
            handleFailure(player, result.reason);
        }

        lastPassTime = serverLevel.getGameTime();
    }

    private String getPlayerTag() {
        return GATE_TAG_PREFIX + gateId;
    }

    private void resetGate() {
        if (currentPlayerId != null) {
            Player player = level.getPlayerByUUID(currentPlayerId);
            if (player != null) {
                player.removeTag(getPlayerTag());
                TicketSystemMod.LOGGER.debug("移除玩家标签: {}", player.getName().getString());
            }
            currentPlayerId = null;
        }
        timeoutTicks = 0;
    }

    public static void tick(Level level, BlockPos pos, BlockState state, GateBlockEntity gate) {
        if (level.isClientSide || !gate.enabled)
            return;

        // 更新检测区域
        Direction currentFacing = state.getValue(GateBlock.FACING);
        if (gate.lastFacing != currentFacing) {
            gate.lastFacing = currentFacing;
            gate.updateDetectionAreas();

        }

        // 处理超时
        if (gate.timeoutTicks > 0) {
            gate.timeoutTicks--;
            if (gate.timeoutTicks <= 0) {
                // 超时，重置闸机并关闭门
                gate.resetGate();
                if (state.getValue(GateBlock.OPEN)) {
                    level.setBlock(pos, state.setValue(GateBlock.OPEN, false), 3);
                    TicketSystemMod.LOGGER.info("超时关闭闸机: {}", pos);
                }
            }
        }

        // 检测玩家位置
        if (gate.currentPlayerId != null) {
            Player player = level.getPlayerByUUID(gate.currentPlayerId);
            if (player == null) {
                // 玩家不在线，重置
                gate.resetGate();
                TicketSystemMod.LOGGER.debug("玩家离线，重置闸机");
                return;
            }

            // 使用AABB检测区域
            gate.checkDetectionAreas(player);
        }
    }

    private void checkDetectionAreas(Player player) {
        if (player == null || level == null)
            return;

        // 检测入站面（正面）
        if (entryDetectionArea != null && player.getBoundingBox().intersects(entryDetectionArea)) {
            TicketSystemMod.LOGGER.debug("玩家 {} 接触入站检测面", player.getName().getString());

            if (!player.getTags().contains(getPlayerTag())) {
                // 非法闯入，关闭闸机并重置
                level.setBlock(worldPosition, getBlockState().setValue(GateBlock.OPEN, false), 3);
                resetGate();
                handleFailure(player, "ticketsystem.gate.illegal_entry");
                TicketSystemMod.LOGGER.info("非法闯入! 玩家 {} 没有有效标签", player.getName().getString());
            }
        }

        // 检测出站面（背面）
        if (exitDetectionArea != null && player.getBoundingBox().intersects(exitDetectionArea)) {
            TicketSystemMod.LOGGER.debug("玩家 {} 接触出站检测面", player.getName().getString());

            // 完成通过
            player.removeTag(getPlayerTag());
            resetGate();

            // 延迟0.1秒关闭闸机
            level.scheduleTick(worldPosition, getBlockState().getBlock(), 2, TickPriority.HIGH);
            TicketSystemMod.LOGGER.info("玩家 {} 通过闸机，闸机将在0.1秒后关闭", player.getName().getString());
        }
    }

    // 处理闸机关闭
    public void closeGate() {
        if (level != null && !level.isClientSide) {
            BlockState state = getBlockState();
            if (state.getValue(GateBlock.OPEN)) {
                level.setBlock(worldPosition, state.setValue(GateBlock.OPEN, false), 3);
                TicketSystemMod.LOGGER.debug("闸机关闭 - 位置: {}", worldPosition);
            }
        }
    }

    private GatePassResult checkTicket(ItemStack ticketStack, Player player) {
        if (ticketStack.isEmpty() || !(ticketStack.getItem() instanceof TicketItem)) {
            return new GatePassResult(false, "ticketsystem.gate.no_ticket");
        }

        CompoundTag ticketTag = ticketStack.getTag();
        if (ticketTag == null) {
            return new GatePassResult(false, "ticketsystem.gate.invalid_ticket");
        }

        // 1. 检查车票ID
        UUID ticketId = GateUtil.getTicketId(ticketTag);
        if (ticketId == null) {
            return new GatePassResult(false, "ticketsystem.gate.invalid_ticket");
        }

        // 4. 获取车票状态
        String status = ticketTag.getString("Status");
        long issueTime = ticketTag.getLong("IssueTime");
        String startStation = ticketTag.getString("StartStation");
        String endStation = ticketTag.getString("Destination");

        long currentTime = System.currentTimeMillis();
        long travelTimeMinutes = (currentTime - issueTime) / 60000;

        // 5. 检查车票是否过期
        if (travelTimeMinutes > maxTravelMinutes) {
            return new GatePassResult(false, "ticketsystem.gate.expired");
        }

        // 根据闸机类型执行不同检查
        switch (gateType) {
            case IN:
                return checkInTicket(status, startStation, ticketTag);
            case OUT:
                return checkOutTicket(status, endStation, ticketTag);
            case BIDIRECTIONAL:
                return checkBidirectionalTicket(status, startStation, endStation, ticketTag);
            default:
                return new GatePassResult(false, "ticketsystem.gate.invalid_gate");
        }
    }

    private GatePassResult checkInTicket(String status, String startStation, CompoundTag ticketTag) {
        // 入站检查
        if (status.equals(TicketItem.COMPLETED)) {
            return new GatePassResult(false, "ticketsystem.gate.already_used");
        }

        if (status.equals(TicketItem.IN_USE)) {
            return new GatePassResult(false, "ticketsystem.gate.in_use");
        }

        if (!startStation.equals(stationId)) {
            return new GatePassResult(false, "ticketsystem.gate.wrong_start");
        }

        // 防止同站重复入站
        if (ticketTag.contains("gate_id") && ticketTag.getString("gate_id").equals(gateId)) {
            return new GatePassResult(false, "ticketsystem.gate.same_gate");
        }

        return new GatePassResult(true, "");
    }

    private GatePassResult checkOutTicket(String status, String endStation, CompoundTag ticketTag) {
        // 出站检查
        if (status.equals(TicketItem.UNUSED)) {
            return new GatePassResult(false, "ticketsystem.gate.not_used");
        }

        if (status.equals(TicketItem.COMPLETED)) {
            return new GatePassResult(false, "ticketsystem.gate.already_used");
        }

        if (!endStation.equals(stationId)) {
            return new GatePassResult(false, "ticketsystem.gate.wrong_end");
        }

        // 防止同站重复出站
        if (ticketTag.contains("exit_gate_id") && ticketTag.getString("exit_gate_id").equals(gateId)) {
            return new GatePassResult(false, "ticketsystem.gate.same_gate");
        }

        return new GatePassResult(true, "");
    }

    private GatePassResult checkBidirectionalTicket(String status, String startStation, String endStation,
            CompoundTag ticketTag) {
        if (status.equals(TicketItem.IN_USE)) {
            // 已使用票作为出站
            if (!endStation.equals(stationId)) {
                return new GatePassResult(false, "ticketsystem.gate.wrong_end");
            }
            return new GatePassResult(true, "");
        } else if (status.equals(TicketItem.UNUSED)) {
            // 未使用票作为入站
            if (!startStation.equals(stationId)) {
                return new GatePassResult(false, "ticketsystem.gate.wrong_start");
            }
            return new GatePassResult(true, "");
        }
        return new GatePassResult(false, "ticketsystem.gate.invalid_status");
    }

    private void handleSuccess(Player player, ItemStack ticketStack) {
        // 设置闸机为开启状态
        BlockState state = getBlockState();
        if (state.getValue(GateBlock.OPEN)) {
            // 如果已经是开启状态，先关闭再打开，确保动画播放
            level.setBlock(worldPosition, state.setValue(GateBlock.OPEN, false), 3);
        }
        level.setBlock(worldPosition, state.setValue(GateBlock.OPEN, true), 3);
        TicketSystemMod.LOGGER.info("闸机开启: {}", worldPosition);

        // 处理车票
        CompoundTag ticketTag = ticketStack.getOrCreateTag();
        boolean isInGate = gateType == GateType.IN ||
                (gateType == GateType.BIDIRECTIONAL && ticketTag.getString("Status").equals(TicketItem.UNUSED));

        String ticketId = ticketTag.getString("TicketId");
        String station = stationId;
        String gateTypeStr = gateType.name();

        if (isInGate) {
            // 入站处理 - 更新车票状态（注意：旅行计时在通过闸机后才开始）
            ticketTag.putString("Status", TicketItem.IN_USE);
            ticketTag.putString("EntryGate", gateId);

            // 记录入站成功日志
            TicketSystemLogger.logGatePassage(player, station, ticketId, true, "入站成功", gateTypeStr);
        } else {
            // 出站处理
            ticketTag.putString("Status", TicketItem.COMPLETED);
            ticketTag.putString("ExitGate", gateId);
            ticketTag.putLong("ExitTime", System.currentTimeMillis());

            // 是否销毁车票
            if (destroyTicket) {
                ticketStack.shrink(1);
            }

            // 记录出站成功日志
            TicketSystemLogger.logGatePassage(player, station, ticketId, true, "出站成功", gateTypeStr);
        }
    }

    private void handleFailure(Player player, String reasonKey) {
        // 发送失败消息
        player.displayClientMessage(Component.translatable(reasonKey), false);

        // 记录失败日志
        String reason = getFailureReason(reasonKey);
        TicketSystemLogger.logGatePassage(player, stationId, "未知", false, reason, gateType.name());
    }

    private String getFailureReason(String reasonKey) {
        switch (reasonKey) {
            case "ticketsystem.gate.no_ticket":
                return "没有车票";
            case "ticketsystem.gate.invalid_ticket":
                return "无效车票";
            case "ticketsystem.gate.expired":
                return "车票已过期";
            case "ticketsystem.gate.wrong_start":
                return "起点站不匹配";
            case "ticketsystem.gate.wrong_end":
                return "终点站不匹配";
            case "ticketsystem.gate.invalid_status":
                return "车票状态无效";
            case "ticketsystem.gate.illegal_entry":
                return "非法闯入";
            default:
                return "未知原因";
        }
    }

    @Override
    protected void saveAdditional(CompoundTag tag) {
        super.saveAdditional(tag);
        tag.putString("GateId", gateId);
        tag.putString("StationId", stationId);
        tag.putString("GateType", gateType.name());
        tag.putBoolean("AllowReentry", allowReentry);
        tag.putInt("MaxTravelMinutes", maxTravelMinutes);
        tag.putBoolean("DestroyTicket", destroyTicket);
        tag.putBoolean("Enabled", enabled);
        if (currentPlayerId != null) {
            tag.putUUID("CurrentPlayer", currentPlayerId);
        }
        tag.putInt("TimeoutTicks", timeoutTicks);
    }

    @Override
    public void load(CompoundTag tag) {
        super.load(tag);
        gateId = tag.getString("GateId");
        stationId = tag.getString("StationId");
        gateType = GateType.valueOf(tag.getString("GateType"));
        allowReentry = tag.getBoolean("AllowReentry");
        maxTravelMinutes = tag.getInt("MaxTravelMinutes");
        destroyTicket = tag.getBoolean("DestroyTicket");
        enabled = tag.getBoolean("Enabled");
        if (tag.hasUUID("CurrentPlayer")) {
            currentPlayerId = tag.getUUID("CurrentPlayer");
        }
        timeoutTicks = tag.getInt("TimeoutTicks");
    }

    @Override
    public CompoundTag getUpdateTag() {
        CompoundTag tag = super.getUpdateTag();
        saveAdditional(tag);
        return tag;
    }

    @Nullable
    @Override
    public Packet<ClientGamePacketListener> getUpdatePacket() {
        return ClientboundBlockEntityDataPacket.create(this);
    }

    @Override
    public void onDataPacket(Connection net, ClientboundBlockEntityDataPacket pkt) {
        super.onDataPacket(net, pkt);
        handleUpdateTag(pkt.getTag());
    }

    // 闸机配置方法
    public String getGateId() {
        return gateId;
    }

    public void setGateId(String gateId) {
        this.gateId = gateId;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }

    public String getStationId() {
        return stationId;
    }

    public void setStationId(String stationId) {
        this.stationId = stationId;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }

    public GateType getGateType() {
        return gateType;
    }

    public void setGateType(GateType gateType) {
        this.gateType = gateType;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }

    public boolean isAllowReentry() {
        return allowReentry;
    }

    public void setAllowReentry(boolean allowReentry) {
        this.allowReentry = allowReentry;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }

    public int getMaxTravelMinutes() {
        return maxTravelMinutes;
    }

    public void setMaxTravelMinutes(int maxTravelMinutes) {
        this.maxTravelMinutes = maxTravelMinutes;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }

    public boolean isDestroyTicket() {
        return destroyTicket;
    }

    public void setDestroyTicket(boolean destroyTicket) {
        this.destroyTicket = destroyTicket;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
        setChanged();
        if (level != null) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }
}

class GatePassResult {
    public final boolean success;
    public final String reason;

    public GatePassResult(boolean success, String reason) {
        this.success = success;
        this.reason = reason;
    }
}
package com.easttown.ticketsystem.block;

import com.easttown.ticketsystem.init.ItemInit;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.context.BlockPlaceContext;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.BaseEntityBlock;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.RenderShape;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.DirectionProperty;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraftforge.network.NetworkHooks;

import javax.annotation.Nullable;

public class TicketMachineBlock extends BaseEntityBlock {
    // 1. 添加方向属性
    public static final DirectionProperty FACING = BlockStateProperties.HORIZONTAL_FACING;

    public TicketMachineBlock(BlockBehaviour.Properties properties) {
        super(properties);
        // 2. 注册默认状态（朝北）
        this.registerDefaultState(this.stateDefinition.any().setValue(FACING, Direction.NORTH));
    }

    // 3. 将方向属性添加到状态定义
    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        super.createBlockStateDefinition(builder);
        builder.add(FACING);
    }

    // 4. 设置放置时的方向（根据玩家朝向）
    @Nullable
    @Override
    public BlockState getStateForPlacement(BlockPlaceContext context) {
        return this.defaultBlockState().setValue(FACING, context.getHorizontalDirection().getOpposite());
    }

    // 以下原有方法保持不变 ▼▼▼
    
    @Override
    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player,
            InteractionHand hand, BlockHitResult hit) {
        if (!level.isClientSide && player instanceof ServerPlayer serverPlayer) {
            BlockEntity blockEntity = level.getBlockEntity(pos);
            if (blockEntity instanceof TicketMachineBlockEntity ticketMachine) {
                // 计算相对点击位置
                double hitX = hit.getLocation().x - pos.getX();
                double hitY = hit.getLocation().y - pos.getY();
                double hitZ = hit.getLocation().z - pos.getZ();

                boolean isAdmin = player.getItemInHand(hand).getItem() == ItemInit.ADMIN_KEY.get();

                NetworkHooks.openScreen(serverPlayer, ticketMachine, buf -> {
                    buf.writeBlockPos(pos);
                    buf.writeBoolean(isAdmin);
                    buf.writeDouble(hitX);
                    buf.writeDouble(hitY);
                    buf.writeDouble(hitZ);
                });
            }
        }
        return InteractionResult.sidedSuccess(level.isClientSide);
    }

    @Override
    public RenderShape getRenderShape(BlockState state) {
        return RenderShape.MODEL;
    }

    @Nullable
    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        return new TicketMachineBlockEntity(pos, state);
    }

    @Override
    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean isMoving) {
        if (!state.is(newState.getBlock())) {
            BlockEntity blockEntity = level.getBlockEntity(pos);
            if (blockEntity instanceof TicketMachineBlockEntity ticketMachine) {
                ticketMachine.dropContents(level, pos);
                level.updateNeighbourForOutputSignal(pos, this);
            }
            super.onRemove(state, level, pos, newState, isMoving);
        }
    }
}
package com.easttown.ticketsystem.block;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.init.BlockEntityInit;
import com.easttown.ticketsystem.init.ItemInit;
import com.easttown.ticketsystem.init.MenuInit;
import com.easttown.ticketsystem.manager.CoinSystem;
import com.easttown.ticketsystem.manager.PriceCalculator;
import com.easttown.ticketsystem.screen.TicketMachineMenu;
import com.easttown.ticketsystem.util.TicketSystemLogger;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.Connection;
import net.minecraft.network.chat.Component;
import net.minecraft.network.protocol.Packet;
import net.minecraft.network.protocol.game.ClientGamePacketListener;
import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
import net.minecraft.world.Containers;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.SimpleContainer;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.ContainerData;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.items.ItemStackHandler;
import net.minecraft.resources.ResourceLocation;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.*;

public class TicketMachineBlockEntity extends BlockEntity implements MenuProvider {
    private final ItemStackHandler itemHandler = new ItemStackHandler(1) {
        @Override
        protected void onContentsChanged(int slot) {
            setChanged();
            if (level != null && !level.isClientSide) {
                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
            }
        }
        
        @Override
        public boolean isItemValid(int slot, @Nonnull ItemStack stack) {
            return false;
        }
        
        @Override
        public ItemStack extractItem(int slot, int amount, boolean simulate) {
            ItemStack stack = super.extractItem(slot, amount, simulate);
            if (!simulate) {
                setChanged();
                if (level != null) {
                    level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
                }
            }
            return stack;
        }
    };
    
    private final ContainerData data = new ContainerData() {
        @Override
        public int get(int index) { return 0; }
        @Override
        public void set(int index, int value) {}
        @Override
        public int getCount() { return 0; }
    };
    
    private LazyOptional<IItemHandler> lazyItemHandler = LazyOptional.empty();
    private String startStation = "";
    
    // 硬币存储系统
    private final Map<String, Integer> storedCoins = new HashMap<>();

    public TicketMachineBlockEntity(BlockPos pos, BlockState state) {
        super(BlockEntityInit.TICKET_MACHINE.get(), pos, state);
    }
    
    @Override
    public Component getDisplayName() {
        return Component.translatable("block.ticketsystem.ticket_machine");
    }
    
    @Nullable
    @Override
    public AbstractContainerMenu createMenu(int containerId, Inventory inventory, Player player) {
        return new TicketMachineMenu(containerId, inventory, this, player.getItemInHand(player.getUsedItemHand()).getItem() == ItemInit.ADMIN_KEY.get());
    }
    
    @Nonnull
    @Override
    public <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, @Nullable Direction side) {
        if (cap == ForgeCapabilities.ITEM_HANDLER) {
            return lazyItemHandler.cast();
        }
        return super.getCapability(cap, side);
    }
    
    @Override
    public void onLoad() {
        super.onLoad();
        lazyItemHandler = LazyOptional.of(() -> itemHandler);
    }
    
    @Override
    public void invalidateCaps() {
        super.invalidateCaps();
        lazyItemHandler.invalidate();
    }
    
    @Override
    protected void saveAdditional(CompoundTag tag) {
        super.saveAdditional(tag);
        tag.put("inventory", itemHandler.serializeNBT());
        tag.putString("StartStation", startStation);
        
        // 保存硬币存储
        CompoundTag coinsTag = new CompoundTag();
        for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
            coinsTag.putInt(entry.getKey(), entry.getValue());
        }
        tag.put("StoredCoins", coinsTag);
    }
    
    @Override
    public void load(CompoundTag tag) {
        super.load(tag);
        itemHandler.deserializeNBT(tag.getCompound("inventory"));
        startStation = tag.getString("StartStation");
        
        // 加载硬币存储
        storedCoins.clear();
        CompoundTag coinsTag = tag.getCompound("StoredCoins");
        for (String key : coinsTag.getAllKeys()) {
            storedCoins.put(key, coinsTag.getInt(key));
        }
    }
    
    public void setStartStation(String station) {
        if (station != null && !station.isEmpty() && !station.equals(startStation)) {
            startStation = station;
            setChanged();
            if (level != null) {
                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
            }
        }
    }
    
    public String getStartStation() {
        return startStation;
    }
    
    public boolean canPrintTicket() {
        return itemHandler.getStackInSlot(0).isEmpty();
    }
    
    public void printTicket(String destination, Player player) {
        if (startStation.isEmpty() || destination.isEmpty()) return;

        ItemStack ticket = new ItemStack(ItemInit.TICKET.get());
        CompoundTag tag = new CompoundTag();

        // 添加车票详细信息
        String ticketId = UUID.randomUUID().toString();
        int price = PriceCalculator.calculatePrice(startStation, destination);

        tag.putString("TicketId", ticketId);
        tag.putString("StartStation", startStation);
        tag.putString("Destination", destination);
        tag.putLong("IssueTime", System.currentTimeMillis());
        tag.putInt("Price", price);
        tag.putString("Status", "UNUSED"); // 初始状态为未使用

        ticket.setTag(tag);

        itemHandler.setStackInSlot(0, ticket);
        setChanged();

        // 记录购买车票日志
        if (player != null) {
            String paymentMethod = "硬币"; // 可以根据实际支付方式调整
            TicketSystemLogger.logTicketPurchase(player, startStation, destination, price, ticketId, paymentMethod);
        }

        if (level != null && !level.isClientSide) {
            level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
        }
    }
    
    public void dropContents(Level level, BlockPos pos) {
        SimpleContainer inventory = new SimpleContainer(itemHandler.getSlots());
        for (int i = 0; i < itemHandler.getSlots(); i++) {
            inventory.setItem(i, itemHandler.getStackInSlot(i));
        }
        Containers.dropContents(level, pos, inventory);
        
        // 同时掉落存储的硬币
        if (!storedCoins.isEmpty()) {
            for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
                Item coin = ForgeRegistries.ITEMS.getValue(ResourceLocation.tryParse(entry.getKey()));
                if (coin != null) {
                    int count = entry.getValue();
                    while (count > 0) {
                        int amount = Math.min(count, coin.getMaxStackSize());
                        Containers.dropItemStack(level, pos.getX(), pos.getY(), pos.getZ(), new ItemStack(coin, amount));
                        count -= amount;
                    }
                }
            }
        }
    }
    
    // 添加硬币到存储
    public void addCoins(Map<String, Integer> coins) {
        for (Map.Entry<String, Integer> entry : coins.entrySet()) {
            String coinId = entry.getKey();
            int amount = entry.getValue();
            storedCoins.put(coinId, storedCoins.getOrDefault(coinId, 0) + amount);
        }
        setChanged();
    }
    
    // 取出所有存储的硬币
    public Map<String, Integer> withdrawCoins() {
        Map<String, Integer> coins = new HashMap<>(storedCoins);
        storedCoins.clear();
        setChanged();
        return coins;
    }
    
    // 获取存储的硬币
    public Map<String, Integer> getStoredCoins() {
        return Collections.unmodifiableMap(storedCoins);
    }
    
    // 获取硬币总价值（以铜币为单位）
    public int getTotalCopperValue() {
        int total = 0;
        for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
            String coinId = entry.getKey();
            int amount = entry.getValue();
            int valuePerCoin = CoinSystem.getCoinValue(coinId);
            total += valuePerCoin * amount;
        }
        return total;
    }
    
    @Override
    public CompoundTag getUpdateTag() {
        CompoundTag tag = super.getUpdateTag();
        saveAdditional(tag);
        return tag;
    }
    
    @Override
    public Packet<ClientGamePacketListener> getUpdatePacket() {
        return ClientboundBlockEntityDataPacket.create(this);
    }
    
    @Override
    public void onDataPacket(Connection net, ClientboundBlockEntityDataPacket pkt) {
        super.onDataPacket(net, pkt);
        handleUpdateTag(pkt.getTag());
    }
}
package com.easttown.ticketsystem.block;

import com.easttown.ticketsystem.init.BlockEntityInit;
import com.easttown.ticketsystem.init.MenuInit;
import com.easttown.ticketsystem.init.ItemInit;
import com.easttown.ticketsystem.item.TicketItem;
import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.manager.CoinSystem;
import com.easttown.ticketsystem.util.LanguageHelper;
import com.easttown.ticketsystem.util.TicketSystemLogger;
import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.network.Connection;
import net.minecraft.network.protocol.Packet;
import net.minecraft.network.protocol.game.ClientGamePacketListener;
import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
import net.minecraft.world.Containers;
import net.minecraft.world.MenuProvider;
import net.minecraft.world.SimpleContainer;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.Container;
import net.minecraft.world.ContainerListener;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.common.util.LazyOptional;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.items.ItemStackHandler;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ReissueMachineBlockEntity extends BlockEntity implements MenuProvider, Container {

    // 物品槽位定义
    // 槽位0：车票输入槽
    // 槽位1-9：硬币输出槽（共9个）
    // 槽位10-63：硬币存储槽（管理员界面，54个槽位，6x9布局）
    // 退票时车票会被销毁，不需要输出槽
    private final ItemStackHandler itemHandler = new ItemStackHandler(64) {
        @Override
        protected void onContentsChanged(int slot) {
            setChanged();
            if (level != null && !level.isClientSide) {
                // 强制发送数据包更新到客户端
                level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);

                // 当车票放入输入槽时，确保客户端及时更新
                if (slot == 0) {
                    ItemStack ticketStack = getTicketInputSlot();
                    if (!ticketStack.isEmpty() && ticketStack.getItem() == ItemInit.TICKET.get()) {
                        // 车票详情现在在GUI中显示，确保客户端及时更新
                        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 车票放入槽位，发送数据包更新");

                        // 强制同步数据到所有正在查看GUI的玩家
                        if (level.getServer() != null) {
                            for (net.minecraft.server.level.ServerPlayer player : level.getServer().getPlayerList().getPlayers()) {
                                if (player.containerMenu instanceof com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineMainMenu) {
                                    player.connection.send(getUpdatePacket());
                                }
                            }
                        }
                    }
                }
            }
        }

        @Override
        public boolean isItemValid(int slot, @Nonnull ItemStack stack) {
            // 槽位0：车票输入槽（只能放入未使用的车票）
            if (slot == 0) {
                return stack.getItem() == ItemInit.TICKET.get() && TicketItem.isUnused(stack);
            }
            // 槽位1-9：硬币输出槽（只能由机器放入）
            if (slot >= 1 && slot <= 9) {
                return false;
            }
            // 槽位10-63：硬币存储槽（只能放入硬币）
            if (slot >= 10 && slot <= 63) {
                String itemId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                return CoinSystem.isCoin(itemId);
            }
            return false;
        }

        @Override
        public ItemStack extractItem(int slot, int amount, boolean simulate) {
            // 所有槽位都允许提取，包括车票输入槽
            ItemStack stack = super.extractItem(slot, amount, simulate);
            if (!simulate) {
                setChanged();
                if (level != null) {
                    level.sendBlockUpdated(worldPosition, getBlockState(), getBlockState(), 3);
                }
            }
            return stack;
        }
    };

    private LazyOptional<IItemHandler> lazyItemHandler = LazyOptional.empty();

    // 硬币存储系统
    private final Map<String, Integer> storedCoins = new HashMap<>();

    public ReissueMachineBlockEntity(BlockPos pos, BlockState state) {
        super(BlockEntityInit.REISSUE_MACHINE.get(), pos, state);
        // 调试信息：输出初始化时的槽位数量
        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity created with " + itemHandler.getSlots() + " slots");
    }

    // MenuProvider接口实现
    @Override
    public Component getDisplayName() {
        return Component.translatable("block.ticketsystem.reissue_machine");
    }

    public Component getDisplayName(Player player) {

        if (isAdmin(player)) {
            return Component.translatable("block.ticketsystem.reissue_machine");
        } else {
            return Component.translatable("block.ticketsystem.reissue_machine.is_adminmode");
        }
    }

    @Override
    public AbstractContainerMenu createMenu(int containerId, Inventory inventory, Player player) {
        // 检查是否是管理员，如果是则打开管理员菜单，否则打开主菜单
        if (isAdmin(player)) {
            return new com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineAdminMenu(containerId, inventory, this);
        } else {
            return new com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineMainMenu(containerId, inventory, this);
        }
    }

    // 客户端打开屏幕的方法
    public void openScreen(Player player) {
        if (player.level().isClientSide()) {
            // 直接打开主菜单界面
            player.openMenu(this);
        }
    }

    // 检查是否是管理员（持有管理员钥匙）
    public boolean isAdmin(Player player) {
        if (player == null) return false;

        // 检查主手和副手是否持有管理员钥匙
        ItemStack mainHand = player.getMainHandItem();
        ItemStack offHand = player.getOffhandItem();

        return (mainHand.getItem() == com.easttown.ticketsystem.init.ItemInit.ADMIN_KEY.get()) ||
                (offHand.getItem() == com.easttown.ticketsystem.init.ItemInit.ADMIN_KEY.get());
    }

    @Nonnull
    @Override
    public <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, @Nullable Direction side) {
        if (cap == ForgeCapabilities.ITEM_HANDLER) {
            return lazyItemHandler.cast();
        }
        return super.getCapability(cap, side);
    }

    @Override
    public void onLoad() {
        super.onLoad();
        lazyItemHandler = LazyOptional.of(() -> itemHandler);
    }

    @Override
    public void invalidateCaps() {
        super.invalidateCaps();
        lazyItemHandler.invalidate();
    }

    @Override
    protected void saveAdditional(CompoundTag tag) {
        super.saveAdditional(tag);
        tag.put("inventory", itemHandler.serializeNBT());

        // 保存硬币存储
        CompoundTag coinsTag = new CompoundTag();
        for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
            coinsTag.putInt(entry.getKey(), entry.getValue());
        }
        tag.put("StoredCoins", coinsTag);
    }

    @Override
    public void load(CompoundTag tag) {
        super.load(tag);

        // 简单的NBT修复：如果槽位数量不对，重新创建
        CompoundTag inventoryTag = tag.getCompound("inventory");
        if (inventoryTag.contains("Size") && inventoryTag.getInt("Size") != 64) {
            int oldSize = inventoryTag.getInt("Size");
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: NBT数据槽位数量不匹配，从 " + oldSize + " 修复到 64");

            // 创建新的64槽位handler
            ItemStackHandler newHandler = new ItemStackHandler(64);

            // 迁移旧数据
            ItemStackHandler oldHandler = new ItemStackHandler(oldSize);
            oldHandler.deserializeNBT(inventoryTag);

            int migratedCount = 0;
            for (int i = 0; i < Math.min(oldHandler.getSlots(), 64); i++) {
                ItemStack stack = oldHandler.getStackInSlot(i);
                if (!stack.isEmpty()) {
                    newHandler.setStackInSlot(i, stack);
                    migratedCount++;
                }
            }

            itemHandler.deserializeNBT(newHandler.serializeNBT());
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: NBT数据迁移完成，迁移了 " + migratedCount + " 个槽位");
        } else {
            itemHandler.deserializeNBT(inventoryTag);
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: NBT数据加载完成，当前槽位数量: " + itemHandler.getSlots());
        }

        // 加载硬币存储
        storedCoins.clear();
        CompoundTag coinsTag = tag.getCompound("StoredCoins");
        for (String key : coinsTag.getAllKeys()) {
            storedCoins.put(key, coinsTag.getInt(key));
        }
    }

    // 槽位访问方法
    public ItemStack getTicketInputSlot() {
        return itemHandler.getStackInSlot(0);
    }

    public ItemStack getCoinOutputSlot(int index) {
        if (index >= 1 && index <= 9) {
            return itemHandler.getStackInSlot(index);
        }
        return ItemStack.EMPTY;
    }

    // 获取所有硬币输出槽
    public ItemStack[] getAllCoinOutputSlots() {
        ItemStack[] slots = new ItemStack[9];
        for (int i = 0; i < 9; i++) {
            slots[i] = itemHandler.getStackInSlot(i + 1);
        }
        return slots;
    }

    // 检查车票NBT完整性
    private boolean isTicketNBTComplete(ItemStack ticket) {
        if (ticket.isEmpty() || ticket.getTag() == null) {
            return false;
        }

        CompoundTag tag = ticket.getTag();
        return tag.contains("TicketId") &&
                tag.contains("StartStation") &&
                tag.contains("Destination") &&
                tag.contains("IssueTime") &&
                tag.contains("Price") &&
                tag.contains("Status");
    }

    // 退票功能
    public boolean canRefundTicket() {
        // 检查输入槽有未使用的车票
        ItemStack inputTicket = getTicketInputSlot();

        if (inputTicket.isEmpty() || !TicketItem.isUnused(inputTicket)) {
            return false;
        }

        // 检查车票NBT完整性
        if (!isTicketNBTComplete(inputTicket)) {
            return false;
        }

        // 不再检查硬币输出槽是否为空，允许堆叠硬币
        return true;
    }

    public boolean refundTicket(Player player) {
        if (!canRefundTicket()) {
            return false;
        }

        ItemStack inputTicket = getTicketInputSlot();
        CompoundTag tag = inputTicket.getTag();
        if (tag == null) {
            return false;
        }

        // 获取车票价格
        int price = tag.getInt("Price");
        long issueTime = tag.getLong("IssueTime");

        // 检查车票是否过期（例如超过24小时不可退票）
        long currentTime = System.currentTimeMillis();
        long timeDiff = currentTime - issueTime;
        long maxRefundTime = 24 * 60 * 60 * 1000; // 24小时

        if (timeDiff > maxRefundTime) {
            return false; // 车票已过期，不可退票
        }

        // 计算退款金额（可设置退款手续费，这里全额退款）
        int refundAmount = price;

        // 检查是否有足够的硬币进行退款
        if (getTotalCoinsValue() < refundAmount) {
            return false;
        }

        // 从存储中扣除硬币并获取实际扣除的硬币组合
        Map<String, Integer> deductedCoins = deductCoinsAndGet(refundAmount);
        if (deductedCoins == null) {
            return false;
        }

        // 销毁车票（清空输入槽）
        itemHandler.setStackInSlot(0, ItemStack.EMPTY);

        // 将硬币放入输出槽，多余的放入玩家物品栏
        // 按价值从高到低排序硬币类型
        List<Map.Entry<String, Integer>> sortedCoins = new ArrayList<>(deductedCoins.entrySet());
        sortedCoins.sort((a, b) -> {
            int valueA = CoinSystem.getCoinValue(a.getKey());
            int valueB = CoinSystem.getCoinValue(b.getKey());
            return Integer.compare(valueB, valueA); // 降序排序
        });

        // 首先尝试放入输出槽（支持堆叠）
        for (Map.Entry<String, Integer> entry : sortedCoins) {
            String coinId = entry.getKey();
            int count = entry.getValue();
            if (count > 0) {
                net.minecraft.world.item.Item coinItem = net.minecraftforge.registries.ForgeRegistries.ITEMS.getValue(net.minecraft.resources.ResourceLocation.tryParse(coinId));
                if (coinItem != null) {
                    // 尝试将硬币堆叠到现有的输出槽中
                    boolean coinsPlaced = false;

                    // 首先检查是否有相同类型的硬币可以堆叠
                    for (int slot = 1; slot <= 9 && count > 0; slot++) {
                        ItemStack existingStack = itemHandler.getStackInSlot(slot);
                        if (!existingStack.isEmpty() && existingStack.getItem() == coinItem &&
                                existingStack.getCount() < existingStack.getMaxStackSize()) {
                            // 可以堆叠到现有槽位
                            int spaceLeft = existingStack.getMaxStackSize() - existingStack.getCount();
                            int toAdd = Math.min(count, spaceLeft);
                            existingStack.grow(toAdd);
                            count -= toAdd;
                            coinsPlaced = true;
                        }
                    }

                    // 如果没有可以堆叠的槽位，尝试放入空槽位
                    for (int slot = 1; slot <= 9 && count > 0; slot++) {
                        ItemStack existingStack = itemHandler.getStackInSlot(slot);
                        if (existingStack.isEmpty()) {
                            // 空槽位，直接放入
                            int toAdd = Math.min(count, coinItem.getMaxStackSize());
                            itemHandler.setStackInSlot(slot, new ItemStack(coinItem, toAdd));
                            count -= toAdd;
                            coinsPlaced = true;
                        }
                    }

                    // 如果输出槽已满或无法堆叠，放入玩家物品栏
                    if (count > 0) {
                        ItemStack remainingCoins = new ItemStack(coinItem, count);
                        if (player != null) {
                            if (!player.getInventory().add(remainingCoins)) {
                                // 如果玩家物品栏也满了，掉落在地上
                                player.drop(remainingCoins, false);
                            }
                            com.easttown.ticketsystem.util.DebugLogger.info("硬币输出槽已满，硬币已放入玩家物品栏");
                        }
                    }
                }
            }
        }

        setChanged();

        // 成功时输出聊天消息
        if (player != null) {
            player.displayClientMessage(LanguageHelper.translate("reissue.refund_success", price), false);
        }

        return true;
    }

    // 硬币管理方法
    public void addCoins(Map<String, Integer> coins) {
        for (Map.Entry<String, Integer> entry : coins.entrySet()) {
            String coinId = entry.getKey();
            int amount = entry.getValue();
            storedCoins.put(coinId, storedCoins.getOrDefault(coinId, 0) + amount);
        }
        setChanged();
    }

    // 获取硬币存储槽中的硬币
    public Map<String, Integer> getCoinsFromStorageSlots() {
        Map<String, Integer> coins = new HashMap<>();
        for (int slot = 10; slot <= 63; slot++) {
            ItemStack stack = itemHandler.getStackInSlot(slot);
            if (!stack.isEmpty()) {
                String coinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                coins.put(coinId, coins.getOrDefault(coinId, 0) + stack.getCount());
            }
        }
        return coins;
    }

    // 获取总硬币价值（包括存储槽中的硬币）
    public int getTotalCoinsValue() {
        int total = 0;

        // 计算存储槽中的硬币价值
        for (int slot = 10; slot <= 63; slot++) {
            ItemStack stack = itemHandler.getStackInSlot(slot);
            if (!stack.isEmpty()) {
                String coinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                int valuePerCoin = CoinSystem.getCoinValue(coinId);
                total += valuePerCoin * stack.getCount();
            }
        }

        // 加上内部存储的硬币价值
        for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
            String coinId = entry.getKey();
            int amount = entry.getValue();
            int valuePerCoin = CoinSystem.getCoinValue(coinId);
            total += valuePerCoin * amount;
        }

        return total;
    }

    private boolean deductCoins(int amount) {
        if (getTotalCoinsValue() < amount) {
            return false;
        }

        // 计算需要扣除的硬币组合
        Map<String, Integer> coinsToDeduct = CoinSystem.calculateOptimalCoins(amount);

        // 首先尝试从存储槽中扣除硬币
        for (Map.Entry<String, Integer> entry : coinsToDeduct.entrySet()) {
            String coinId = entry.getKey();
            int required = entry.getValue();

            // 从存储槽中扣除
            for (int slot = 10; slot <= 63 && required > 0; slot++) {
                ItemStack stack = itemHandler.getStackInSlot(slot);
                if (!stack.isEmpty()) {
                    String stackCoinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                    if (stackCoinId.equals(coinId)) {
                        int available = stack.getCount();
                        int toDeduct = Math.min(available, required);
                        stack.shrink(toDeduct);
                        required -= toDeduct;
                        if (stack.isEmpty()) {
                            itemHandler.setStackInSlot(slot, ItemStack.EMPTY);
                        }
                    }
                }
            }

            // 如果存储槽中不足，尝试自动换钱
            if (required > 0) {
                if (!exchangeCoinsForSmaller(coinId, required)) {
                    return false;
                }
            }
        }

        setChanged();
        return true;
    }

    // 自动将大面额硬币换成小面额硬币
    private boolean exchangeCoinsForSmaller(String targetCoinId, int required) {
        // 获取目标硬币的价值
        int targetValue = CoinSystem.getCoinValue(targetCoinId);
        int requiredValue = targetValue * required;

        // 尝试从存储槽中寻找更大面额的硬币
        List<String> coinTypes = new ArrayList<>(CoinSystem.getCoinValues().keySet());
        Collections.sort(coinTypes, (a, b) -> Integer.compare(CoinSystem.getCoinValue(b), CoinSystem.getCoinValue(a)));

        for (String largerCoinId : coinTypes) {
            int largerValue = CoinSystem.getCoinValue(largerCoinId);
            if (largerValue <= targetValue) continue; // 跳过相同或更小的面额

            // 计算需要多少个大面额硬币
            int neededLargerCoins = (int) Math.ceil((double) requiredValue / largerValue);

            // 检查存储槽中是否有足够的大面额硬币
            int availableLargerCoins = 0;
            for (int slot = 10; slot <= 63; slot++) {
                ItemStack stack = itemHandler.getStackInSlot(slot);
                if (!stack.isEmpty()) {
                    String stackCoinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                    if (stackCoinId.equals(largerCoinId)) {
                        availableLargerCoins += stack.getCount();
                    }
                }
            }

            if (availableLargerCoins >= neededLargerCoins) {
                // 兑换大面额硬币
                int remainingToExchange = neededLargerCoins;
                for (int slot = 10; slot <= 63 && remainingToExchange > 0; slot++) {
                    ItemStack stack = itemHandler.getStackInSlot(slot);
                    if (!stack.isEmpty()) {
                        String stackCoinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                        if (stackCoinId.equals(largerCoinId)) {
                            int toExchange = Math.min(stack.getCount(), remainingToExchange);
                            stack.shrink(toExchange);
                            remainingToExchange -= toExchange;
                            if (stack.isEmpty()) {
                                itemHandler.setStackInSlot(slot, ItemStack.EMPTY);
                            }
                        }
                    }
                }

                // 计算找零（大面额硬币价值 - 所需价值）
                int changeValue = (neededLargerCoins * largerValue) - requiredValue;
                if (changeValue > 0) {
                    // 将找零放入存储槽
                    Map<
                            String,
                            Integer> changeCoins = CoinSystem.calculateOptimalCoins(changeValue);
                    addCoinsToStorageSlots(changeCoins);
                }

                return true;
            }
        }

        return false;
    }

    // 将硬币添加到存储槽
    private void addCoinsToStorageSlots(Map<String, Integer> coins) {
        for (Map.Entry<String, Integer> entry : coins.entrySet()) {
            String coinId = entry.getKey();
            int count = entry.getValue();
            if (count > 0) {
                net.minecraft.world.item.Item coinItem = net.minecraftforge.registries.ForgeRegistries.ITEMS.getValue(net.minecraft.resources.ResourceLocation.tryParse(coinId));
                if (coinItem != null) {
                    // 尝试将硬币放入存储槽
                    for (int slot = 10; slot <= 63 && count > 0; slot++) {
                        ItemStack existingStack = itemHandler.getStackInSlot(slot);
                        if (existingStack.isEmpty()) {
                            // 空槽位，直接放入
                            int toAdd = Math.min(count, coinItem.getMaxStackSize());
                            itemHandler.setStackInSlot(slot, new ItemStack(coinItem, toAdd));
                            count -= toAdd;
                        } else if (existingStack.getItem() == coinItem && existingStack.getCount() < existingStack.getMaxStackSize()) {
                            // 相同物品，可以堆叠
                            int spaceLeft = existingStack.getMaxStackSize() - existingStack.getCount();
                            int toAdd = Math.min(count, spaceLeft);
                            existingStack.grow(toAdd);
                            count -= toAdd;
                        }
                    }
                }
            }
        }
    }

    // 扣除硬币并返回实际扣除的硬币组合
    private Map<String, Integer> deductCoinsAndGet(int amount) {
        if (getTotalCoinsValue() < amount) {
            return null;
        }

        // 计算需要扣除的硬币组合
        Map<String, Integer> coinsToDeduct = CoinSystem.calculateOptimalCoins(amount);
        Map<String, Integer> actualDeducted = new HashMap<>();

        // 首先尝试从存储槽中扣除硬币
        for (Map.Entry<String, Integer> entry : coinsToDeduct.entrySet()) {
            String coinId = entry.getKey();
            int required = entry.getValue();
            int actuallyDeducted = 0;

            // 从存储槽中扣除
            for (int slot = 10; slot <= 63 && required > 0; slot++) {
                ItemStack stack = itemHandler.getStackInSlot(slot);
                if (!stack.isEmpty()) {
                    String stackCoinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                    if (stackCoinId.equals(coinId)) {
                        int available = stack.getCount();
                        int toDeduct = Math.min(available, required);
                        stack.shrink(toDeduct);
                        actuallyDeducted += toDeduct;
                        required -= toDeduct;
                        if (stack.isEmpty()) {
                            itemHandler.setStackInSlot(slot, ItemStack.EMPTY);
                        }
                    }
                }
            }

            // 记录实际扣除的数量
            if (actuallyDeducted > 0) {
                actualDeducted.put(coinId, actuallyDeducted);
            }

            // 如果存储槽中不足，尝试自动换钱
            if (required > 0) {
                Map<
                        String,
                        Integer> exchangedCoins = exchangeCoinsForSmallerAndGet(coinId, required);
                if (exchangedCoins == null) {
                    return null;
                }
                // 合并兑换得到的硬币
                for (Map.Entry<String, Integer> exchangeEntry : exchangedCoins.entrySet()) {
                    actualDeducted.put(exchangeEntry.getKey(),
                            actualDeducted.getOrDefault(exchangeEntry.getKey(), 0) + exchangeEntry.getValue());
                }
            }
        }

        setChanged();
        return actualDeducted;
    }

    // 自动将大面额硬币换成小面额硬币并返回实际兑换的硬币
    private Map<String, Integer> exchangeCoinsForSmallerAndGet(String targetCoinId, int required) {
        // 获取目标硬币的价值
        int targetValue = CoinSystem.getCoinValue(targetCoinId);
        int requiredValue = targetValue * required;

        // 尝试从存储槽中寻找更大面额的硬币
        List<String> coinTypes = new ArrayList<>(CoinSystem.getCoinValues().keySet());
        Collections.sort(coinTypes, (a, b) -> Integer.compare(CoinSystem.getCoinValue(b), CoinSystem.getCoinValue(a)));

        for (String largerCoinId : coinTypes) {
            int largerValue = CoinSystem.getCoinValue(largerCoinId);
            if (largerValue <= targetValue) continue; // 跳过相同或更小的面额

            // 计算需要多少个大面额硬币
            int neededLargerCoins = (int) Math.ceil((double) requiredValue / largerValue);

            // 检查存储槽中是否有足够的大面额硬币
            int availableLargerCoins = 0;
            for (int slot = 10; slot <= 63; slot++) {
                ItemStack stack = itemHandler.getStackInSlot(slot);
                if (!stack.isEmpty()) {
                    String stackCoinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                    if (stackCoinId.equals(largerCoinId)) {
                        availableLargerCoins += stack.getCount();
                    }
                }
            }

            if (availableLargerCoins >= neededLargerCoins) {
                // 兑换大面额硬币
                int remainingToExchange = neededLargerCoins;
                for (int slot = 10; slot <= 63 && remainingToExchange > 0; slot++) {
                    ItemStack stack = itemHandler.getStackInSlot(slot);
                    if (!stack.isEmpty()) {
                        String stackCoinId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                        if (stackCoinId.equals(largerCoinId)) {
                            int toExchange = Math.min(stack.getCount(), remainingToExchange);
                            stack.shrink(toExchange);
                            remainingToExchange -= toExchange;
                            if (stack.isEmpty()) {
                                itemHandler.setStackInSlot(slot, ItemStack.EMPTY);
                            }
                        }
                    }
                }

                // 计算找零（大面额硬币价值 - 所需价值）
                int changeValue = (neededLargerCoins * largerValue) - requiredValue;
                Map<String, Integer> result = new HashMap<>();
                result.put(targetCoinId, required);

                if (changeValue > 0) {
                    // 将找零放入存储槽
                    Map<
                            String,
                            Integer> changeCoins = CoinSystem.calculateOptimalCoins(changeValue);
                    addCoinsToStorageSlots(changeCoins);
                }

                return result;
            }
        }

        return null;
    }

    public Map<String, Integer> withdrawCoins() {
        Map<String, Integer> coins = new HashMap<>(storedCoins);
        storedCoins.clear();
        setChanged();
        return coins;
    }

    // 退币功能 - 根据车票价格退款
    public RefundResult refundTicketByPrice(Player player) {
        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 开始处理退票请求，玩家: " + player.getName().getString());

        // 获取车票输入槽
        ItemStack inputTicket = getTicketInputSlot();

        // 检查是否有车票
        if (inputTicket.isEmpty()) {
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票失败 - 没有车票");
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND, "退票失败 - 没有车票，玩家: " + player.getName().getString());
            return RefundResult.NO_TICKET;
        }

        if (!TicketItem.isUnused(inputTicket)) {
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票失败 - 车票已使用");
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND, "退票失败 - 车票已使用，玩家: " + player.getName().getString());
            return RefundResult.INVALID_TICKET;
        }

        // 检查车票NBT完整性
        if (!isTicketNBTComplete(inputTicket)) {
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票失败 - 车票NBT数据不完整");
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND, "退票失败 - 车票NBT数据不完整，玩家: " + player.getName().getString());
            return RefundResult.INVALID_TICKET;
        }

        CompoundTag tag = inputTicket.getTag();
        if (tag == null) {
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票失败 - 车票没有NBT数据");
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND, "退票失败 - 车票没有NBT数据，玩家: " + player.getName().getString());
            return RefundResult.INVALID_TICKET;
        }

        // 获取车票价格和购买时间
        int price = tag.getInt("Price");
        long issueTime = tag.getLong("IssueTime");
        String ticketId = tag.contains("TicketId") ? tag.getString("TicketId") : "未知";
        String startStation = tag.contains("StartStation") ? tag.getString("StartStation") : "未知";
        String destination = tag.contains("Destination") ? tag.getString("Destination") : "未知";

        if (price <= 0) {
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND, "退票失败 - 车票价格无效，玩家: " + player.getName().getString());
            return RefundResult.INVALID_TICKET;
        }

        // 计算退款金额（阶梯式退款）
        int refundAmount = calculateRefundAmount(price, issueTime);
        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 车票价格: " + price + ", 退款金额: " + refundAmount);

        if (refundAmount <= 0) {
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票失败 - 车票已过期");
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND,
                    "退票失败 - 车票已过期，玩家: " + player.getName().getString() +
                            ", 车票ID: " + ticketId +
                            ", 原价: " + price);
            return RefundResult.TICKET_EXPIRED;
        }

        // 检查存储中是否有足够的硬币
        int totalCoins = getTotalCoinsValue();
        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 存储硬币总价值: " + totalCoins + ", 需要: " + refundAmount);

        if (totalCoins < refundAmount) {
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票失败 - 硬币不足");
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND,
                    "退票失败 - 硬币不足，玩家: " + player.getName().getString() +
                            ", 车票ID: " + ticketId +
                            ", 需要: " + refundAmount +
                            ", 实际: " + totalCoins);
            return RefundResult.INSUFFICIENT_COINS;
        }

        // 从存储中扣除硬币并获取实际扣除的硬币组合
        Map<String, Integer> deductedCoins = deductCoinsAndGet(refundAmount);
        if (deductedCoins == null) {
            TicketSystemLogger.logWarning(TicketSystemLogger.LogType.REFUND,
                    "退票失败 - 硬币扣除失败，玩家: " + player.getName().getString() +
                            ", 车票ID: " + ticketId);
            return RefundResult.INSUFFICIENT_COINS;
        }

        // 销毁车票
        itemHandler.setStackInSlot(0, ItemStack.EMPTY);

        // 将硬币放入输出槽，多余的放入玩家物品栏
        // 按价值从高到低排序硬币类型
        List<Map.Entry<String, Integer>> sortedCoins = new ArrayList<>(deductedCoins.entrySet());
        sortedCoins.sort((a, b) -> {
            int valueA = CoinSystem.getCoinValue(a.getKey());
            int valueB = CoinSystem.getCoinValue(b.getKey());
            return Integer.compare(valueB, valueA); // 降序排序
        });

        // 首先尝试放入输出槽（支持堆叠）
        for (Map.Entry<String, Integer> entry : sortedCoins) {
            String coinId = entry.getKey();
            int count = entry.getValue();
            if (count > 0) {
                net.minecraft.world.item.Item coinItem = net.minecraftforge.registries.ForgeRegistries.ITEMS.getValue(net.minecraft.resources.ResourceLocation.tryParse(coinId));
                if (coinItem != null) {
                    // 尝试将硬币堆叠到现有的输出槽中
                    boolean coinsPlaced = false;

                    // 首先检查是否有相同类型的硬币可以堆叠
                    for (int slot = 1; slot <= 9 && count > 0; slot++) {
                        ItemStack existingStack = itemHandler.getStackInSlot(slot);
                        if (!existingStack.isEmpty() && existingStack.getItem() == coinItem &&
                                existingStack.getCount() < existingStack.getMaxStackSize()) {
                            // 可以堆叠到现有槽位
                            int spaceLeft = existingStack.getMaxStackSize() - existingStack.getCount();
                            int toAdd = Math.min(count, spaceLeft);
                            existingStack.grow(toAdd);
                            count -= toAdd;
                            coinsPlaced = true;
                        }
                    }

                    // 如果没有可以堆叠的槽位，尝试放入空槽位
                    for (int slot = 1; slot <= 9 && count > 0; slot++) {
                        ItemStack existingStack = itemHandler.getStackInSlot(slot);
                        if (existingStack.isEmpty()) {
                            // 空槽位，直接放入
                            int toAdd = Math.min(count, coinItem.getMaxStackSize());
                            itemHandler.setStackInSlot(slot, new ItemStack(coinItem, toAdd));
                            count -= toAdd;
                            coinsPlaced = true;
                        }
                    }

                    // 如果输出槽已满或无法堆叠，放入玩家物品栏
                    if (count > 0) {
                        ItemStack remainingCoins = new ItemStack(coinItem, count);
                        if (player != null) {
                            if (!player.getInventory().add(remainingCoins)) {
                                // 如果玩家物品栏也满了，掉落在地上
                                player.drop(remainingCoins, false);
                            }
                            com.easttown.ticketsystem.util.DebugLogger.info("硬币输出槽已满，硬币已放入玩家物品栏");
                        }
                    }
                }
            }
        }

        setChanged();

        // 成功时输出聊天消息
        if (player != null) {
            player.displayClientMessage(LanguageHelper.translate("reissue.refund_success", refundAmount), false);
        }

        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineBlockEntity: 退票成功，退款金额: " + refundAmount);

        // 记录详细的退票成功日志
        String refundReason = calculateRefundReason(price, issueTime);
        TicketSystemLogger.logRefund(player, ticketId, price, refundAmount, refundReason);

        return RefundResult.SUCCESS;
    }

    // 计算退款原因
    private String calculateRefundReason(int originalPrice, long issueTime) {
        long currentTime = System.currentTimeMillis();
        long timeDiff = currentTime - issueTime;

        // 时间阈值（毫秒）
        long halfHour = 30 * 60 * 1000; // 30分钟
        long oneHour = 60 * 60 * 1000; // 1小时
        long twoHours = 2 * 60 * 60 * 1000; // 2小时
        long sixHours = 6 * 60 * 60 * 1000; // 6小时
        long oneDay = 24 * 60 * 60 * 1000; // 24小时

        if (timeDiff <= halfHour) {
            return "30分钟内全额退款";
        } else if (timeDiff <= oneHour) {
            return "1小时内75%退款";
        } else if (timeDiff <= twoHours) {
            return "2小时内50%退款";
        } else if (timeDiff <= sixHours) {
            return "6小时内25%退款";
        } else if (timeDiff <= oneDay) {
            return "24小时内10%退款";
        } else {
            return "超过24小时不可退款";
        }
    }

    public Map<String, Integer> getStoredCoins() {
        return Collections.unmodifiableMap(storedCoins);
    }

    // 计算阶梯式退款金额
    private int calculateRefundAmount(int originalPrice, long issueTime) {
        long currentTime = System.currentTimeMillis();
        long timeDiff = currentTime - issueTime;

        // 时间阈值（毫秒）
        long halfHour = 30 * 60 * 1000; // 30分钟
        long oneHour = 60 * 60 * 1000; // 1小时
        long twoHours = 2 * 60 * 60 * 1000; // 2小时
        long sixHours = 6 * 60 * 60 * 1000; // 6小时
        long oneDay = 24 * 60 * 60 * 1000; // 24小时

        // 阶梯式退款比例（从配置文件读取）
        if (timeDiff <= halfHour) {
            // 30分钟内：全额退款
            return (int) (originalPrice * com.easttown.ticketsystem.config.TicketSystemConfig.getRefundHalfHourRate());
        } else if (timeDiff <= oneHour) {
            // 1小时内：75%退款
            return (int) (originalPrice * com.easttown.ticketsystem.config.TicketSystemConfig.getRefundOneHourRate());
        } else if (timeDiff <= twoHours) {
            // 2小时内：50%退款
            return (int) (originalPrice * com.easttown.ticketsystem.config.TicketSystemConfig.getRefundTwoHoursRate());
        } else if (timeDiff <= sixHours) {
            // 6小时内：25%退款
            return (int) (originalPrice * com.easttown.ticketsystem.config.TicketSystemConfig.getRefundSixHoursRate());
        } else if (timeDiff <= oneDay) {
            // 24小时内：10%退款
            return (int) (originalPrice * com.easttown.ticketsystem.config.TicketSystemConfig.getRefundOneDayRate());
        } else {
            // 超过24小时：不可退款
            return 0;
        }
    }

    // 获取车票详情信息（用于GUI显示）
    public Map<String, String> getTicketDetails() {
        Map<String, String> details = new HashMap<>();
        ItemStack ticketStack = getTicketInputSlot();

        if (ticketStack.isEmpty() || ticketStack.getTag() == null) {
            details.put("hasTicket", "false");
            return details;
        }

        CompoundTag tag = ticketStack.getTag();

        // 获取车票信息
        details.put("hasTicket", "true");
        details.put("ticketId", tag.contains("TicketId") ? tag.getString("TicketId") : "未知");
        details.put("startStation", tag.contains("StartStation") ? tag.getString("StartStation") : "未知");
        details.put("destination", tag.contains("Destination") ? tag.getString("Destination") : "未知");
        details.put("price", tag.contains("Price") ? String.valueOf(tag.getInt("Price")) : "0");
        details.put("status", tag.contains("Status") ? tag.getString("Status") : "未知");

        // 格式化时间
        long issueTime = tag.contains("IssueTime") ? tag.getLong("IssueTime") : 0;
        details.put("issueTime", formatTime(issueTime));

        return details;
    }

    // 格式化时间
    private String formatTime(long timestamp) {
        if (timestamp <= 0) {
            return "未知";
        }

        java.util.Date date = new java.util.Date(timestamp);
        java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return sdf.format(date);
    }

    public int getTotalCopperValue() {
        int total = 0;
        for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
            String coinId = entry.getKey();
            int amount = entry.getValue();
            int valuePerCoin = CoinSystem.getCoinValue(coinId);
            total += valuePerCoin * amount;
        }
        return total;
    }

    // 掉落物品
    public void dropContents(Level level, BlockPos pos) {
        SimpleContainer inventory = new SimpleContainer(itemHandler.getSlots());
        for (int i = 0; i < itemHandler.getSlots(); i++) {
            inventory.setItem(i, itemHandler.getStackInSlot(i));
        }
        Containers.dropContents(level, pos, inventory);

        // 同时掉落存储的硬币
        if (!storedCoins.isEmpty()) {
            for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
                net.minecraft.world.item.Item coin = net.minecraftforge.registries.ForgeRegistries.ITEMS.getValue(net.minecraft.resources.ResourceLocation.tryParse(entry.getKey()));
                if (coin != null) {
                    int count = entry.getValue();
                    while (count > 0) {
                        int amount = Math.min(count, coin.getMaxStackSize());
                        Containers.dropItemStack(level, pos.getX(), pos.getY(), pos.getZ(), new ItemStack(coin, amount));
                        count -= amount;
                    }
                }
            }
        }
    }

    // 数据同步方法
    @Override
    public CompoundTag getUpdateTag() {
        CompoundTag tag = super.getUpdateTag();
        saveAdditional(tag);
        return tag;
    }

    @Override
    public void handleUpdateTag(CompoundTag tag) {
        super.handleUpdateTag(tag);
        load(tag);
    }

    @Override
    public Packet<ClientGamePacketListener> getUpdatePacket() {
        return ClientboundBlockEntityDataPacket.create(this);
    }

    @Override
    public void onDataPacket(Connection net, ClientboundBlockEntityDataPacket pkt) {
        super.onDataPacket(net, pkt);
        CompoundTag tag = pkt.getTag();
        if (tag != null) {
            handleUpdateTag(tag);
        }
    }

    // Container接口实现
    @Override
    public int getContainerSize() {
        return itemHandler.getSlots();
    }

    @Override
    public boolean isEmpty() {
        for (int i = 0; i < itemHandler.getSlots(); i++) {
            if (!itemHandler.getStackInSlot(i).isEmpty()) {
                return false;
            }
        }
        return true;
    }

    @Override
    public ItemStack getItem(int slot) {
        // 添加边界检查，防止访问无效槽位
        if (slot < 0 || slot >= itemHandler.getSlots()) {
            // 输出警告日志
            TicketSystemMod.LOGGER.warn("ReissueMachineBlockEntity: Attempting to access slot " + slot + ", but only " + itemHandler.getSlots() + " slots available");
            return ItemStack.EMPTY;
        }
        return itemHandler.getStackInSlot(slot);
    }

    @Override
    public ItemStack removeItem(int slot, int amount) {
        // 添加边界检查，防止访问无效槽位
        if (slot < 0 || slot >= itemHandler.getSlots()) {
            // 输出警告日志
            TicketSystemMod.LOGGER.warn("ReissueMachineBlockEntity: Attempting to access slot " + slot + ", but only " + itemHandler.getSlots() + " slots available");
            return ItemStack.EMPTY;
        }
        return itemHandler.extractItem(slot, amount, false);
    }

    @Override
    public ItemStack removeItemNoUpdate(int slot) {
        // 添加边界检查，防止访问无效槽位
        if (slot < 0 || slot >= itemHandler.getSlots()) {
            // 输出警告日志
            TicketSystemMod.LOGGER.warn("ReissueMachineBlockEntity: Attempting to access slot " + slot + ", but only " + itemHandler.getSlots() + " slots available");
            return ItemStack.EMPTY;
        }
        ItemStack stack = itemHandler.getStackInSlot(slot);
        itemHandler.setStackInSlot(slot, ItemStack.EMPTY);
        return stack;
    }

    @Override
    public void setItem(int slot, ItemStack stack) {
        // 添加边界检查，防止访问无效槽位
        if (slot < 0 || slot >= itemHandler.getSlots()) {
            // 输出警告日志
            TicketSystemMod.LOGGER.warn("ReissueMachineBlockEntity: Attempting to access slot " + slot + ", but only " + itemHandler.getSlots() + " slots available");
            return;
        }
        itemHandler.setStackInSlot(slot, stack);
    }

    @Override
    public void setChanged() {
        super.setChanged();
    }

    @Override
    public boolean stillValid(Player player) {
        if (this.level == null || this.level.getBlockEntity(this.worldPosition) != this) {
            return false;
        }
        return player.distanceToSqr((double) this.worldPosition.getX() + 0.5D,
                        (double) this.worldPosition.getY() + 0.5D,
                        (double) this.worldPosition.getZ() + 0.5D) <= 64.0D;
    }

    @Override
    public void clearContent() {
        for (int i = 0; i < itemHandler.getSlots(); i++) {
            itemHandler.setStackInSlot(i, ItemStack.EMPTY);
        }
    }

    @Override
    public void startOpen(Player player) {
        // 可选实现
    }

    @Override
    public void stopOpen(Player player) {
        // 可选实现
    }

    @Override
    public boolean canPlaceItem(int slot, ItemStack stack) {
        // 添加边界检查，防止访问无效槽位
        if (slot < 0 || slot >= itemHandler.getSlots()) {
            // 输出警告日志
            TicketSystemMod.LOGGER.warn("ReissueMachineBlockEntity: Attempting to access slot " + slot + ", but only " + itemHandler.getSlots() + " slots available");
            return false;
        }
        return itemHandler.isItemValid(slot, stack);
    }

    @Override
    public int getMaxStackSize() {
        return 64;
    }

    // Container接口的监听器方法 - 可选实现
    public void addSlotListener(ContainerListener listener) {
        // 可选实现
    }

    public void removeSlotListener(ContainerListener listener) {
        // 可选实现
    }

    // 退款结果枚举
    public enum RefundResult {
        SUCCESS,
        NO_TICKET,
        INVALID_TICKET,
        INSUFFICIENT_COINS,
        TICKET_EXPIRED
    }
}package com.easttown.ticketsystem.block;

import net.minecraft.core.BlockPos;
import net.minecraft.core.Direction;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResult;
import net.minecraft.world.entity.LivingEntity;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.context.BlockPlaceContext;
import com.easttown.ticketsystem.init.ItemInit;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.world.level.BlockGetter;
import net.minecraft.world.level.Level;
import net.minecraft.world.level.LevelAccessor;
import net.minecraft.world.level.LevelReader;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.Blocks;
import net.minecraft.world.level.block.EntityBlock;
import net.minecraft.world.level.block.entity.BlockEntity;
import net.minecraft.world.level.block.LevelEvent;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.block.state.BlockState;
import net.minecraft.world.level.block.state.StateDefinition;
import net.minecraft.world.level.block.state.properties.BlockStateProperties;
import net.minecraft.world.level.block.state.properties.DirectionProperty;
import net.minecraft.world.level.block.state.properties.DoubleBlockHalf;
import net.minecraft.world.level.material.Fluids;
import net.minecraft.world.phys.BlockHitResult;
import net.minecraft.world.phys.shapes.CollisionContext;
import net.minecraft.world.phys.shapes.VoxelShape;
import net.minecraftforge.network.NetworkHooks;
import com.easttown.ticketsystem.util.DebugLogger;

import javax.annotation.Nullable;

public class ReissueMachineBlock extends Block implements EntityBlock {
    public static final DirectionProperty FACING = BlockStateProperties.HORIZONTAL_FACING;
    public static final net.minecraft.world.level.block.state.properties.EnumProperty<DoubleBlockHalf> HALF = BlockStateProperties.DOUBLE_BLOCK_HALF;

    // 下半部分碰撞箱（完整高度）
    private static final VoxelShape SHAPE_LOWER = Block.box(0, 0, 0, 16, 32, 16);
    // 上半部分碰撞箱（相对于下半部分的位置）
    private static final VoxelShape SHAPE_UPPER = Block.box(0, -16, 0, 16, 16, 16);

    public ReissueMachineBlock(BlockBehaviour.Properties properties) {
        super(properties);
        this.registerDefaultState(this.stateDefinition.any()
            .setValue(FACING, Direction.NORTH)
            .setValue(HALF, DoubleBlockHalf.LOWER));
    }

    @Override
    protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
        super.createBlockStateDefinition(builder);
        builder.add(FACING, HALF);
    }

    // 放置逻辑
    @Nullable
    @Override
    public BlockState getStateForPlacement(BlockPlaceContext context) {
        BlockPos clickedPos = context.getClickedPos();
        Level level = context.getLevel();

        // 检查上方空间是否可用
        if (clickedPos.getY() < level.getMaxBuildHeight() - 1 &&
            level.getBlockState(clickedPos.above()).canBeReplaced(context)) {
            return this.defaultBlockState()
                .setValue(FACING, context.getHorizontalDirection().getOpposite())
                .setValue(HALF, DoubleBlockHalf.LOWER);
        } else {
            return null; // 放置失败
        }
    }

    // 自动创建上半部分
    @Override
    public void setPlacedBy(Level level, BlockPos pos, BlockState state,
                           LivingEntity entity, ItemStack stack) {
        // 在下方位置的上方放置上半部分
        level.setBlock(pos.above(), state.setValue(HALF, DoubleBlockHalf.UPPER), 3);
    }

    // 生存检查机制
    @Override
    public boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
        BlockPos belowPos = pos.below();
        BlockState belowState = level.getBlockState(belowPos);

        if (state.getValue(HALF) == DoubleBlockHalf.LOWER) {
            // 下半部分：需要下方有坚固的支撑面
            return belowState.isFaceSturdy(level, belowPos, Direction.UP);
        } else {
            // 上半部分：需要下方是同一方块的下半部分
            return belowState.is(this) && belowState.getValue(HALF) == DoubleBlockHalf.LOWER;
        }
    }

    // 方块更新同步
    @Override
    public BlockState updateShape(BlockState state, Direction facing, BlockState facingState,
                                 LevelAccessor level, BlockPos currentPos, BlockPos facingPos) {
        DoubleBlockHalf blockHalf = state.getValue(HALF);

        // 处理垂直方向的更新（上下部分连接处）
        if (facing.getAxis() == Direction.Axis.Y &&
            blockHalf == DoubleBlockHalf.LOWER == (facing == Direction.UP)) {

            boolean condition = facingState.is(this) && facingState.getValue(HALF) != blockHalf;
            return condition ?
                state.setValue(FACING, facingState.getValue(FACING)) :
                Blocks.AIR.defaultBlockState(); // 如果另一半丢失，破坏当前部分
        } else {
            // 下半部分检查下方支撑
            boolean condition = blockHalf == DoubleBlockHalf.LOWER &&
                               facing == Direction.DOWN &&
                               !state.canSurvive(level, currentPos);
            return condition ? Blocks.AIR.defaultBlockState() :
                   super.updateShape(state, facing, facingState, level, currentPos, facingPos);
        }
    }

    // 破坏连锁反应
    @Override
    public void playerWillDestroy(Level level, BlockPos pos, BlockState state, Player player) {
        DoubleBlockHalf value = state.getValue(HALF);
        BlockPos otherPos = value == DoubleBlockHalf.LOWER ? pos.above() : pos.below();
        BlockState otherState = level.getBlockState(otherPos);

        if (otherState.is(this) && otherState.getValue(HALF) != value) {
            if (!level.isClientSide) {
                if (player.isCreative()) {
                    // 创造模式：直接破坏另一部分，不产生掉落
                    level.setBlock(otherPos, Blocks.AIR.defaultBlockState(), Block.UPDATE_SUPPRESS_DROPS | Block.UPDATE_ALL);
                } else {
                    // 生存模式：只在下半部分产生掉落，避免重复掉落
                    if (value == DoubleBlockHalf.LOWER) {
                        // 破坏下半部分时，上半部分自动破坏但不产生掉落
                        level.setBlock(otherPos, Blocks.AIR.defaultBlockState(), Block.UPDATE_SUPPRESS_DROPS | Block.UPDATE_ALL);
                    } else {
                        // 破坏上半部分时，下半部分保留，不产生额外掉落
                        level.setBlock(otherPos, otherState, Block.UPDATE_SUPPRESS_DROPS | Block.UPDATE_ALL);
                    }
                }
            }
        }

        super.playerWillDestroy(level, pos, state, player);
    }

    // 碰撞箱管理
    @Override
    public VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
        if (state.getValue(HALF) == DoubleBlockHalf.LOWER) {
            return SHAPE_LOWER; // 完整高度的碰撞箱
        } else {
            return SHAPE_UPPER; // 上半部分较矮的碰撞箱
        }
    }

    @Override
    public VoxelShape getCollisionShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
        return getShape(state, level, pos, context);
    }

    // 交互逻辑
    @Override
    public InteractionResult use(BlockState state, Level level, BlockPos pos, Player player,
            InteractionHand hand, BlockHitResult hit) {

        // 检查是否持有管理员钥匙
        ItemStack heldItem = player.getItemInHand(hand);
        boolean isAdminKey = heldItem.getItem() == ItemInit.ADMIN_KEY.get();

        // 统一使用下半部分的位置进行方块实体操作
        BlockPos tePos = state.getValue(HALF) == DoubleBlockHalf.LOWER ? pos : pos.below();
        BlockEntity blockEntity = level.getBlockEntity(tePos);

        if (blockEntity instanceof ReissueMachineBlockEntity terminal) {
            DebugLogger.info("方块使用 - 位置: {}, 客户端: {}, 管理员钥匙: {}", tePos, level.isClientSide(), isAdminKey);

            // 持有管理员钥匙时打开管理员界面，否则打开游客模式界面
            if (isAdminKey) {
                if (level.isClientSide()) {
                    // 客户端直接打开管理员界面
                    terminal.openScreen(player);
                } else if (player instanceof ServerPlayer serverPlayer) {
                    // 服务端打开管理员界面
                    NetworkHooks.openScreen(serverPlayer, terminal, tePos);
                }
            } else {
                // 游客模式：打开主菜单界面
                if (level.isClientSide()) {
                    // 客户端直接打开主菜单界面
                    terminal.openScreen(player);
                } else if (player instanceof ServerPlayer serverPlayer) {
                    // 服务端打开主菜单界面
                    NetworkHooks.openScreen(serverPlayer, terminal, tePos);
                }
            }
            return InteractionResult.sidedSuccess(level.isClientSide);
        }
        return InteractionResult.PASS;
    }

    // 方块实体集成
    @Nullable
    @Override
    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
        // 只在下半部分创建方块实体
        if (state.getValue(HALF) == DoubleBlockHalf.LOWER) {
            return new ReissueMachineBlockEntity(pos, state);
        }
        return null;
    }
}package com.easttown.ticketsystem.client;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.manager.StationManager;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.AbstractSelectionList;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.narration.NarratedElementType;
import net.minecraft.network.chat.Component;

import java.util.*;
import java.util.function.Consumer;

public abstract class BaseStationList 
    extends AbstractSelectionList<BaseStationList.StationEntry> {
    
    // 颜色常量
    protected static final int BACKGROUND = 0xFFE0F7FA;
    protected static final int NORMAL_BG = 0xFFB3E5FC;
    protected static final int SELECTED_BG = 0xFF03A9F4;
    protected static final int HOVER_BG = 0xFF81D4FA;
    protected static final int START_BG = 0xFFB2EBF2;
    protected static final int DISABLED_BG = 0xFFEEEEEE;
    protected static final int NORMAL_TEXT = 0xFF01579B;
    protected static final int SELECTED_TEXT = 0xFFFFFFFF;
    protected static final int DISABLED_TEXT = 0xFF80DEEA;
    protected static final int START_TEXT = 0xFF81D4FA;
    
    protected final StationListProvider provider;
    protected final List<String> stations = new ArrayList<>();
    protected int listX, listY, listWidth, listHeight;
    
    // 分页状态
    protected int currentPage = 0;
    protected int itemsPerPage;
protected int totalPages = 1;
    
    protected boolean visible = true;
    
    // 选择状态
    protected String selectedStation = "";
    protected int selectedIndex = -1;
    
    // 滚动条状态 (已移除)
    protected int scrollbarWidth = 6;
    protected int scrollbarMargin = 2;
    
    // 点击监听器
    private Consumer<String> clickListener;

    public BaseStationList(StationListProvider provider, 
                         int x, int y, int width, int height) {
        super(
            Minecraft.getInstance(), 
            width,
            height,
            y,
            y + height,
            20
        );
        this.provider = provider;
        this.listX = x;
        this.listY = y;
        this.listWidth = width;
        this.listHeight = height;
        this.setLeftPos(x);
        
        // 计算每页显示的项目数量
        this.itemsPerPage = Math.max(1, height / this.itemHeight);
    }
    
    // 设置点击监听器
    public void setOnClick(Consumer<String> listener) {
        this.clickListener = listener;
    }
    
    // 设置选中的车站
    public void setSelectedStation(String station) {
        this.selectedStation = station;
        if (provider != null) {
            provider.setSelectedStation(station);
        }
        updateSelectionIndex();
    }
    
    // 获取选中的车站
    public String getSelectedStation() {
        return selectedStation;
    }
    
    // 更新选中索引
    private void updateSelectionIndex() {
        this.selectedIndex = stations.indexOf(selectedStation);
    }
    
    public void setVisible(boolean visible) {
        this.visible = visible;
    }
    
    public void setPosition(int x, int y, int width, int height) {
        this.listX = x;
        this.listY = y;
        this.listWidth = width;
        this.listHeight = height;
        this.setLeftPos(x);
        this.y0 = y;
        this.y1 = y + height;
        this.width = width;
        this.height = height;
        
        // 重新计算每页显示的项目数量
        this.itemsPerPage = Math.max(1, height / this.itemHeight);
        updateTotalPages();
    }
    
    public void refreshStations(String filter) {
        this.clearEntries();
        Set<String> allStations = StationManager.getStations();
        stations.clear();
        
        for (String station : allStations) {
            if (filter.isEmpty() || station.toLowerCase().contains(filter.toLowerCase())) {
                stations.add(station);
            }
        }
        Collections.sort(stations);
        
        // 更新总页数
        updateTotalPages();
        
        // 确保当前页在有效范围内
        currentPage = Math.max(0, Math.min(currentPage, totalPages - 1));
        
        // 添加当前页的条目
        int startIndex = currentPage * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, stations.size());
        
        for (int i = startIndex; i < endIndex; i++) {
            String station = stations.get(i);
            this.addEntry(createEntry(station));
        }
        
        // 更新选中索引
        updateSelectionIndex();
    }
    
    private void updateTotalPages() {
        totalPages = stations.isEmpty() ? 1 : (int) Math.ceil((double) stations.size() / itemsPerPage);
    }
    
    protected abstract StationEntry createEntry(String station);
    
    protected abstract boolean canSelectStation(String station);
    
    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
        if (!visible) return;
        
        // 绘制背景
        guiGraphics.fill(
            this.x0, this.y0, 
            this.x0 + this.width, this.y0 + this.height, 
            BACKGROUND
        );
        
        // 绘制边框
        guiGraphics.renderOutline(
            this.x0, this.y0, 
            this.getWidth(), this.getHeight(), 
            0xFF03A9F4
        );
        
        // 绘制当前页的条目
        int startIndex = currentPage * itemsPerPage;
        int endIndex = Math.min(startIndex + itemsPerPage, stations.size());
        
        for (int i = startIndex; i < endIndex; i++) {
            int displayIndex = i - startIndex;
            StationEntry entry = this.getEntry(displayIndex);
            int yPos = this.y0 + (displayIndex * getItemHeight());
            
            if (yPos >= this.y0 && yPos + getItemHeight() <= this.y1) {
                boolean isHovered = isMouseOver(mouseX, mouseY) && 
                                   mouseY >= yPos && mouseY < yPos+ getItemHeight();
                boolean isSelected = stations.get(i).equals(selectedStation);
                
                entry.render(
                    guiGraphics, 
                    i, 
                    yPos, 
                    this.x0, 
                    this.getWidth(),
                    getItemHeight(), 
                    mouseX, 
                    mouseY, 
                    isHovered,
                    partialTicks
                );
            }
        }
    }
    
    @Override
    public boolean mouseClicked(double mouseX, double mouseY, int button) {
        if (!visible) return false;
        
        // 处理车站选择
        if (button == 0 && mouseX >= this.x0 && mouseX <= this.x0 + this.width && 
            mouseY >= this.y0 && mouseY <= this.y0 + this.height) {
            
            int relativeY = (int) (mouseY - this.y0);
            int index = relativeY / getItemHeight();
            int actualIndex = currentPage * itemsPerPage + index;
            
            if (actualIndex >= 0 && actualIndex < stations.size()) {
                String station = stations.get(actualIndex);
                if (canSelectStation(station)) {
                    setSelectedStation(station);
                    
                    // 触发点击监听器
                    if (clickListener != null) {
                        clickListener.accept(station);
                    }
                    return true;
                }
            }
        }
        
        return super.mouseClicked(mouseX, mouseY, button);
    }
    
    // 翻页方法
    public void nextPage() {
        if (currentPage < totalPages - 1) {
            currentPage++;
            refreshStations(provider != null ? provider.getSearchText() : "");
        }
    }
    
    public void prevPage() {
        if (currentPage > 0) {
            currentPage--;
            refreshStations(provider != null ? provider.getSearchText() : "");
        }
    }
    
    public boolean hasNextPage() {
        return currentPage < totalPages - 1;
    }
    
    public boolean hasPrevPage() {
        return currentPage > 0;
    }
    
    @Override
    public void updateNarration(NarrationElementOutput output) {
        output.add(NarratedElementType.TITLE, LanguageHelper.translate("narrator.ticketsystem.station_list"));
        
        for (int i = 0; i < this.getItemCount(); i++) {
            StationEntry entry = this.getEntry(i);
            entry.updateNarration(output);
        }
    }
    
    public int getCurrentPage() {
        return currentPage;
    }
    
    public int getTotalPages() {
        return totalPages;
    }
    
    public int getItemHeight() {
        return this.itemHeight;
    }
    
    protected void renderScrollingText(GuiGraphics guiGraphics, String text, 
                                      int left, int top, int width, int height, 
                                      int color, String stationKey) {
        int maxWidth = width - 10;
        int textWidth = Minecraft.getInstance().font.width(text);
        
        if (textWidth <= maxWidth) {
            guiGraphics.drawString(
                Minecraft.getInstance().font, 
                text, 
                left + 5, 
                top + (height - 8) / 2, 
                color, 
                false
            );
            return;
        }
        
        // 实现滚动文本
        long currentTime = System.currentTimeMillis();
        int scrollOffset = (int) ((currentTime / 30) % (textWidth + maxWidth));
        
        if (scrollOffset <= textWidth) {
            // 正常滚动阶段
            guiGraphics.drawString(
                Minecraft.getInstance().font, 
                text, 
                left + 5 - scrollOffset, 
                top + (height - 8) / 2, 
                color, 
                false
            );
        } else {
            // 暂停阶段 - 显示完整文本
            guiGraphics.drawString(
                Minecraft.getInstance().font, 
                text, 
                left + 5, 
                top + (height - 8) / 2, 
                color, 
                false
            );
        }
    }

    public abstract static class StationEntry extends AbstractSelectionList.Entry<StationEntry> {
        protected final String station;
        protected boolean isSelected;

        public StationEntry(String station) {
            this.station = station;
        }
        
        public abstract void render(GuiGraphics guiGraphics, int index, int top, int left, 
                                  int width, int height, int mouseX, int mouseY, 
                                  boolean isHovered, float partialTicks);
        
        public void updateNarration(NarrationElementOutput output) {
            output.add(NarratedElementType.TITLE, 
                Component.translatable("narrator.ticketsystem.station_entry", station));
        }
        
        public String getStation() {
            return station;
        }
        
        public void setSelected(boolean selected) {
            this.isSelected = selected;
        }
    }
    
    public interface StationListProvider {
        void setSelectedStation(String station);
        String getSelectedStation();
        String getSearchText();
        String getStartStation();
    }
    
    public int getHoveredIndex() {
        return -1; // 简化实现
    }
    
    public List<String> getStations() {
        return new ArrayList<>(); // 简化实现
    }
}
package com.easttown.ticketsystem.client;

import com.easttown.ticketsystem.screen.TicketMachineScreen;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.narration.NarratedElementType;
import net.minecraft.network.chat.Component;

public class AdminStationList extends BaseStationList {
    
    public AdminStationList(StationListProvider provider, 
                         int x, int y, int width, int height) {
        super(provider, x, y, width, height);
    }
    
    @Override
    protected AdminStationEntry createEntry(String station) {
        return new AdminStationEntry(station);
    }
    
    @Override
    protected boolean canSelectStation(String station) {
        // 管理员可以选择任何车站
        return true;
    }
    
    @Override
    public void updateNarration(NarrationElementOutput output) {
        output.add(NarratedElementType.TITLE, LanguageHelper.translate("narrator.ticketsystem.admin_station_list"));
    }
    
    public class AdminStationEntry extends StationEntry {
        public AdminStationEntry(String station) {
            super(station);
        }

        @Override
        public void render(GuiGraphics guiGraphics, int index, int top, int left, 
                          int width, int height, int mouseX, int mouseY, 
                          boolean isHovered, float partialTicks) {
            
            String startStation = provider != null ? provider.getStartStation() : "";
            boolean isStart = station.equals(startStation);
            
            // 绘制条目背景
            if (isSelected) {
                guiGraphics.fill(left, top, left + width, top + height, SELECTED_BG);
            } else if (isHovered) {
                guiGraphics.fill(left, top, left + width, top + height, HOVER_BG);
            } else if (isStart) {
                guiGraphics.fill(left, top, left + width, top + height, START_BG);
            } else {
                guiGraphics.fill(left, top, left + width, top + height, NORMAL_BG);
            }
            
            // 绘制车站名称
            int color = isStart ? START_TEXT : (isSelected ? SELECTED_TEXT : NORMAL_TEXT);
            renderScrollingText(guiGraphics, station, left, top, width, height, color, getStation());
        }
        
        @Override
        public void updateNarration(NarrationElementOutput output) {
            output.add(NarratedElementType.TITLE, Component.literal(station));
        }
    }
}
package com.easttown.ticketsystem.client;

import com.easttown.ticketsystem.init.MenuInit;
import com.easttown.ticketsystem.screen.*;
import com.easttown.ticketsystem.screen.terminal.ReissueMachineMainScreen;
import com.easttown.ticketsystem.screen.terminal.ReissueMachineAdminScreen;
import net.minecraft.client.gui.screens.MenuScreens;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;

@Mod.EventBusSubscriber(modid = "ticketsystem", value = Dist.CLIENT, bus = Mod.EventBusSubscriber.Bus.MOD)
public final class ClientSetup {

    private static volatile boolean screensRegistered = false;   // 二次注册防护

    @SubscribeEvent
    public static void onClientSetup(FMLClientSetupEvent event) {
        event.enqueueWork(() -> {
            if (!screensRegistered) {
                MenuScreens.register(MenuInit.TICKET_MACHINE_MENU.get(), TicketMachineScreen::new);
                MenuScreens.register(MenuInit.GATE_CONFIG_MENU.get(), GateConfigScreen::new);
                // 注册退票机器菜单
                MenuScreens.register(MenuInit.REISSUE_MACHINE_MAIN_MENU.get(), com.easttown.ticketsystem.screen.terminal.ReissueMachineMainScreen::new);
                // 注册退票机器管理员菜单
                MenuScreens.register(MenuInit.REISSUE_MACHINE_ADMIN_MENU.get(), com.easttown.ticketsystem.screen.terminal.ReissueMachineAdminScreen::new);
                screensRegistered = true;
            }

            // 其他仅客户端逻辑（已移除调试功能）
        });
    }
}
// DebugRenderer.java (辅助渲染)
package com.easttown.ticketsystem.client;

import com.mojang.blaze3d.vertex.PoseStack;
import com.mojang.blaze3d.vertex.VertexConsumer;
import net.minecraft.client.renderer.MultiBufferSource;
import net.minecraft.client.renderer.RenderType;
import net.minecraft.world.phys.AABB;

public class DebugRenderer {
    public static void renderAABB(PoseStack poseStack, MultiBufferSource buffer, 
                                 AABB aabb, int packedLight, 
                                 float r, float g, float b, float a) {
        VertexConsumer vertexConsumer = buffer.getBuffer(RenderType.LINES);
        
        double minX = aabb.minX;
        double minY = aabb.minY;
        double minZ = aabb.minZ;
        double maxX = aabb.maxX;
        double maxY = aabb.maxY;
        double maxZ = aabb.maxZ;
        
        // 绘制底部
        renderLine(vertexConsumer, poseStack, minX, minY, minZ, maxX, minY, minZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, minX, minY, minZ, minX, minY, maxZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, maxX, minY, minZ, maxX, minY, maxZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, minX, minY, maxZ, maxX, minY, maxZ, r, g, b, a);
        
        // 绘制顶部
        renderLine(vertexConsumer, poseStack, minX, maxY, minZ, maxX, maxY, minZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, minX, maxY, minZ, minX, maxY, maxZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, maxX, maxY, minZ, maxX, maxY, maxZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, minX, maxY, maxZ, maxX, maxY, maxZ, r, g, b, a);
        
        // 绘制侧边
        renderLine(vertexConsumer, poseStack, minX, minY, minZ, minX, maxY, minZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, maxX, minY, minZ, maxX, maxY, minZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, minX, minY, maxZ, minX, maxY, maxZ, r, g, b, a);
        renderLine(vertexConsumer, poseStack, maxX, minY, maxZ, maxX, maxY, maxZ, r, g, b, a);
    }
    
    private static void renderLine(VertexConsumer consumer, PoseStack poseStack, 
                                  double x1, double y1, double z1,
                                  double x2, double y2, double z2,
                                  float r, float g, float b, float a) {
        consumer.vertex(poseStack.last().pose(), (float) x1, (float) y1, (float) z1)
                .color(r, g, b, a)
                .normal(0, 1, 0)
                .endVertex();
        consumer.vertex(poseStack.last().pose(), (float) x2, (float) y2, (float) z2)
                .color(r, g, b, a)
                .normal(0, 1, 0)
                .endVertex();
    }
}
package com.easttown.ticketsystem.client;

import com.easttown.ticketsystem.screen.TicketMachineScreen;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.narration.NarratedElementType;
import net.minecraft.network.chat.Component;

public class UserStationList extends BaseStationList {

    public UserStationList(StationListProvider provider, 
                         int x, int y, int width, int height) {
        super(provider, x, y, width, height);
    }
    
    @Override
    protected UserStationEntry createEntry(String station) {
        return new UserStationEntry(station);
    }
    
    @Override
    protected boolean canSelectStation(String station) {
        // 用户不能选择起始站作为目的地
        if (provider != null && provider.getStartStation() != null) {
            return !station.equals(provider.getStartStation());
        }
        return true;
    }
    
    @Override
    public void updateNarration(NarrationElementOutput output) {
        output.add(NarratedElementType.TITLE, LanguageHelper.translate("narrator.ticketsystem.user_station_list"));
    }
    
    public class UserStationEntry extends StationEntry {
        public UserStationEntry(String station) {
            super(station);
        }

        @Override
        public void render(GuiGraphics guiGraphics, int index, int top, int left, 
                          int width, int height, int mouseX, int mouseY, 
                          boolean isHovered, float partialTicks) {
            
            String startStation = provider != null ? provider.getStartStation() : "";
            boolean isStart = station.equals(startStation);
            boolean isDisabled = !canSelectStation(station);

            // 绘制背景
            if (isStart) {
                guiGraphics.fill(left, top, left + width, top + height, START_BG);
            } else if (isSelected) {
                guiGraphics.fill(left, top, left + width, top + height, SELECTED_BG);
            } else if (isHovered) {
                guiGraphics.fill(left, top, left + width, top + height, HOVER_BG);
            } else if (isDisabled) {
                guiGraphics.fill(left, top, left + width, top + height, DISABLED_BG);
            } else {
                guiGraphics.fill(left, top, left + width, top + height, NORMAL_BG);
            }

            // 绘制文本
            int textColor;
            if (isStart) {
                textColor = START_TEXT;
            } else if (isSelected) {
                textColor = SELECTED_TEXT;
            } else if (isDisabled) {
                textColor = DISABLED_TEXT;
            } else {
                textColor = NORMAL_TEXT;
            }
            
            renderScrollingText(guiGraphics, station, left, top, width, height, textColor, getStation());
        }
        
        @Override
        public void updateNarration(NarrationElementOutput output) {
            output.add(NarratedElementType.TITLE, Component.literal(station));
        }
    }
}
package com.easttown.ticketsystem.command;

import com.easttown.ticketsystem.manager.StationManager;
import com.mojang.brigadier.Command;
import com.mojang.brigadier.context.CommandContext;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.network.chat.Component;

public class AddStationCommand {
    // 旧方法：不带坐标，默认坐标为0
    public static int execute(CommandContext<CommandSourceStack> context, String station) {
        return executeOld(context, station, 0, 0, 0);
    }

    // 旧方法：带坐标
    public static int execute(CommandContext<CommandSourceStack> context, String station, int x, int y, int z) {
        return executeOld(context, station, x, y, z);
    }

    // 旧方法实现
    private static int executeOld(CommandContext<CommandSourceStack> context, String station, int x, int y, int z) {
        // 添加车站坐标信息
        StationManager.addStation(station, x, y, z);
        context.getSource().sendSuccess(() ->
            Component.literal("已添加车站: " + station +
                (x == 0 && y == 0 && z == 0 ? "" : " 坐标: (" + x + ", " + y + ", " + z + ")")),
            true
        );
        return Command.SINGLE_SUCCESS;
    }

    // 新方法：完整信息，不带坐标
    public static int executeFull(CommandContext<CommandSourceStack> context,
                                 String chineseName, String englishName, String lineId) {
        return executeFull(context, chineseName, englishName, lineId, 0, 0, 0, 0);
    }

    // 新方法：完整信息，带站序号，不带坐标
    public static int executeFull(CommandContext<CommandSourceStack> context,
                                 String chineseName, String englishName, String lineId, int stationNumber) {
        return executeFull(context, chineseName, englishName, lineId, stationNumber, 0, 0, 0);
    }

    // 新方法：完整信息，带站序号和坐标
    public static int executeFull(CommandContext<CommandSourceStack> context,
                                 String chineseName, String englishName, String lineId,
                                 int stationNumber, int x, int y, int z) {
        boolean success = StationManager.addStationToLine(chineseName, englishName, lineId,
                                                         stationNumber, x, y, z);
        if (success) {
            String coordStr = (x == 0 && y == 0 && z == 0) ? "" :
                String.format(" 坐标: (%d, %d, %d)", x, y, z);
            String numberStr = stationNumber > 0 ? String.format(" (站序号: %02d)", stationNumber) : "";
            context.getSource().sendSuccess(() ->
                Component.literal(String.format("已添加车站: %s (%s) 到线路: %s%s%s",
                                               chineseName,
                                               englishName != null && !englishName.isEmpty() ? englishName : "无英文名",
                                               lineId, numberStr, coordStr)),
                true
            );
        } else {
            context.getSource().sendFailure(
                Component.literal("添加车站失败，请检查线路是否存在或编码是否冲突")
            );
        }
        return success ? Command.SINGLE_SUCCESS : 0;
    }
}package com.easttown.ticketsystem.command;

import com.easttown.ticketsystem.manager.StationManager;
import com.mojang.brigadier.Command;
import com.mojang.brigadier.context.CommandContext;
import com.mojang.brigadier.suggestion.Suggestions;
import com.mojang.brigadier.suggestion.SuggestionsBuilder;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.SharedSuggestionProvider;
import net.minecraft.network.chat.Component;

import java.util.concurrent.CompletableFuture;

public class DeleteStationCommand {
    public static int execute(CommandContext<CommandSourceStack> context, String station) {
        if (StationManager.containsStation(station)) {
            StationManager.removeStation(station);
            context.getSource().sendSuccess(() -> 
                Component.literal("已删除车站: " + station), true);
            return Command.SINGLE_SUCCESS;
        } else {
            context.getSource().sendFailure(
                Component.literal("车站不存在: " + station));
            return 0;
        }
    }
    
    public static CompletableFuture<Suggestions> getSuggestions(CommandContext<CommandSourceStack> context, SuggestionsBuilder builder) {
        return SharedSuggestionProvider.suggest(StationManager.getStations(), builder);
    }
}package com.easttown.ticketsystem.command;

import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import com.mojang.brigadier.arguments.StringArgumentType;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.commands.Commands;

public class TicketCommand {
    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
        dispatcher.register(
            Commands.literal("ticketsystem")
                .requires(source -> source.hasPermission(4))
                .then(
                    Commands.literal("addstation")
                        .then(
                            Commands.argument("chineseName", StringArgumentType.string())
                                .then(
                                    Commands.argument("englishName", StringArgumentType.string())
                                        .then(
                                            Commands.argument("lineId", StringArgumentType.string())
                                                // 基本版本：只有三个参数
                                                .executes(
                                                    context -> AddStationCommand.executeFull(
                                                        context,
                                                        StringArgumentType.getString(context, "chineseName"),
                                                        StringArgumentType.getString(context, "englishName"),
                                                        StringArgumentType.getString(context, "lineId")
                                                    )
                                                )
                                                // 可选站序号
                                                .then(
                                                    Commands.argument("stationNumber", IntegerArgumentType.integer(0, 99))
                                                        .executes(
                                                            context -> AddStationCommand.executeFull(
                                                                context,
                                                                StringArgumentType.getString(context, "chineseName"),
                                                                StringArgumentType.getString(context, "englishName"),
                                                                StringArgumentType.getString(context, "lineId"),
                                                                IntegerArgumentType.getInteger(context, "stationNumber")
                                                            )
                                                        )
                                                        // 可选坐标
                                                        .then(
                                                            Commands.argument("x", IntegerArgumentType.integer())
                                                                .then(
                                                                    Commands.argument("y", IntegerArgumentType.integer())
                                                                        .then(
                                                                            Commands.argument("z", IntegerArgumentType.integer())
                                                                                .executes(
                                                                                    context -> AddStationCommand.executeFull(
                                                                                        context,
                                                                                        StringArgumentType.getString(context, "chineseName"),
                                                                                        StringArgumentType.getString(context, "englishName"),
                                                                                        StringArgumentType.getString(context, "lineId"),
                                                                                        IntegerArgumentType.getInteger(context, "stationNumber"),
                                                                                        IntegerArgumentType.getInteger(context, "x"),
                                                                                        IntegerArgumentType.getInteger(context, "y"),
                                                                                        IntegerArgumentType.getInteger(context, "z")
                                                                                    )
                                                                                )
                                                                        )
                                                                )
                                                        )
                                                )
                                        )
                                )
                        )
                )
                // 添加车站完整信息命令（中文名、英文名、线路ID）
                .then(
                    Commands.literal("addstationfull")
                        .then(
                            Commands.argument("chineseName", StringArgumentType.string())
                                .then(
                                    Commands.argument("englishName", StringArgumentType.string())
                                        .then(
                                            Commands.argument("lineId", StringArgumentType.string())
                                                // 基本版本：只有三个参数
                                                .executes(
                                                    context -> AddStationCommand.executeFull(
                                                        context,
                                                        StringArgumentType.getString(context, "chineseName"),
                                                        StringArgumentType.getString(context, "englishName"),
                                                        StringArgumentType.getString(context, "lineId")
                                                    )
                                                )
                                                // 可选站序号
                                                .then(
                                                    Commands.argument("stationNumber", IntegerArgumentType.integer(0, 99))
                                                        .executes(
                                                            context -> AddStationCommand.executeFull(
                                                                context,
                                                                StringArgumentType.getString(context, "chineseName"),
                                                                StringArgumentType.getString(context, "englishName"),
                                                                StringArgumentType.getString(context, "lineId"),
                                                                IntegerArgumentType.getInteger(context, "stationNumber")
                                                            )
                                                        )
                                                        // 可选坐标
                                                        .then(
                                                            Commands.argument("x", IntegerArgumentType.integer())
                                                                .then(
                                                                    Commands.argument("y", IntegerArgumentType.integer())
                                                                        .then(
                                                                            Commands.argument("z", IntegerArgumentType.integer())
                                                                                .executes(
                                                                                    context -> AddStationCommand.executeFull(
                                                                                        context,
                                                                                        StringArgumentType.getString(context, "chineseName"),
                                                                                        StringArgumentType.getString(context, "englishName"),
                                                                                        StringArgumentType.getString(context, "lineId"),
                                                                                        IntegerArgumentType.getInteger(context, "stationNumber"),
                                                                                        IntegerArgumentType.getInteger(context, "x"),
                                                                                        IntegerArgumentType.getInteger(context, "y"),
                                                                                        IntegerArgumentType.getInteger(context, "z")
                                                                                    )
                                                                                )
                                                                        )
                                                                )
                                                        )
                                                )
                                        )
                                )
                        )
                )
                // 修复点运算符位置和缺失的括号
                .then(
                    Commands.literal("deletestation")
                        .then(
                            Commands.argument("station", StringArgumentType.string())
                                .suggests((context, builder) -> DeleteStationCommand.getSuggestions(context, builder))
                                .executes(
                                    context -> DeleteStationCommand.execute(
                                        context,
                                        StringArgumentType.getString(context, "station")
                                    )
                                )
                        )
                )
                // 添加车站管理GUI命令
                .then(
                    Commands.literal("managestations")
                        .executes(ManageStationsCommand::execute)
                )
                // 添加重新加载配置命令
                .then(
                    Commands.literal("reload")
                        .executes(ReloadCommand::execute)
                )
        );
    }
}
package com.easttown.ticketsystem.command;

import com.easttown.ticketsystem.config.TicketSystemConfig;
import com.easttown.ticketsystem.manager.StationManager;
import com.easttown.ticketsystem.util.DebugLogger;
import com.mojang.brigadier.Command;
import com.mojang.brigadier.context.CommandContext;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.network.chat.Component;

public class ReloadCommand {

    public static int execute(CommandContext<CommandSourceStack> context) {
        try {
            CommandSourceStack source = context.getSource();

            // 重新加载配置文件
            reloadConfigurations(source);

            source.sendSuccess(() ->
                Component.literal("票务系统配置已重新加载"), true);

            return Command.SINGLE_SUCCESS;

        } catch (Exception e) {
            context.getSource().sendFailure(
                Component.literal("重新加载配置时发生错误: " + e.getMessage())
            );
            DebugLogger.error("Reload command failed", e);
            return 0;
        }
    }

    private static void reloadConfigurations(CommandSourceStack source) {
        // 重新加载车站数据
        StationManager.reloadStations();

        // Forge配置会自动重新加载，不需要手动调用
        // 这里可以添加其他需要重新加载的配置

        DebugLogger.info("Configurations reloaded successfully");
    }
}package com.easttown.ticketsystem.command;

import com.easttown.ticketsystem.network.NetworkHandler;
import com.easttown.ticketsystem.network.OpenStationManagementPacket;
import com.mojang.brigadier.Command;
import com.mojang.brigadier.context.CommandContext;
import net.minecraft.commands.CommandSourceStack;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;

/**
 * 打开车站管理GUI命令
 * 发送网络包到客户端打开车站管理界面
 */
public class ManageStationsCommand {
    public static int execute(CommandContext<CommandSourceStack> context) {
        CommandSourceStack source = context.getSource();

        // 检查执行者是否为玩家
        ServerPlayer player = source.getPlayer();
        if (player != null) {
            // 发送打开车站管理GUI的网络包
            NetworkHandler.sendToPlayer(new OpenStationManagementPacket(), player);
            source.sendSuccess(() ->
                Component.literal("已发送车站管理界面打开请求"),
                true
            );
            return Command.SINGLE_SUCCESS;
        } else {
            source.sendFailure(Component.literal("此命令只能由玩家执行"));
            return 0;
        }
    }
}package com.easttown.ticketsystem.config;

import net.minecraftforge.common.ForgeConfigSpec;

public class TicketSystemConfig {
    public static final ForgeConfigSpec.Builder BUILDER = new ForgeConfigSpec.Builder();
    public static final ForgeConfigSpec SPEC;

    // 调试设置
    public static final ForgeConfigSpec.BooleanValue SHOW_DEBUG_LOGS;

    // 硬币类型配置
    public static final ForgeConfigSpec.ConfigValue<String> COPPER_COIN_ITEM;
    public static final ForgeConfigSpec.ConfigValue<String> IRON_COIN_ITEM;
    public static final ForgeConfigSpec.ConfigValue<String> GOLD_COIN_ITEM;
    public static final ForgeConfigSpec.ConfigValue<String> EMERALD_COIN_ITEM;
    public static final ForgeConfigSpec.ConfigValue<String> DIAMOND_COIN_ITEM;
    public static final ForgeConfigSpec.ConfigValue<String> NETHERITE_COIN_ITEM;

    // 硬币汇率
    public static final ForgeConfigSpec.IntValue COPPER_TO_IRON_RATE;
    public static final ForgeConfigSpec.IntValue IRON_TO_GOLD_RATE;
    public static final ForgeConfigSpec.IntValue GOLD_TO_EMERALD_RATE;
    public static final ForgeConfigSpec.IntValue EMERALD_TO_DIAMOND_RATE;
    public static final ForgeConfigSpec.IntValue DIAMOND_TO_NETHERITE_RATE;

    // 每格距离的费用（支持小数，向上取整）
    public static final ForgeConfigSpec.DoubleValue COST_PER_BLOCK;

    // 退款阶梯配置
    public static final ForgeConfigSpec.DoubleValue REFUND_HALF_HOUR_RATE;
    public static final ForgeConfigSpec.DoubleValue REFUND_ONE_HOUR_RATE;
    public static final ForgeConfigSpec.DoubleValue REFUND_TWO_HOURS_RATE;
    public static final ForgeConfigSpec.DoubleValue REFUND_SIX_HOURS_RATE;
    public static final ForgeConfigSpec.DoubleValue REFUND_ONE_DAY_RATE;

    // Web服务器配置
    public static final ForgeConfigSpec.IntValue WEB_SERVER_PORT;

    static {
        BUILDER.push("调试设置");

        SHOW_DEBUG_LOGS = BUILDER
            .comment("是否在控制台显示调试日志 (默认: true)")
            .define("showDebugLogs", true);

        BUILDER.pop();

        BUILDER.push("硬币系统设置");

        // 硬币物品注册名
        COPPER_COIN_ITEM = BUILDER.comment("铜币物品ID")
            .define("copper_coin_item", "ticketsystem:copper_coin");
        IRON_COIN_ITEM = BUILDER.comment("铁币物品ID")
            .define("iron_coin_item", "ticketsystem:iron_coin");
        GOLD_COIN_ITEM = BUILDER.comment("金币物品ID")
            .define("gold_coin_item", "ticketsystem:gold_coin");
        EMERALD_COIN_ITEM = BUILDER.comment("绿宝石币物品ID")
            .define("emerald_coin_item", "ticketsystem:emerald_coin");
        DIAMOND_COIN_ITEM = BUILDER.comment("钻石币物品ID")
            .define("diamond_coin_item", "ticketsystem:diamond_coin");
        NETHERITE_COIN_ITEM = BUILDER.comment("下界合金币物品ID")
            .define("netherite_coin_item", "ticketsystem:netherite_coin");

        // 硬币兑换汇率
        COPPER_TO_IRON_RATE = BUILDER.comment("铜币兑换铁币汇率 (1铁币 = X铜币)")
            .defineInRange("copper_to_iron_rate", 10, 1, 1000);
        IRON_TO_GOLD_RATE = BUILDER.comment("铁币兑换金币汇率 (1金币 = X铁币)")
            .defineInRange("iron_to_gold_rate", 10, 1, 1000);
        GOLD_TO_EMERALD_RATE = BUILDER.comment("金币兑换绿宝石币汇率 (1绿宝石币 = X金币)")
            .defineInRange("gold_to_emerald_rate", 10, 1, 1000);
        EMERALD_TO_DIAMOND_RATE = BUILDER.comment("绿宝石币兑换钻石币汇率 (1钻石币 = X绿宝石币)")
            .defineInRange("emerald_to_diamond_rate", 10, 1, 1000);
        DIAMOND_TO_NETHERITE_RATE = BUILDER.comment("钻石币兑换下界合金币汇率 (1下界合金币 = X钻石币)")
            .defineInRange("diamond_to_netherite_rate", 10, 1, 1000);

        // 每格距离费用（支持小数，向上取整）
        COST_PER_BLOCK = BUILDER.comment("每格距离费用 (铜币，支持小数，向上取整)")
            .defineInRange("cost_per_block", 1.0, 0.01, 100.0);

        BUILDER.pop();

        BUILDER.push("退票设置");

        // 退款阶梯配置
        REFUND_HALF_HOUR_RATE = BUILDER.comment("30分钟内退款比例 (0.0-1.0)")
            .defineInRange("refund_half_hour_rate", 1.0, 0.0, 1.0);
        REFUND_ONE_HOUR_RATE = BUILDER.comment("1小时内退款比例 (0.0-1.0)")
            .defineInRange("refund_one_hour_rate", 0.75, 0.0, 1.0);
        REFUND_TWO_HOURS_RATE = BUILDER.comment("2小时内退款比例 (0.0-1.0)")
            .defineInRange("refund_two_hours_rate", 0.5, 0.0, 1.0);
        REFUND_SIX_HOURS_RATE = BUILDER.comment("6小时内退款比例 (0.0-1.0)")
            .defineInRange("refund_six_hours_rate", 0.25, 0.0, 1.0);
        REFUND_ONE_DAY_RATE = BUILDER.comment("24小时内退款比例 (0.0-1.0)")
            .defineInRange("refund_one_day_rate", 0.1, 0.0, 1.0);

        BUILDER.pop();

        BUILDER.push("Web服务器设置");

        WEB_SERVER_PORT = BUILDER.comment("Web服务器端口 (默认: 23333)")
            .defineInRange("web_server_port", 23333, 1024, 65535);

        BUILDER.pop();

        SPEC = BUILDER.build();
    }

    // 调试相关方法
    public static boolean showDebugLogs() {
        return SHOW_DEBUG_LOGS.get();
    }

    // 硬币汇率相关方法
    public static int getCopperToIronRate() {
        return COPPER_TO_IRON_RATE.get();
    }

    public static int getIronToGoldRate() {
        return IRON_TO_GOLD_RATE.get();
    }

    public static int getGoldToEmeraldRate() {
        return GOLD_TO_EMERALD_RATE.get();
    }

    public static int getEmeraldToDiamondRate() {
        return EMERALD_TO_DIAMOND_RATE.get();
    }

    public static int getDiamondToNetheriteRate() {
        return DIAMOND_TO_NETHERITE_RATE.get();
    }

    // 计费相关方法
    public static double getCostPerBlock() {
        return COST_PER_BLOCK.get();
    }

    /**
     * 计算总费用（向上取整）
     * @param distance 距离（方块数）
     * @return 总费用（铜币，向上取整）
     */
    public static int calculateTotalCost(int distance) {
        double totalCost = distance * getCostPerBlock();
        return (int) Math.ceil(totalCost);
    }

    // 退款配置相关方法
    public static double getRefundHalfHourRate() {
        return REFUND_HALF_HOUR_RATE.get();
    }

    public static double getRefundOneHourRate() {
        return REFUND_ONE_HOUR_RATE.get();
    }

    public static double getRefundTwoHoursRate() {
        return REFUND_TWO_HOURS_RATE.get();
    }

    public static double getRefundSixHoursRate() {
        return REFUND_SIX_HOURS_RATE.get();
    }

    public static double getRefundOneDayRate() {
        return REFUND_ONE_DAY_RATE.get();
    }

    // Web服务器相关方法
    public static int getWebServerPort() {
        return WEB_SERVER_PORT.get();
    }
}package com.easttown.ticketsystem.data;

public class StationData {
    private final int x;
    private final int y;
    private final int z;
    private int price; // 价格（以铜币为单位）
    
    public StationData(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.price = 100; // 默认价格
    }
    
    public int getX() {
        return x;
    }
    
    public int getY() {
        return y;
    }
    
    public int getZ() {
        return z;
    }
    
    public int getPrice() {
        return price;
    }
    
    public void setPrice(int price) {
        this.price = price;
    }
}package com.easttown.ticketsystem.data;

/**
 * 车站数据类 - 参考web版本的stations.json结构
 * 文档要求：删除双票价系统，简化实现，参考web版本数据结构
 */
public class Station {
    private final String code;        // 车站编码，如"01-01"（唯一标识）
    private String name;             // 车站中文名称
    private String enName;           // 车站英文名称（可选）
    private int x, y, z;             // 坐标（用于Minecraft地图显示）

    public Station(String code, String name) {
        this.code = code;
        this.name = name;
        this.enName = "";
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }

    public Station(String code, String name, String enName, int x, int y, int z) {
        this.code = code;
        this.name = name;
        this.enName = enName;
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Getter方法
    public String getCode() {
        return code;
    }

    public String getName() {
        return name;
    }

    public String getEnName() {
        return enName;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public int getZ() {
        return z;
    }

    // Setter方法（除了code是final）
    public void setName(String name) {
        this.name = name;
    }

    public void setEnName(String enName) {
        this.enName = enName;
    }

    public void setX(int x) {
        this.x = x;
    }

    public void setY(int y) {
        this.y = y;
    }

    public void setZ(int z) {
        this.z = z;
    }

    /**
     * 设置坐标
     */
    public void setCoordinates(int x, int y, int z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * 检查坐标是否有效
     * @return 坐标是否在合理范围内
     */
    public boolean isValidCoordinate() {
        // Minecraft世界坐标范围
        return x >= -30000000 && x <= 30000000 &&
               y >= -2048 && y <= 2048 &&
               z >= -30000000 && z <= 30000000;
    }

    @Override
    public String toString() {
        return String.format("Station{code='%s', name='%s', enName='%s', x=%d, y=%d, z=%d}",
                code, name, enName, x, y, z);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Station station = (Station) obj;
        return code.equals(station.code);
    }

    @Override
    public int hashCode() {
        return code.hashCode();
    }
}package com.easttown.ticketsystem.data;

import java.util.ArrayList;
import java.util.List;

/**
 * 线路数据类 - 参考web版本的lines.json结构
 * 文档要求：简化线路显示，不使用SVG，只显示车站归属关系
 */
public class Line {
    private final String id;          // 线路ID，如"1"（唯一）
    private String name;             // 线路中文名称
    private String enName;           // 线路英文名称（可选）
    private String color;            // 线路颜色，如"#FF0000"或颜色名称
    private List<String> stationCodes; // 车站编码列表（有序）

    public Line(String id, String name, String color) {
        this.id = id;
        this.name = name;
        this.enName = "";
        this.color = color;
        this.stationCodes = new ArrayList<>();
    }

    public Line(String id, String name, String enName, String color) {
        this.id = id;
        this.name = name;
        this.enName = enName;
        this.color = color;
        this.stationCodes = new ArrayList<>();
    }

    // Getter方法
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEnName() {
        return enName;
    }

    public String getColor() {
        return color;
    }

    public List<String> getStationCodes() {
        return stationCodes;
    }

    // Setter方法（除了id是final）
    public void setName(String name) {
        this.name = name;
    }

    public void setEnName(String enName) {
        this.enName = enName;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public void setStationCodes(List<String> stationCodes) {
        this.stationCodes = stationCodes;
    }

    // 便捷方法
    /**
     * 添加车站到线路末尾
     * @param stationCode 车站编码
     */
    public void addStation(String stationCode) {
        if (!stationCodes.contains(stationCode)) {
            stationCodes.add(stationCode);
        }
    }

    /**
     * 在指定位置插入车站
     * @param index 插入位置
     * @param stationCode 车站编码
     */
    public void insertStation(int index, String stationCode) {
        if (!stationCodes.contains(stationCode)) {
            if (index >= 0 && index <= stationCodes.size()) {
                stationCodes.add(index, stationCode);
            } else {
                stationCodes.add(stationCode);
            }
        }
    }

    /**
     * 移除车站
     * @param stationCode 车站编码
     * @return 是否成功移除
     */
    public boolean removeStation(String stationCode) {
        return stationCodes.remove(stationCode);
    }

    /**
     * 获取车站数量
     */
    public int getStationCount() {
        return stationCodes.size();
    }

    /**
     * 检查是否包含指定车站
     */
    public boolean containsStation(String stationCode) {
        return stationCodes.contains(stationCode);
    }

    /**
     * 获取车站在线路中的顺序（0-based）
     * @return 位置索引，如果不存在返回-1
     */
    public int getStationOrder(String stationCode) {
        return stationCodes.indexOf(stationCode);
    }

    /**
     * 获取相邻车站（如果存在）
     * @param stationCode 当前车站
     * @return 前一个和后一个车站的数组[prev, next]，可能为null
     */
    public String[] getAdjacentStations(String stationCode) {
        int index = stationCodes.indexOf(stationCode);
        if (index == -1) {
            return null;
        }

        String prev = index > 0 ? stationCodes.get(index - 1) : null;
        String next = index < stationCodes.size() - 1 ? stationCodes.get(index + 1) : null;
        return new String[]{prev, next};
    }

    /**
     * 检查线路是否有效（至少有2个车站）
     */
    public boolean isValid() {
        return stationCodes.size() >= 2;
    }

    @Override
    public String toString() {
        return String.format("Line{id='%s', name='%s', enName='%s', color='%s', stations=%d}",
                id, name, enName, color, stationCodes.size());
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Line line = (Line) obj;
        return id.equals(line.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}package com.easttown.ticketsystem.data;

/**
 * 票价数据类 - 参考web版本的fares.json结构
 * 文档要求：删除双票价系统，只保留单票价
 */
public class Fare {
    private final String fromStation;  // 起点车站编码
    private final String toStation;    // 终点车站编码
    private final int price;           // 票价（铜币）

    public Fare(String fromStation, String toStation, int price) {
        this.fromStation = fromStation;
        this.toStation = toStation;
        this.price = price;
    }

    // Getter方法
    public String getFromStation() {
        return fromStation;
    }

    public String getToStation() {
        return toStation;
    }

    public int getPrice() {
        return price;
    }

    /**
     * 检查票价是否有效（价格为正数，车站编码不为空）
     */
    public boolean isValid() {
        return fromStation != null && !fromStation.isEmpty() &&
               toStation != null && !toStation.isEmpty() &&
               price > 0;
    }

    /**
     * 检查是否为指定区间的票价（方向敏感）
     */
    public boolean isForSegment(String from, String to) {
        return fromStation.equals(from) && toStation.equals(to);
    }

    /**
     * 检查是否为指定区间的票价（方向不敏感，双向匹配）
     */
    public boolean isForSegmentBidirectional(String station1, String station2) {
        return (fromStation.equals(station1) && toStation.equals(station2)) ||
               (fromStation.equals(station2) && toStation.equals(station1));
    }

    /**
     * 获取对称票价（交换起点终点）
     */
    public Fare getSymmetricFare() {
        return new Fare(toStation, fromStation, price);
    }

    @Override
    public String toString() {
        return String.format("Fare{from='%s', to='%s', price=%d}",
                fromStation, toStation, price);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Fare fare = (Fare) obj;
        // 方向敏感的相等性比较
        return price == fare.price &&
               fromStation.equals(fare.fromStation) &&
               toStation.equals(fare.toStation);
    }

    @Override
    public int hashCode() {
        int result = fromStation.hashCode();
        result = 31 * result + toStation.hashCode();
        result = 31 * result + price;
        return result;
    }
}package com.easttown.ticketsystem.data;

import java.util.ArrayList;
import java.util.List;

/**
 * 路径计算结果类
 * 用于存储票价计算的结果：经过的车站、线路、总价格等
 */
public class Route {
    private List<String> stationPath;   // 经过的车站编码列表
    private List<String> linePath;      // 经过的线路ID列表（用于换乘显示）
    private int totalPrice;             // 总价格（铜币）
    private int transferCount;          // 换乘次数
    private int stationCount;           // 经过的车站数（不包括起点）
    private String startStation;        // 起点车站
    private String endStation;          // 终点车站

    public Route(String startStation, String endStation) {
        this.startStation = startStation;
        this.endStation = endStation;
        this.stationPath = new ArrayList<>();
        this.linePath = new ArrayList<>();
        this.totalPrice = 0;
        this.transferCount = 0;
        this.stationCount = 0;
    }

    public Route(List<String> stationPath, List<String> linePath, int totalPrice,
                 int transferCount, String startStation, String endStation) {
        this.stationPath = new ArrayList<>(stationPath);
        this.linePath = new ArrayList<>(linePath);
        this.totalPrice = totalPrice;
        this.transferCount = transferCount;
        this.stationCount = stationPath.size() - 1; // 不包括起点
        this.startStation = startStation;
        this.endStation = endStation;
    }

    // Getter方法
    public List<String> getStationPath() {
        return new ArrayList<>(stationPath);
    }

    public List<String> getLinePath() {
        return new ArrayList<>(linePath);
    }

    public int getTotalPrice() {
        return totalPrice;
    }

    public int getTransferCount() {
        return transferCount;
    }

    public int getStationCount() {
        return stationCount;
    }

    public String getStartStation() {
        return startStation;
    }

    public String getEndStation() {
        return endStation;
    }

    // Setter方法
    public void setStationPath(List<String> stationPath) {
        this.stationPath = new ArrayList<>(stationPath);
        this.stationCount = stationPath.size() - 1; // 更新车站数
    }

    public void setLinePath(List<String> linePath) {
        this.linePath = new ArrayList<>(linePath);
    }

    public void setTotalPrice(int totalPrice) {
        this.totalPrice = totalPrice;
    }

    public void setTransferCount(int transferCount) {
        this.transferCount = transferCount;
    }

    // 便捷方法
    public void addStationToPath(String stationCode) {
        stationPath.add(stationCode);
        stationCount = stationPath.size() - 1;
    }

    public void addLineToPath(String lineId) {
        linePath.add(lineId);
    }

    public void addToTotalPrice(int price) {
        totalPrice += price;
    }

    public void incrementTransferCount() {
        transferCount++;
    }

    /**
     * 获取路径描述（简化显示）
     */
    public String getDescription() {
        if (stationPath.isEmpty()) {
            return String.format("从 %s 到 %s: 无路径", startStation, endStation);
        }

        StringBuilder sb = new StringBuilder();
        sb.append(String.format("从 %s 到 %s: ", startStation, endStation));

        if (stationCount > 0) {
            sb.append(String.format("经过 %d 站", stationCount));
        } else {
            sb.append("直达");
        }

        if (transferCount > 0) {
            sb.append(String.format("，换乘 %d 次", transferCount));
        }

        sb.append(String.format("，票价 %d 铜币", totalPrice));
        return sb.toString();
    }

    /**
     * 检查路径是否有效（包含起点和终点）
     */
    public boolean isValid() {
        if (stationPath.isEmpty()) return false;
        String first = stationPath.get(0);
        String last = stationPath.get(stationPath.size() - 1);
        return startStation.equals(first) && endStation.equals(last);
    }

    /**
     * 获取换乘点列表
     */
    public List<String> getTransferPoints() {
        List<String> transfers = new ArrayList<>();
        if (linePath.size() <= 1) {
            return transfers; // 无需换乘
        }

        // 线路切换的位置就是换乘点
        String currentLine = linePath.get(0);
        for (int i = 1; i < linePath.size(); i++) {
            if (!linePath.get(i).equals(currentLine)) {
                // 线路切换，对应的车站是换乘点
                if (i - 1 < stationPath.size()) {
                    transfers.add(stationPath.get(i - 1));
                }
                currentLine = linePath.get(i);
            }
        }

        return transfers;
    }

    @Override
    public String toString() {
        return String.format("Route{start='%s', end='%s', stations=%d, lines=%d, price=%d, transfers=%d}",
                startStation, endStation, stationCount, linePath.size(), totalPrice, transferCount);
    }
}package com.easttown.ticketsystem.init;

import com.easttown.ticketsystem.block.GateBlockEntity;
import com.easttown.ticketsystem.block.TicketMachineBlockEntity;
import com.easttown.ticketsystem.block.ReissueMachineBlockEntity;
import net.minecraft.world.level.block.entity.BlockEntityType;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;
import com.easttown.ticketsystem.*;

public class BlockEntityInit {
    public static final DeferredRegister<
            BlockEntityType<
                    ?>> BLOCK_ENTITIES = DeferredRegister.create(ForgeRegistries.BLOCK_ENTITY_TYPES, TicketSystemMod.MODID);

    public static final RegistryObject<
            BlockEntityType<
                    TicketMachineBlockEntity>> TICKET_MACHINE = BLOCK_ENTITIES.register("ticket_machine",
            () -> BlockEntityType.Builder.of(
                    TicketMachineBlockEntity::new,
                    BlockInit.TICKET_MACHINE.get()
            ).build(null));

    // 添加闸机方块实体的注册
    public static final RegistryObject<
            BlockEntityType<GateBlockEntity>> GATE = BLOCK_ENTITIES.register("gate",
            () -> BlockEntityType.Builder.of(
                    GateBlockEntity::new,
                    BlockInit.GATE.get()
            ).build(null));
    // 添加补票机器方块实体
    public static final RegistryObject<
            BlockEntityType<
                    ReissueMachineBlockEntity>> REISSUE_MACHINE = BLOCK_ENTITIES.register("reissue_machine",
            () -> BlockEntityType.Builder.of(
                    ReissueMachineBlockEntity::new,
                    BlockInit.REISSUE_MACHINE.get()
            ).build(null));

}
package com.easttown.ticketsystem.init;

import com.easttown.ticketsystem.TicketSystemMod;
//import com.easttown.ticketsystem.block.GateBlock;
//import com.easttown.ticketsystem.block.TicketMachineBlock;
import com.easttown.ticketsystem.block.GateBlock;
import com.easttown.ticketsystem.block.TicketMachineBlock;
import com.easttown.ticketsystem.block.ReissueMachineBlock;
import net.minecraft.world.level.block.Block;
import net.minecraft.world.level.block.SoundType;
import net.minecraft.world.level.block.state.BlockBehaviour;
import net.minecraft.world.level.material.MapColor;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

public class BlockInit {
    public static final DeferredRegister<Block> BLOCKS = 
        DeferredRegister.create(ForgeRegistries.BLOCKS, TicketSystemMod.MODID);
    
    public static final RegistryObject<Block> TICKET_MACHINE = BLOCKS.register("ticket_machine", 
        () -> new TicketMachineBlock(BlockBehaviour.Properties.of()
            .strength(3.5f)
            .sound(SoundType.METAL)
            .requiresCorrectToolForDrops()
            .noOcclusion()
    ));
    
    // 添加闸机方块的注册
    public static final RegistryObject<Block> GATE = BLOCKS.register("gate", 
        () -> new GateBlock(BlockBehaviour.Properties.of()
            .strength(3.5f)
            .sound(SoundType.METAL)
            .requiresCorrectToolForDrops()
            .noOcclusion()
    ));
    
    // 添加补票机器方块
public static final RegistryObject<Block> REISSUE_MACHINE = BLOCKS.register("reissue_machine",
    () -> new ReissueMachineBlock(BlockBehaviour.Properties.of()
        .mapColor(MapColor.METAL)
        .strength(5.0f, 6.0f)
        .sound(SoundType.METAL)
        .requiresCorrectToolForDrops()
        .noOcclusion()
));

    // 添加自定义蛋糕方块（功能与原版蛋糕完全相同）
    public static final RegistryObject<Block> CUSTOM_CAKE = BLOCKS.register("custom_cake",
        () -> new net.minecraft.world.level.block.CakeBlock(BlockBehaviour.Properties.of()
            .strength(0.5F)
            .sound(SoundType.WOOL)
    ));

}
package com.easttown.ticketsystem.init;

import com.easttown.ticketsystem.item.*;
import net.minecraft.world.item.BlockItem;
import net.minecraft.world.item.Item;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;
import com.easttown.ticketsystem.*;

public class ItemInit {
    public static final DeferredRegister<Item> ITEMS = DeferredRegister.create(ForgeRegistries.ITEMS,
            TicketSystemMod.MODID);

    // 原有物品
    public static final RegistryObject<Item> TICKET_MACHINE_ITEM = ITEMS.register("ticket_machine",
            () -> new BlockItem(BlockInit.TICKET_MACHINE.get(), new Item.Properties()));
    public static final RegistryObject<Item> TICKET = ITEMS.register("ticket",
            () -> new TicketItem(new Item.Properties().stacksTo(1)));
    public static final RegistryObject<Item> ADMIN_KEY = ITEMS.register("admin_key",
            () -> new AdminKeyItem(new Item.Properties().stacksTo(1)));

    // 硬币物品
    public static final RegistryObject<Item> COPPER_COIN = ITEMS.register("copper_coin",
            CopperCoinItem::new);
    public static final RegistryObject<Item> IRON_COIN = ITEMS.register("iron_coin",
            IronCoinItem::new);
    public static final RegistryObject<Item> GOLD_COIN = ITEMS.register("gold_coin",
            GoldCoinItem::new);
    public static final RegistryObject<Item> DIAMOND_COIN = ITEMS.register("diamond_coin",
            DiamondCoinItem::new);
    public static final RegistryObject<Item> EMERALD_COIN = ITEMS.register("emerald_coin",
            EmeraldCoinItem::new);
    public static final RegistryObject<Item> NETHERITE_COIN = ITEMS.register("netherite_coin",
            NetheriteCoinItem::new);
    public static final RegistryObject<Item> ITEM9875IS0 = ITEMS.register("9875is0",
            ITEM9875is0::new);
            // 在ItemInit类中添加
    public static final RegistryObject<Item> REIMBURSEMENT_VOUCHER = ITEMS.register("reimbursement_voucher",
            () -> new ReimbursementVoucherItem(new Item.Properties()));

    
    // 闸机物品
    public static final RegistryObject<Item> GATE_ITEM = ITEMS.register("gate",
            () -> new BlockItem(BlockInit.GATE.get(), new Item.Properties()));
            public static final RegistryObject<Item> REISSUE_MACHINE_ITEM = ITEMS.register("reissue_machine",
        () -> new BlockItem(BlockInit.REISSUE_MACHINE.get(), new Item.Properties()));

    // 添加自定义蛋糕物品
    public static final RegistryObject<Item> CUSTOM_CAKE_ITEM = ITEMS.register("custom_cake",
        () -> new BlockItem(BlockInit.CUSTOM_CAKE.get(), new Item.Properties()));
}
package com.easttown.ticketsystem.init;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.screen.GateConfigMenu;
import com.easttown.ticketsystem.screen.TicketMachineMenu;
import com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineMainMenu;
import com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineAdminMenu;
import net.minecraft.core.BlockPos;
import net.minecraft.world.inventory.MenuType;
import net.minecraftforge.common.extensions.IForgeMenuType;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.ForgeRegistries;
import net.minecraftforge.registries.RegistryObject;

public class MenuInit {
    public static final DeferredRegister<MenuType<?>> MENUS = 
        DeferredRegister.create(ForgeRegistries.MENU_TYPES, TicketSystemMod.MODID);
    
    public static final RegistryObject<MenuType<TicketMachineMenu>> TICKET_MACHINE_MENU = 
        MENUS.register("ticket_machine_menu", 
            () -> IForgeMenuType.create((windowId, inv, data) -> 
                new TicketMachineMenu(windowId, inv, data)));
    
    // 添加闸机配置菜单注册
    public static final RegistryObject<MenuType<GateConfigMenu>> GATE_CONFIG_MENU =
        MENUS.register("gate_config_menu",
            () -> IForgeMenuType.create((windowId, inv, data) ->
                new GateConfigMenu(windowId, inv, data)));

    // 退票机器主菜单
    public static final RegistryObject<MenuType<ReissueMachineMainMenu>> REISSUE_MACHINE_MAIN_MENU =
        MENUS.register("reissue_machine_main_menu",
            () -> IForgeMenuType.create((windowId, inv, data) ->
                new ReissueMachineMainMenu(windowId, inv, data)));

    // 退票机器管理员菜单
    public static final RegistryObject<MenuType<ReissueMachineAdminMenu>> REISSUE_MACHINE_ADMIN_MENU =
        MENUS.register("reissue_machine_admin_menu",
            () -> IForgeMenuType.create((windowId, inv, data) ->
                new ReissueMachineAdminMenu(windowId, inv, data)));

}
// AdminKeyItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class AdminKeyItem extends Item {
    public AdminKeyItem(Properties properties) {
        super(properties);
    }
}// CopperCoinItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class CopperCoinItem extends Item {
    public CopperCoinItem() {
        super(new Properties().stacksTo(64));
    }
}

package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class EmeraldCoinItem extends Item {
    public EmeraldCoinItem() {
        super(new Properties().stacksTo(64));
    }
}// DiamondCoinItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class DiamondCoinItem extends Item {
    public DiamondCoinItem() {
        super(new Properties().stacksTo(64));
    }
}

// NetheriteCoinItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class ITEM9875is0 extends Item {
    public ITEM9875is0() {
        super(new Properties().stacksTo(64));
    }
}
// GoldCoinItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class GoldCoinItem extends Item {
    public GoldCoinItem() {
        super(new Properties().stacksTo(64));
    }
}


// IronCoinItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class IronCoinItem extends Item {
    public IronCoinItem() {
        super(new Properties().stacksTo(64));
    }
}

// NetheriteCoinItem.java
package com.easttown.ticketsystem.item;

import net.minecraft.world.item.Item;

public class NetheriteCoinItem extends Item {
    public NetheriteCoinItem() {
        super(new Properties().stacksTo(64));
    }
}package com.easttown.ticketsystem.item;

import net.minecraft.ChatFormatting;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.level.Level;
import org.jetbrains.annotations.Nullable;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

public class ReimbursementVoucherItem extends Item {
    public ReimbursementVoucherItem(Properties properties) {
        super(properties);
    }

    @Override
    public void appendHoverText(ItemStack stack, @Nullable Level level, 
                               List<Component> tooltip, TooltipFlag flag) {
        super.appendHoverText(stack, level, tooltip, flag);
        
        CompoundTag tag = stack.getTag();
        if (tag != null && tag.getBoolean("IsReimbursement")) {
            String start = tag.getString("StartStation");
            String dest = tag.getString("Destination");
            long issueTime = tag.getLong("IssueTime");
            int price = tag.getInt("Price");
            
            if (!start.isEmpty() && !dest.isEmpty()) {
                // 格式化时间
                String timeStr = new SimpleDateFormat("yyyy-MM-dd HH:mm").format(new Date(issueTime));
                
                // 添加基本信息
                tooltip.add(Component.translatable("item.voucher.tooltip.route", start, dest)
                    .copy().withStyle(ChatFormatting.GRAY));
                tooltip.add(Component.translatable("item.voucher.tooltip.price", price)
                    .copy().withStyle(ChatFormatting.GOLD));
                tooltip.add(Component.translatable("item.voucher.tooltip.time", timeStr)
                    .copy().withStyle(ChatFormatting.DARK_GRAY));
                
                // 添加报销凭证标识
                tooltip.add(Component.translatable("item.voucher.status")
                    .copy().withStyle(ChatFormatting.DARK_PURPLE, ChatFormatting.BOLD));
            }
        }
    }
}
package com.easttown.ticketsystem.item;

import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.ChatFormatting;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.network.chat.Component;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.InteractionResultHolder;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.TooltipFlag;
import net.minecraft.world.level.Level;
import org.jetbrains.annotations.Nullable;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;

public class TicketItem extends Item {
    // 车票状态常量
    public static final String UNUSED = "UNUSED";
    public static final String IN_USE = "IN_USE";
    public static final String COMPLETED = "COMPLETED";

    public TicketItem(Properties properties) {
        super(properties);
    }

    @Override
    public void appendHoverText(ItemStack stack, @Nullable Level level, 
                               List<Component> tooltip, TooltipFlag flag) {
        super.appendHoverText(stack, level, tooltip, flag);
        
        CompoundTag tag = stack.getTag();
        if (tag != null) {
            String start = tag.getString("StartStation");
            String dest = tag.getString("Destination");
            long issueTime = tag.getLong("IssueTime");
            int price = tag.getInt("Price");
            String status = tag.getString("Status");
            
            if (!start.isEmpty() && !dest.isEmpty()) {
                // 格式化时间
                String timeStr = new SimpleDateFormat("yyyy-MM-dd HH:mm").format(new Date(issueTime));
                
                // 添加基本信息 - 使用语言键
                tooltip.add(LanguageHelper.translate("item.ticket.tooltip.route", start, dest)
                    .copy().withStyle(ChatFormatting.GRAY));
                tooltip.add(LanguageHelper.translate("item.ticket.tooltip.price", price)
                    .copy().withStyle(ChatFormatting.GOLD));
                tooltip.add(LanguageHelper.translate("item.ticket.tooltip.time", timeStr)
                    .copy().withStyle(ChatFormatting.DARK_GRAY));
                
                // 添加状态信息 - 使用语言键
                Component statusText;
                switch (status) {
                    case IN_USE:
                        statusText = LanguageHelper.translate("item.ticket.status.in_use")
                            .copy().withStyle(ChatFormatting.YELLOW);
                        break;
                    case COMPLETED:
                        statusText = LanguageHelper.translate("item.ticket.status.completed")
                            .copy().withStyle(ChatFormatting.GREEN);
                        break;
                    default: // UNUSED
                        statusText = LanguageHelper.translate("item.ticket.status.unused")
                            .copy().withStyle(ChatFormatting.BLUE);
                }
                tooltip.add(statusText);
                
                // 添加使用说明 - 使用语言键
                tooltip.add(LanguageHelper.translate("item.ticket.usage")
                    .copy().withStyle(ChatFormatting.ITALIC, ChatFormatting.DARK_PURPLE));
            }
        }
    }

    @Override
    public InteractionResultHolder<ItemStack> use(Level level, Player player, InteractionHand hand) {
        ItemStack stack = player.getItemInHand(hand);
        CompoundTag tag = stack.getTag();
        
        if (tag != null) {
            String status = tag.getString("Status");
            String dest = tag.getString("Destination");
            
            if (!dest.isEmpty()) {
                if (!level.isClientSide) {
                    // 显示使用信息 - 使用语言键
                    switch (status) {
                        case UNUSED:
                            player.displayClientMessage(
                                LanguageHelper.translate("item.ticket.use.unused", dest), true);
                            break;
                        case IN_USE:
                            player.displayClientMessage(
                                LanguageHelper.translate("item.ticket.use.in_use", dest), true);
                            break;
                        case COMPLETED:
                            player.displayClientMessage(
                                LanguageHelper.translate("item.ticket.use.completed", dest), true);
                            break;
                    }
                }
                return InteractionResultHolder.sidedSuccess(stack, level.isClientSide());
            }
        }
        
        return InteractionResultHolder.pass(stack);
    }
    
    // 辅助方法：检查车票状态
    public static boolean isUnused(ItemStack ticket) {
        CompoundTag tag = ticket.getTag();
        return tag != null && tag.getString("Status").equals(UNUSED);
    }
    
    public static boolean isInUse(ItemStack ticket) {
        CompoundTag tag = ticket.getTag();
        return tag != null && tag.getString("Status").equals(IN_USE);
    }
    
    public static boolean isCompleted(ItemStack ticket) {
        CompoundTag tag = ticket.getTag();
        return tag != null && tag.getString("Status").equals(COMPLETED);
    }
}
package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.config.TicketSystemConfig;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.registries.ForgeRegistries;

import java.util.*;

public class CoinSystem {
    // 硬币价值映射（按从低到高排序）
    private static final Map<String, Integer> coinValues = new LinkedHashMap<>();
    
    static {
        // 初始化硬币价值（以铜币为单位）
        coinValues.put(TicketSystemConfig.COPPER_COIN_ITEM.get(), 1);
        coinValues.put(TicketSystemConfig.IRON_COIN_ITEM.get(), TicketSystemConfig.getCopperToIronRate());
        coinValues.put(TicketSystemConfig.GOLD_COIN_ITEM.get(),
            TicketSystemConfig.getIronToGoldRate() * TicketSystemConfig.getCopperToIronRate());
        coinValues.put(TicketSystemConfig.EMERALD_COIN_ITEM.get(),
            TicketSystemConfig.getGoldToEmeraldRate() * TicketSystemConfig.getIronToGoldRate() * TicketSystemConfig.getCopperToIronRate());
        coinValues.put(TicketSystemConfig.DIAMOND_COIN_ITEM.get(),
            TicketSystemConfig.getEmeraldToDiamondRate() * TicketSystemConfig.getGoldToEmeraldRate() *
            TicketSystemConfig.getIronToGoldRate() * TicketSystemConfig.getCopperToIronRate());
        coinValues.put(TicketSystemConfig.NETHERITE_COIN_ITEM.get(),
            TicketSystemConfig.getDiamondToNetheriteRate() * TicketSystemConfig.getEmeraldToDiamondRate() *
            TicketSystemConfig.getGoldToEmeraldRate() * TicketSystemConfig.getIronToGoldRate() *
            TicketSystemConfig.getCopperToIronRate());
    }
    
    // 计算最优硬币组合
    public static Map<String, Integer> calculateOptimalCoins(int amount) {
        Map<String, Integer> result = new HashMap<>();
        int remaining = amount;
        
        // 从高级到低级计算
        List<String> coins = new ArrayList<>(coinValues.keySet());
        Collections.reverse(coins);
        
        for (String coinId : coins) {
            int value = coinValues.get(coinId);
            if (remaining >= value) {
                int count = remaining / value;
                result.put(coinId, count);
                remaining %= value;
            }
        }
        
        return result;
    }
    
    // 检查玩家是否有足够硬币
    public static boolean hasSufficientCoins(Player player, int price) {
        return getPlayerCopperValue(player) >= price;
    }
    
    // 获取玩家硬币总价值（铜币）
    public static int getPlayerCopperValue(Player player) {
        int total = 0;
        for (Map.Entry<String, Integer> entry : coinValues.entrySet()) {
            String coinId = entry.getKey();
            Item coinItem = ForgeRegistries.ITEMS.getValue(ResourceLocation.parse(coinId));
            if (coinItem != null) {
                int count = countItems(player.getInventory(), coinItem);
                total += count * entry.getValue();
            }
        }
        return total;
    }
    
    // 扣除硬币并返回实际扣除的硬币（考虑找零）
    public static Map<String, Integer> deductWithChange(Player player, int price) {
        int playerValue = getPlayerCopperValue(player);
        if (playerValue < price) return Collections.emptyMap();
        
        // 先移除全部硬币
        for (Map.Entry<String, Integer> entry : coinValues.entrySet()) {
            String coinId = entry.getKey();
            Item coinItem = ForgeRegistries.ITEMS.getValue(ResourceLocation.parse(coinId));
            if (coinItem != null) {
                removeItems(player.getInventory(), coinItem, countItems(player.getInventory(), coinItem));
            }
        }
        
        // 计算并给予找零
        int change = playerValue - price;
        Map<String, Integer> changeCoins = calculateOptimalCoins(change);
        
        for (Map.Entry<String, Integer> entry : changeCoins.entrySet()) {
            String coinId = entry.getKey();
            Item coinItem = ForgeRegistries.ITEMS.getValue(ResourceLocation.parse(coinId));
            if (coinItem != null && entry.getValue() > 0) {
                giveItems(player, coinItem, entry.getValue());
            }
        }
        
        // 返回实际扣除的硬币
        return calculateOptimalCoins(price);
    }
    
    // 格式化差额为可读字符串
    public static String formatDeficit(int deficitCopper) {
        if (deficitCopper <= 0) return "0";
        
        Map<String, Integer> coins = calculateOptimalCoins(deficitCopper);
        StringBuilder sb = new StringBuilder();
        
        List<String> coinTypes = Arrays.asList(
            TicketSystemConfig.NETHERITE_COIN_ITEM.get(),
            TicketSystemConfig.DIAMOND_COIN_ITEM.get(),
            TicketSystemConfig.EMERALD_COIN_ITEM.get(),
            TicketSystemConfig.GOLD_COIN_ITEM.get(),
            TicketSystemConfig.IRON_COIN_ITEM.get(),
            TicketSystemConfig.COPPER_COIN_ITEM.get()
        );
        
        for (String coinType : coinTypes) {
            if (coins.containsKey(coinType) && coins.get(coinType) > 0) {
                if (sb.length() > 0) sb.append(" + ");
                sb.append(coins.get(coinType)).append(" ").append(getCoinName(coinType));
            }
        }
        
        return sb.toString();
    }
    
    // 获取硬币名称
    public static String getCoinName(String coinId) {
        if (coinId.equals(TicketSystemConfig.COPPER_COIN_ITEM.get())) return "铜币";
        if (coinId.equals(TicketSystemConfig.IRON_COIN_ITEM.get())) return "铁币";
        if (coinId.equals(TicketSystemConfig.GOLD_COIN_ITEM.get())) return "金币";
        if (coinId.equals(TicketSystemConfig.EMERALD_COIN_ITEM.get())) return "绿宝石币";
        if (coinId.equals(TicketSystemConfig.DIAMOND_COIN_ITEM.get())) return "钻石币";
        if (coinId.equals(TicketSystemConfig.NETHERITE_COIN_ITEM.get())) return "下界合金币";
        return "硬币";
    }
    
    // 获取硬币价值（以铜币为单位）
    public static int getCoinValue(String coinId) {
        return coinValues.getOrDefault(coinId, 0);
    }

    // 检查是否为硬币
    public static boolean isCoin(String coinId) {
        return coinValues.containsKey(coinId);
    }

    // 获取硬币价值映射
    public static Map<String, Integer> getCoinValues() {
        return new LinkedHashMap<>(coinValues);
    }
    
    // 统计物品数量
    private static int countItems(Inventory inventory, Item item) {
        int count = 0;
        for (int i = 0; i < inventory.getContainerSize(); i++) {
            ItemStack stack = inventory.getItem(i);
            if (stack.getItem() == item) {
                count += stack.getCount();
            }
        }
        return count;
    }
    
    // 移除物品
    private static void removeItems(Inventory inventory, Item item, int amount) {
        int remaining = amount;
        for (int i = 0; i < inventory.getContainerSize(); i++) {
            ItemStack stack = inventory.getItem(i);
            if (stack.getItem() == item) {
                int toRemove = Math.min(remaining, stack.getCount());
                stack.shrink(toRemove);
                remaining -= toRemove;
                if (remaining <= 0) break;
            }
        }
    }
    
    // 给予物品
    public static void giveItems(Player player, Item item, int amount) {
        while (amount > 0) {
            int stackSize = Math.min(item.getMaxStackSize(), amount);
            ItemStack stack = new ItemStack(item, stackSize);
            if (!player.addItem(stack)) {
                player.drop(stack, false);
            }
            amount -= stackSize;
        }
    }
}
package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.config.TicketSystemConfig;
import com.easttown.ticketsystem.data.Fare;
import com.easttown.ticketsystem.data.Route;
import net.minecraft.world.entity.player.Player;

/**
 * 价格计算器 - 重构版本
 * 文档要求：基于票价表查询，删除双票价系统，支持线路网络
 * 优先使用票价表，如果没有定义则回退到距离计算
 */
public class PriceCalculator {
    // 缓存最近的计算结果（简单实现）
    private static final java.util.Map<String, Integer> priceCache = new java.util.HashMap<>();
    private static final int CACHE_SIZE = 100;

    /**
     * 计算票价（主要方法）
     * @param startStation 起点车站名称（兼容旧代码）或车站编码
     * @param destination 终点车站名称（兼容旧代码）或车站编码
     * @return 票价（铜币），如果无法计算返回0
     */
    public static int calculatePrice(String startStation, String destination) {
        if (startStation == null || destination == null ||
                startStation.isEmpty() || destination.isEmpty()) {
            return 0;
        }

        if (startStation.equals(destination)) {
            return 0;
        }

        // 初始化折扣管理器
        DiscountManager.initialize();
        // 检查缓存
        String cacheKey = startStation + "->" + destination;
        Integer cachedPrice = priceCache.get(cacheKey);
        if (cachedPrice != null) {
            return cachedPrice;
        }

        // 转换车站名称到编码（如果需要）
        String startCode = convertToStationCode(startStation);
        String destCode = convertToStationCode(destination);

        if (startCode == null || destCode == null) {
            // 车站不存在，使用旧的距离计算作为回退
            return calculatePriceByDistance(startStation, destination);
        }

        // 使用票价表计算
        int price = calculatePriceByFareTable(startCode, destCode);

        // 更新缓存
        if (priceCache.size() >= CACHE_SIZE) {
            // 简单LRU：清除一半缓存
            java.util.Iterator<String> it = priceCache.keySet().iterator();
            for (int i = 0; i < CACHE_SIZE / 2 && it.hasNext(); i++) {
                it.next();
                it.remove();
            }
        }
        priceCache.put(cacheKey, price);

        // 应用折扣
        int finalPrice = DiscountManager.applyDiscount(price);
        return finalPrice;
    }

    /**
     * 使用票价表计算价格（新系统）
     */
    private static int calculatePriceByFareTable(String startCode, String destCode) {
        // 初始化管理器
        NetworkManager.initialize();

        // 方法1：直接查询票价表
        Fare fare = FareManager.getFare(startCode, destCode);
        if (fare != null && fare.getPrice() > 0) {
            return fare.getPrice();
        }

        // 方法2：使用路线计算器查找最优路径
        Route route = RouteCalculator.findCheapestRoute(startCode, destCode);
        if (route != null && route.getTotalPrice() > 0) {
            return route.getTotalPrice();
        }

        // 方法3：如果票价表不完整，使用距离计算作为回退
        TicketSystemMod.LOGGER.debug("No fare definition found for {} -> {}, falling back to distance calculation",
                startCode, destCode);
        return calculatePriceByDistance(startCode, destCode);
    }

    /**
     * 使用距离计算价格（旧系统，作为回退）
     */
    private static int calculatePriceByDistance(String startStation, String destination) {
        // 尝试使用StationManagerCompat保持兼容性
        try {
            double distance = StationManagerCompat.calculateDistance(startStation, destination);
            if (distance <= 0) {
                return 0;
            }

            // 使用新的配置系统计算价格（支持小数，向上取整）
            int price = TicketSystemConfig.calculateTotalCost((int) distance);

            // 限制价格在合理范围内
            return Math.min(price, Integer.MAX_VALUE);
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Error in distance-based price calculation", e);
            return 100; // 默认票价
        }
    }

    /**
     * 转换车站标识符（名称或编码）
     */
    private static String convertToStationCode(String stationIdentifier) {
        // 如果已经是编码格式（如"01-01"），直接返回
        if (stationIdentifier.matches("\\d{2}-\\d{2}")) {
            // 检查编码是否存在
            if (NetworkManager.hasStation(stationIdentifier)) {
                return stationIdentifier;
            }
        }

        // 尝试通过名称查找编码
        NetworkManager.initialize();
        for (com.easttown.ticketsystem.data.Station station : NetworkManager.getAllStations()) {
            if (station.getName().equals(stationIdentifier) ||
                    station.getCode().equals(stationIdentifier)) {
                return station.getCode();
            }
        }

        // 未找到
        return null;
    }

    /**
     * 扣除支付（兼容原有API）
     */
    public static boolean deductPayment(Player player, int price) {
        if (price <= 0) {
            return true;
        }

        // 使用CoinSystem扣除支付
        return CoinSystem.deductWithChange(player, price) != null;
    }

    /**
     * 计算票价并验证支付能力
     */
    public static PriceResult calculateAndValidatePrice(String startStation, String destination, Player player) {
        int price = calculatePrice(startStation, destination);

        // 检查玩家是否有足够金钱
        boolean canAfford = CoinSystem.hasSufficientCoins(player, price);

        return new PriceResult(price, canAfford);
    }

    /**
     * 获取路径详情（而不仅仅是价格）
     */
    public static Route getRouteDetails(String startStation, String destination) {
        String startCode = convertToStationCode(startStation);
        String destCode = convertToStationCode(destination);

        if (startCode == null || destCode == null) {
            return null;
        }

        NetworkManager.initialize();
        return RouteCalculator.findCheapestRoute(startCode, destCode);
    }

    /**
     * 清除价格缓存
     */
    public static void clearCache() {
        priceCache.clear();
    }

    /**
     * 获取缓存统计
     */
    public static String getCacheStats() {
        return String.format("Price cache: %d entries", priceCache.size());
    }

    /**
     * 验证票价表完整性
     */
    public static java.util.List<String> validateFareTable() {
        NetworkManager.initialize();
        return NetworkManager.validateData();
    }

    /**
     * 生成基础票价表（基于现有车站距离）
     */
    public static boolean generateBasicFares() {
        NetworkManager.initialize();
        java.util.List<String> issues = new java.util.ArrayList<>();

        java.util.Collection<com.easttown.ticketsystem.data.Station> stations = NetworkManager.getAllStations();
        if (stations.size() < 2) {
            TicketSystemMod.LOGGER.warn("Not enough stations to generate fares");
            return false;
        }

        int generatedCount = 0;
        com.easttown.ticketsystem.data.Station[] stationArray = stations.toArray(new com.easttown.ticketsystem.data.Station[0]);

        // 为所有车站对生成基础票价
        for (int i = 0; i < stationArray.length; i++) {
            for (int j = i + 1; j < stationArray.length; j++) {
                com.easttown.ticketsystem.data.Station s1 = stationArray[i];
                com.easttown.ticketsystem.data.Station s2 = stationArray[j];

                // 检查是否已有票价
                if (!NetworkManager.hasFare(s1.getCode(), s2.getCode())) {
                    // 基于距离计算票价
                    int price = calculatePriceByDistance(s1.getName(), s2.getName());

                    // 添加双向票价
                    Fare fare = new Fare(s1.getCode(), s2.getCode(), price);
                    if (NetworkManager.addBidirectionalFare(fare)) {
                        generatedCount++;
                    } else {
                        issues.add(String.format("Failed to generate fare: %s -> %s", s1.getCode(), s2.getCode()));
                    }
                }
            }
        }

        TicketSystemMod.LOGGER.info("Generated {} basic fares, {} issues", generatedCount, issues.size());
        return generatedCount > 0;
    }

    // ==================== 辅助类 ====================

    /**
     * 价格计算结果
     */
    public static class PriceResult {
        private final int price;
        private final boolean canAfford;

        public PriceResult(int price, boolean canAfford) {
            this.price = price;
            this.canAfford = canAfford;
        }

        public int getPrice() {
            return price;
        }

        public boolean canAfford() {
            return canAfford;
        }

        @Override
        public String toString() {
            return String.format("Price: %d铜币, 可支付: %s", price, canAfford ? "是" : "否");
        }
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.data.Station;
import com.easttown.ticketsystem.data.StationData;

import java.util.HashSet;
import java.util.Set;

/**
 * 车站管理器 - 适配器版本
 * 保持原有API兼容性，但底层使用新的NetworkManager系统
 * 文档要求：修复数据存储位置bug，所有数据操作在服务器端执行
 */
public class StationManager {
    // 最大距离限制，防止坐标过大导致计算问题
    private static final double MAX_DISTANCE = 1000000; // 1,000,000格

    // 初始化NetworkManager（懒加载）
    static {
        try {
            NetworkManager.initialize();
            TicketSystemMod.LOGGER.info("StationManager initialized with NetworkManager backend");
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to initialize StationManager with NetworkManager", e);
        }
    }

    /**
     * 添加车站（兼容原有API）
     * 注意：这个方法应该只在服务器端调用
     * 客户端应该通过网络包发送添加请求
     */
    public static void addStation(String stationName, int x, int y, int z) {
        // 生成车站编码（使用名称作为基础，确保唯一性）
        String stationCode = generateStationCode(stationName);

        // 创建新的Station对象
        Station station = new Station(stationCode, stationName);
        station.setCoordinates(x, y, z);

        // 使用NetworkManager添加
        NetworkManager.addStation(station);

        TicketSystemMod.LOGGER.debug("Added station via StationManager adapter: {} -> {}", stationName, stationCode);
    }

    /**
     * 移除车站（兼容原有API）
     */
    public static void removeStation(String stationName) {
        // 查找对应的车站编码
        String stationCode = findStationCodeByName(stationName);
        if (stationCode != null) {
            NetworkManager.removeStation(stationCode);
            TicketSystemMod.LOGGER.debug("Removed station via StationManager adapter: {} -> {}", stationName, stationCode);
        } else {
            TicketSystemMod.LOGGER.warn("Station not found for removal: {}", stationName);
        }
    }

    /**
     * 获取所有车站名称（兼容原有API）
     * 注意：这返回车站名称，而不是编码
     */
    public static Set<String> getStations() {
        Set<String> stationNames = new HashSet<>();
        for (Station station : NetworkManager.getAllStations()) {
            stationNames.add(station.getName());
        }
        return stationNames;
    }

    /**
     * 获取车站数据（兼容原有API）
     * 返回旧的StationData对象以保持兼容性
     */
    public static StationData getStationData(String stationName) {
        String stationCode = findStationCodeByName(stationName);
        if (stationCode == null) {
            return null;
        }

        Station station = NetworkManager.getStation(stationCode);
        if (station == null) {
            return null;
        }

        // 创建旧的StationData对象
        StationData data = new StationData(station.getX(), station.getY(), station.getZ());
        // 注意：旧的price字段未使用，保持默认值
        return data;
    }

    /**
     * 检查车站是否存在（兼容原有API）
     */
    public static boolean containsStation(String stationName) {
        return findStationCodeByName(stationName) != null;
    }

    /**
     * 计算距离（兼容原有API）
     * 使用新系统的车站坐标计算距离
     */
    public static double calculateDistance(String station1Name, String station2Name) {
        if (station1Name.equals(station2Name)) return 0;

        String code1 = findStationCodeByName(station1Name);
        String code2 = findStationCodeByName(station2Name);

        if (code1 == null || code2 == null) {
            return 0;
        }

        Station s1 = NetworkManager.getStation(code1);
        Station s2 = NetworkManager.getStation(code2);

        if (s1 == null || s2 == null) {
            return 0;
        }

        // 使用long类型防止整数溢出
        long dx = (long) s1.getX() - s2.getX();
        long dy = (long) s1.getY() - s2.getY();
        long dz = (long) s1.getZ() - s2.getZ();

        // 计算欧几里得距离
        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

        // 限制最大距离
        return Math.min(distance, MAX_DISTANCE);
    }

    /**
     * 检查坐标是否有效（兼容原有API）
     */
    public static boolean isValidCoordinate(int x, int y, int z) {
        // 使用Station类的验证逻辑
        Station dummy = new Station("dummy", "dummy");
        dummy.setCoordinates(x, y, z);
        return dummy.isValidCoordinate();
    }

    /**
     * 重新加载车站数据（兼容原有API）
     */
    public static void reloadStations() {
        NetworkManager.reloadAll();
    }

    // ==================== 辅助方法 ====================

    /**
     * 根据车站名称查找车站编码
     */
    private static String findStationCodeByName(String stationName) {
        for (Station station : NetworkManager.getAllStations()) {
            if (station.getName().equals(stationName)) {
                return station.getCode();
            }
        }
        return null;
    }

    /**
     * 生成车站编码
     * 简单实现：使用名称作为编码的基础，确保唯一性
     */
    private static String generateStationCode(String stationName) {
        // 简单实现：使用名称作为编码的基础
        // 移除特殊字符，转换为小写，用下划线替换空格
        String baseCode = stationName.replaceAll("[^a-zA-Z0-9\\u4e00-\\u9fff]", "_")
                                    .replaceAll("_+", "_")
                                    .toLowerCase();

        if (baseCode.isEmpty()) {
            baseCode = "station_" + System.currentTimeMillis();
        }

        // 确保唯一性
        int suffix = 1;
        String code = baseCode;
        while (NetworkManager.getStation(code) != null) {
            code = baseCode + "_" + suffix;
            suffix++;
        }

        return code;
    }

    /**
     * 直接添加车站（使用编码）- 新代码使用
     */
    public static boolean addStationWithCode(String stationCode, String stationName, int x, int y, int z) {
        Station station = new Station(stationCode, stationName);
        station.setCoordinates(x, y, z);
        return NetworkManager.addStation(station);
    }

    /**
     * 获取车站编码（新代码使用）
     */
    public static String getStationCode(String stationName) {
        return findStationCodeByName(stationName);
    }

    /**
     * 获取车站名称（新代码使用）
     */
    public static String getStationName(String stationCode) {
        Station station = NetworkManager.getStation(stationCode);
        return station != null ? station.getName() : null;
    }

    /**
     * 添加车站到线路（完整信息）
     * @param chineseName 车站中文名
     * @param englishName 车站英文名（可选，可为null或空）
     * @param lineId 线路ID
     * @param stationNumber 站序号（1-99），如为0则自动分配
     * @param x 坐标X（可选）
     * @param y 坐标Y（可选）
     * @param z 坐标Z（可选）
     * @return 是否成功
     */
    public static boolean addStationToLine(String chineseName, String englishName, String lineId,
                                           int stationNumber, int x, int y, int z) {
        // 检查线路是否存在
        Line line = NetworkManager.getLine(lineId);
        if (line == null) {
            TicketSystemMod.LOGGER.error("线路不存在: {}", lineId);
            return false;
        }

        // 生成车站编码（格式：线路ID-站序号，如 L1-01）
        String stationCode;
        if (stationNumber > 0) {
            // 使用指定的站序号，格式化为两位数
            stationCode = String.format("%s-%02d", lineId, stationNumber);
        } else {
            // 自动分配站序号：找到线路中最大的站序号+1
            int maxNumber = 0;
            for (String existingCode : line.getStationCodes()) {
                if (existingCode.startsWith(lineId + "-")) {
                    try {
                        // 提取站序号部分（如 L1-01 -> 01 -> 1）
                        String numPart = existingCode.substring(lineId.length() + 1);
                        int num = Integer.parseInt(numPart);
                        if (num > maxNumber) {
                            maxNumber = num;
                        }
                    } catch (NumberFormatException e) {
                        // 忽略格式不正确的编码
                    }
                }
            }
            stationNumber = maxNumber + 1;
            stationCode = String.format("%s-%02d", lineId, stationNumber);
        }

        // 检查编码是否已存在
        if (NetworkManager.getStation(stationCode) != null) {
            TicketSystemMod.LOGGER.error("车站编码已存在: {}", stationCode);
            return false;
        }

        // 创建车站
        Station station = new Station(stationCode, chineseName,
                                     englishName != null ? englishName : "",
                                     x, y, z);

        // 添加到车站管理器
        boolean stationAdded = NetworkManager.addStation(station);
        if (!stationAdded) {
            TicketSystemMod.LOGGER.error("添加车站失败: {}", stationCode);
            return false;
        }

        // 将车站编码添加到线路末尾
        line.getStationCodes().add(stationCode);
        // 更新线路
        NetworkManager.removeLine(lineId);
        NetworkManager.addLine(line);

        TicketSystemMod.LOGGER.info("已添加车站: {} (编码: {}) 到线路: {}",
                                   chineseName, stationCode, lineId);
        return true;
    }

}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Station;
import com.easttown.ticketsystem.data.StationData;

import java.util.HashSet;
import java.util.Set;

/**
 * 车站管理器兼容层
 * 提供与原有StationManager相同的API，但底层使用NetworkManager
 * 用于保持现有代码的兼容性，同时迁移到新系统
 */
public class StationManagerCompat {
    /**
     * 添加车站（兼容原有API）
     * 注意：这个方法应该只在服务器端调用
     * 客户端应该通过网络包发送添加请求
     */
    public static void addStation(String stationName, int x, int y, int z) {
        // 创建车站编码（使用名称作为编码，或生成唯一编码）
        String stationCode = generateStationCode(stationName);

        // 创建新的Station对象
        Station station = new Station(stationCode, stationName);
        station.setCoordinates(x, y, z);

        // 使用NetworkManager添加
        NetworkManager.addStation(station);

        TicketSystemMod.LOGGER.debug("Added station via compat layer: {} -> {}", stationName, stationCode);
    }

    /**
     * 移除车站（兼容原有API）
     */
    public static void removeStation(String stationName) {
        // 查找对应的车站编码
        String stationCode = findStationCodeByName(stationName);
        if (stationCode != null) {
            NetworkManager.removeStation(stationCode);
            TicketSystemMod.LOGGER.debug("Removed station via compat layer: {} -> {}", stationName, stationCode);
        } else {
            TicketSystemMod.LOGGER.warn("Station not found for removal: {}", stationName);
        }
    }

    /**
     * 获取所有车站名称（兼容原有API）
     * 注意：这返回车站名称，而不是编码
     */
    public static Set<String> getStations() {
        Set<String> stationNames = new HashSet<>();
        for (Station station : NetworkManager.getAllStations()) {
            stationNames.add(station.getName());
        }
        return stationNames;
    }

    /**
     * 获取车站数据（兼容原有API）
     * 返回旧的StationData对象以保持兼容性
     */
    public static StationData getStationData(String stationName) {
        String stationCode = findStationCodeByName(stationName);
        if (stationCode == null) {
            return null;
        }

        Station station = NetworkManager.getStation(stationCode);
        if (station == null) {
            return null;
        }

        // 创建旧的StationData对象
        StationData data = new StationData(station.getX(), station.getY(), station.getZ());
        // 注意：旧的price字段未使用，保持默认值
        return data;
    }

    /**
     * 检查车站是否存在（兼容原有API）
     */
    public static boolean containsStation(String stationName) {
        return findStationCodeByName(stationName) != null;
    }

    /**
     * 计算距离（兼容原有API）
     * 使用新系统的车站坐标计算距离
     */
    public static double calculateDistance(String station1Name, String station2Name) {
        String code1 = findStationCodeByName(station1Name);
        String code2 = findStationCodeByName(station2Name);

        if (code1 == null || code2 == null) {
            return 0;
        }

        Station s1 = NetworkManager.getStation(code1);
        Station s2 = NetworkManager.getStation(code2);

        if (s1 == null || s2 == null) {
            return 0;
        }

        long dx = (long) s1.getX() - s2.getX();
        long dy = (long) s1.getY() - s2.getY();
        long dz = (long) s1.getZ() - s2.getZ();

        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        double MAX_DISTANCE = 1000000; // 与原StationManager一致
        return Math.min(distance, MAX_DISTANCE);
    }

    /**
     * 检查坐标是否有效（兼容原有API）
     */
    public static boolean isValidCoordinate(int x, int y, int z) {
        return NetworkManager.getStation("dummy") != null ?
               new Station("dummy", "dummy").isValidCoordinate() : // 使用Station的检查逻辑
               (x >= -30000000 && x <= 30000000 &&
                y >= -2048 && y <= 2048 &&
                z >= -30000000 && z <= 30000000);
    }

    /**
     * 重新加载车站数据（兼容原有API）
     */
    public static void reloadStations() {
        NetworkManager.reloadAll();
    }

    // ==================== 辅助方法 ====================

    /**
     * 根据车站名称查找车站编码
     */
    private static String findStationCodeByName(String stationName) {
        for (Station station : NetworkManager.getAllStations()) {
            if (station.getName().equals(stationName)) {
                return station.getCode();
            }
        }
        return null;
    }

    /**
     * 生成车站编码
     * 简单实现：使用名称的hashCode，确保唯一性
     */
    private static String generateStationCode(String stationName) {
        // 简单实现：使用名称作为编码的基础
        // 实际应该使用更健壮的编码生成逻辑
        String baseCode = stationName.replaceAll("[^a-zA-Z0-9]", "_").toLowerCase();

        // 确保唯一性
        int suffix = 1;
        String code = baseCode;
        while (NetworkManager.getStation(code) != null) {
            code = baseCode + "_" + suffix;
            suffix++;
        }

        return code;
    }

    /**
     * 直接添加车站（使用编码）
     * 新代码应该使用这个方法而不是旧的addStation
     */
    public static boolean addStationWithCode(String stationCode, String stationName, int x, int y, int z) {
        Station station = new Station(stationCode, stationName);
        station.setCoordinates(x, y, z);
        return NetworkManager.addStation(station);
    }

    /**
     * 获取车站编码（新代码使用）
     */
    public static String getStationCode(String stationName) {
        return findStationCodeByName(stationName);
    }

    /**
     * 获取车站名称（新代码使用）
     */
    public static String getStationName(String stationCode) {
        Station station = NetworkManager.getStation(stationCode);
        return station != null ? station.getName() : null;
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.data.Line;

import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * 线路管理器
 * 提供线路管理的专门API，底层使用NetworkManager
 */
public class LineManager {
    /**
     * 初始化线路管理器
     */
    public static void initialize() {
        NetworkManager.initialize();
    }

    /**
     * 添加线路
     */
    public static boolean addLine(Line line) {
        return NetworkManager.addLine(line);
    }

    /**
     * 添加线路（简化参数）
     */
    public static boolean addLine(String id, String name, String color) {
        Line line = new Line(id, name, color);
        return addLine(line);
    }

    /**
     * 移除线路
     */
    public static boolean removeLine(String lineId) {
        return NetworkManager.removeLine(lineId);
    }

    /**
     * 获取线路
     */
    public static Line getLine(String lineId) {
        return NetworkManager.getLine(lineId);
    }

    /**
     * 获取所有线路ID
     */
    public static Set<String> getAllLineIds() {
        return NetworkManager.getLineIds();
    }

    /**
     * 获取所有线路
     */
    public static Collection<Line> getAllLines() {
        return NetworkManager.getAllLines();
    }

    /**
     * 检查线路是否存在
     */
    public static boolean hasLine(String lineId) {
        return NetworkManager.hasLine(lineId);
    }

    /**
     * 更新线路
     */
    public static boolean updateLine(Line line) {
        return NetworkManager.updateLine(line);
    }

    /**
     * 将车站添加到线路
     */
    public static boolean addStationToLine(String lineId, String stationCode) {
        Line line = getLine(lineId);
        if (line == null) {
            return false;
        }

        line.addStation(stationCode);
        return updateLine(line);
    }

    /**
     * 将车站插入到线路的指定位置
     */
    public static boolean insertStationToLine(String lineId, int index, String stationCode) {
        Line line = getLine(lineId);
        if (line == null) {
            return false;
        }

        line.insertStation(index, stationCode);
        return updateLine(line);
    }

    /**
     * 从线路移除车站
     */
    public static boolean removeStationFromLine(String lineId, String stationCode) {
        Line line = getLine(lineId);
        if (line == null) {
            return false;
        }

        boolean removed = line.removeStation(stationCode);
        if (removed) {
            return updateLine(line);
        }
        return false;
    }

    /**
     * 获取包含指定车站的所有线路
     */
    public static List<Line> getLinesContainingStation(String stationCode) {
        return NetworkManager.getLinesContainingStation(stationCode);
    }

    /**
     * 检查车站是否属于线路
     */
    public static boolean isStationInLine(String lineId, String stationCode) {
        Line line = getLine(lineId);
        return line != null && line.containsStation(stationCode);
    }

    /**
     * 获取线路中的车站顺序
     */
    public static int getStationOrderInLine(String lineId, String stationCode) {
        Line line = getLine(lineId);
        return line != null ? line.getStationOrder(stationCode) : -1;
    }

    /**
     * 获取线路中的相邻车站
     */
    public static String[] getAdjacentStationsInLine(String lineId, String stationCode) {
        Line line = getLine(lineId);
        return line != null ? line.getAdjacentStations(stationCode) : null;
    }

    /**
     * 验证线路是否有效（至少2个车站）
     */
    public static boolean isValidLine(String lineId) {
        Line line = getLine(lineId);
        return line != null && line.isValid();
    }

    /**
     * 获取线路统计信息
     */
    public static String getLineStats(String lineId) {
        Line line = getLine(lineId);
        if (line == null) {
            return "线路不存在";
        }

        return String.format("线路 %s: %s, %d个车站, 颜色: %s",
                lineId, line.getName(), line.getStationCount(), line.getColor());
    }

    /**
     * 重新加载线路数据
     */
    public static void reloadLines() {
        NetworkManager.reloadAll();
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Station;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.data.Fare;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.*;

/**
 * 网络数据管理器 - 替换现有的StationManager
 * 文档要求：修复数据存储位置bug，所有数据操作在服务器端执行
 * 统一管理车站、线路、票价数据
 */
public class NetworkManager {
    private static final String BASE_PATH = "mods/" + TicketSystemMod.MODID + "/";
    private static final String STATIONS_DIR = BASE_PATH + "stations/";
    private static final String LINES_DIR = BASE_PATH + "lines/";
    private static final String FARES_DIR = BASE_PATH + "fares/";

    private static final String STATIONS_FILE = STATIONS_DIR + "stations.json";
    private static final String LINES_FILE = LINES_DIR + "lines.json";
    private static final String FARES_FILE = FARES_DIR + "fares.json";

    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    // 数据缓存
    private static Map<String, Station> stations = new HashMap<>();
    private static Map<String, Line> lines = new HashMap<>();
    private static Map<String, Fare> fares = new HashMap<>(); // key: "from-to"

    // 初始化标志
    private static boolean initialized = false;

    /**
     * 初始化管理器，加载所有数据
     * 应该在服务器启动时调用
     */
    public static void initialize() {
        if (initialized) {
            return;
        }

        try {
            // 确保目录存在
            ensureDirectories();

            // 加载数据
            loadStations();
            loadLines();
            loadFares();

            TicketSystemMod.LOGGER.info("NetworkManager initialized: {} stations, {} lines, {} fares loaded",
                    stations.size(), lines.size(), fares.size());

            initialized = true;
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to initialize NetworkManager", e);
            // 使用空数据继续运行
            stations = new HashMap<>();
            lines = new HashMap<>();
            fares = new HashMap<>();
        }
    }

    private static void ensureDirectories() {
        new File(STATIONS_DIR).mkdirs();
        new File(LINES_DIR).mkdirs();
        new File(FARES_DIR).mkdirs();
    }

    // ==================== 车站管理 ====================

    private static void loadStations() {
        File file = new File(STATIONS_FILE);
        if (!file.exists()) {
            saveStations(); // 创建空文件
            return;
        }

        try (FileReader reader = new FileReader(file)) {
            Type type = new TypeToken<Map<String, Station>>() {}.getType();
            Map<String, Station> loaded = GSON.fromJson(reader, type);
            if (loaded != null) {
                stations = loaded;
            }
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to load stations", e);
        }
    }

    private static void saveStations() {
        try (FileWriter writer = new FileWriter(STATIONS_FILE)) {
            GSON.toJson(stations, writer);
        } catch (IOException e) {
            TicketSystemMod.LOGGER.error("Failed to save stations", e);
        }
    }

    /**
     * 添加车站
     * @param station 车站对象
     * @return 是否成功添加
     */
    public static boolean addStation(Station station) {
        if (station == null || station.getCode() == null || station.getCode().isEmpty()) {
            return false;
        }

        if (!station.isValidCoordinate()) {
            TicketSystemMod.LOGGER.warn("Invalid coordinate for station: {}", station);
            return false;
        }

        stations.put(station.getCode(), station);
        saveStations();
        return true;
    }

    /**
     * 移除车站
     * @param stationCode 车站编码
     * @return 是否成功移除
     */
    public static boolean removeStation(String stationCode) {
        if (!stations.containsKey(stationCode)) {
            return false;
        }

        // 从所有线路中移除该车站
        for (Line line : lines.values()) {
            line.removeStation(stationCode);
        }
        saveLines();

        // 移除所有涉及该车站的票价
        removeFaresInvolvingStation(stationCode);

        // 移除车站
        stations.remove(stationCode);
        saveStations();

        return true;
    }

    /**
     * 获取车站
     */
    public static Station getStation(String stationCode) {
        return stations.get(stationCode);
    }

    /**
     * 获取所有车站编码
     */
    public static Set<String> getStationCodes() {
        return stations.keySet();
    }

    /**
     * 获取所有车站
     */
    public static Collection<Station> getAllStations() {
        return stations.values();
    }

    /**
     * 检查车站是否存在
     */
    public static boolean hasStation(String stationCode) {
        return stations.containsKey(stationCode);
    }

    /**
     * 更新车站信息
     */
    public static boolean updateStation(Station station) {
        if (!hasStation(station.getCode())) {
            return false;
        }

        stations.put(station.getCode(), station);
        saveStations();
        return true;
    }

    // ==================== 线路管理 ====================

    private static void loadLines() {
        File file = new File(LINES_FILE);
        if (!file.exists()) {
            saveLines(); // 创建空文件
            return;
        }

        try (FileReader reader = new FileReader(file)) {
            Type type = new TypeToken<Map<String, Line>>() {}.getType();
            Map<String, Line> loaded = GSON.fromJson(reader, type);
            if (loaded != null) {
                lines = loaded;
            }
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to load lines", e);
        }
    }

    private static void saveLines() {
        try (FileWriter writer = new FileWriter(LINES_FILE)) {
            GSON.toJson(lines, writer);
        } catch (IOException e) {
            TicketSystemMod.LOGGER.error("Failed to save lines", e);
        }
    }

    /**
     * 添加线路
     */
    public static boolean addLine(Line line) {
        if (line == null || line.getId() == null || line.getId().isEmpty()) {
            return false;
        }

        // 验证线路中的车站是否存在
        for (String stationCode : line.getStationCodes()) {
            if (!hasStation(stationCode)) {
                TicketSystemMod.LOGGER.warn("Station {} not found when adding line {}", stationCode, line.getId());
                // 可以继续，线路可以包含尚未添加的车站
            }
        }

        lines.put(line.getId(), line);
        saveLines();
        return true;
    }

    /**
     * 移除线路
     */
    public static boolean removeLine(String lineId) {
        if (!lines.containsKey(lineId)) {
            return false;
        }

        lines.remove(lineId);
        saveLines();
        return true;
    }

    /**
     * 获取线路
     */
    public static Line getLine(String lineId) {
        return lines.get(lineId);
    }

    /**
     * 获取所有线路ID
     */
    public static Set<String> getLineIds() {
        return lines.keySet();
    }

    /**
     * 获取所有线路
     */
    public static Collection<Line> getAllLines() {
        return lines.values();
    }

    /**
     * 检查线路是否存在
     */
    public static boolean hasLine(String lineId) {
        return lines.containsKey(lineId);
    }

    /**
     * 更新线路
     */
    public static boolean updateLine(Line line) {
        if (!hasLine(line.getId())) {
            return false;
        }

        lines.put(line.getId(), line);
        saveLines();
        return true;
    }

    /**
     * 获取包含指定车站的所有线路
     */
    public static List<Line> getLinesContainingStation(String stationCode) {
        List<Line> result = new ArrayList<>();
        for (Line line : lines.values()) {
            if (line.containsStation(stationCode)) {
                result.add(line);
            }
        }
        return result;
    }

    // ==================== 票价管理 ====================

    private static void loadFares() {
        File file = new File(FARES_FILE);
        if (!file.exists()) {
            saveFares(); // 创建空文件
            return;
        }

        try (FileReader reader = new FileReader(file)) {
            Type type = new TypeToken<Map<String, Fare>>() {}.getType();
            Map<String, Fare> loaded = GSON.fromJson(reader, type);
            if (loaded != null) {
                fares = loaded;
            }
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to load fares", e);
        }
    }

    private static void saveFares() {
        try (FileWriter writer = new FileWriter(FARES_FILE)) {
            GSON.toJson(fares, writer);
        } catch (IOException e) {
            TicketSystemMod.LOGGER.error("Failed to save fares", e);
        }
    }

    private static String getFareKey(String from, String to) {
        return from + "-" + to;
    }

    /**
     * 添加票价
     */
    public static boolean addFare(Fare fare) {
        if (fare == null || !fare.isValid()) {
            return false;
        }

        // 验证车站存在
        if (!hasStation(fare.getFromStation()) || !hasStation(fare.getToStation())) {
            TicketSystemMod.LOGGER.warn("Station not found when adding fare: {}", fare);
            return false;
        }

        fares.put(getFareKey(fare.getFromStation(), fare.getToStation()), fare);
        saveFares();
        return true;
    }

    /**
     * 添加双向票价（同时添加正向和反向）
     */
    public static boolean addBidirectionalFare(Fare fare) {
        if (!addFare(fare)) {
            return false;
        }

        // 添加反向票价
        Fare reverseFare = fare.getSymmetricFare();
        fares.put(getFareKey(reverseFare.getFromStation(), reverseFare.getToStation()), reverseFare);
        saveFares();
        return true;
    }

    /**
     * 移除票价
     */
    public static boolean removeFare(String fromStation, String toStation) {
        String key = getFareKey(fromStation, toStation);
        if (!fares.containsKey(key)) {
            return false;
        }

        fares.remove(key);
        saveFares();
        return true;
    }

    /**
     * 移除涉及指定车站的所有票价
     */
    private static void removeFaresInvolvingStation(String stationCode) {
        List<String> toRemove = new ArrayList<>();
        for (String key : fares.keySet()) {
            Fare fare = fares.get(key);
            if (fare.getFromStation().equals(stationCode) || fare.getToStation().equals(stationCode)) {
                toRemove.add(key);
            }
        }

        for (String key : toRemove) {
            fares.remove(key);
        }

        if (!toRemove.isEmpty()) {
            saveFares();
        }
    }

    /**
     * 获取票价
     */
    public static Fare getFare(String fromStation, String toStation) {
        // 先尝试正向查询
        String key = getFareKey(fromStation, toStation);
        Fare fare = fares.get(key);

        if (fare == null) {
            // 尝试反向查询（双向票价）
            key = getFareKey(toStation, fromStation);
            fare = fares.get(key);
        }

        return fare;
    }

    /**
     * 获取所有票价
     */
    public static Collection<Fare> getAllFares() {
        return fares.values();
    }

    /**
     * 检查票价是否存在
     */
    public static boolean hasFare(String fromStation, String toStation) {
        return getFare(fromStation, toStation) != null;
    }

    /**
     * 更新票价
     */
    public static boolean updateFare(Fare fare) {
        if (fare == null || !fare.isValid()) {
            return false;
        }

        String key = getFareKey(fare.getFromStation(), fare.getToStation());
        if (!fares.containsKey(key)) {
            return false;
        }

        fares.put(key, fare);
        saveFares();
        return true;
    }

    // ==================== 工具方法 ====================

    /**
     * 重新加载所有数据
     */
    public static void reloadAll() {
        initialized = false;
        initialize();
    }

    /**
     * 获取管理器状态
     */
    public static String getStatus() {
        return String.format("Stations: %d, Lines: %d, Fares: %d",
                stations.size(), lines.size(), fares.size());
    }

    /**
     * 验证数据完整性
     */
    public static List<String> validateData() {
        List<String> issues = new ArrayList<>();

        // 检查线路中的车站是否存在
        for (Line line : lines.values()) {
            for (String stationCode : line.getStationCodes()) {
                if (!hasStation(stationCode)) {
                    issues.add(String.format("线路 %s 包含不存在的车站: %s", line.getId(), stationCode));
                }
            }
        }

        // 检查票价对应的车站是否存在
        for (Fare fare : fares.values()) {
            if (!hasStation(fare.getFromStation())) {
                issues.add(String.format("票价起点车站不存在: %s", fare.getFromStation()));
            }
            if (!hasStation(fare.getToStation())) {
                issues.add(String.format("票价终点车站不存在: %s", fare.getToStation()));
            }
        }

        return issues;
    }

    /**
     * 获取车站的线路归属信息
     */
    public static List<String> getStationLineInfo(String stationCode) {
        List<String> lineInfo = new ArrayList<>();
        for (Line line : getLinesContainingStation(stationCode)) {
            int order = line.getStationOrder(stationCode) + 1; // 1-based
            lineInfo.add(String.format("%s (第%d站)", line.getName(), order));
        }
        return lineInfo;
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Fare;
import com.easttown.ticketsystem.data.Station;

import java.util.*;
import java.util.stream.Collectors;

/**
 * 票价计算引擎 - 基于web项目的实时计算算法
 * 实现sumLineFare、sumWithTransfer等核心算法
 * 票价基于相邻车站票价累加，支持零成本换乘
 */
public class FareCalculationEngine {
    // 解析车站编码
    public static class ParsedCode {
        public final String prefix;  // 线路前缀，如"01"
        public final int num;        // 站序号，如1

        public ParsedCode(String prefix, int num) {
            this.prefix = prefix;
            this.num = num;
        }

        @Override
        public String toString() {
            return String.format("%s-%02d", prefix, num);
        }
    }

    /**
     * 解析车站编码，如"01-01" -> prefix="01", num=1
     */
    public static ParsedCode parseCode(String code) {
        if (code == null || code.isEmpty()) {
            return new ParsedCode("", 0);
        }

        String[] parts = code.split("-");
        if (parts.length != 2) {
            TicketSystemMod.LOGGER.warn("Invalid station code format: {}", code);
            return new ParsedCode("", 0);
        }

        try {
            int num = Integer.parseInt(parts[1]);
            return new ParsedCode(parts[0], num);
        } catch (NumberFormatException e) {
            TicketSystemMod.LOGGER.warn("Invalid station number in code: {}", code);
            return new ParsedCode(parts[0], 0);
        }
    }

    /**
     * 获取相邻两站之间的单段票价
     * @param from 起点站编码
     * @param to 终点站编码
     * @param isRegular 是否为普通票价（true=普通，false=特急）
     * @return 单段票价，未找到返回0
     */
    public static int segFare(String from, String to, boolean isRegular) {
        if (from == null || to == null || from.isEmpty() || to.isEmpty()) {
            return 0;
        }

        // 初始化管理器
        NetworkManager.initialize();

        // 优先查找 from→to
        Fare fare = FareManager.getFare(from, to);
        if (fare != null && fare.getPrice() > 0) {
            // 注意：当前Fare类只有单票价，没有区分普通/特急
            // 根据web项目，fares.json有cost_regular和cost_express字段
            // 暂时统一使用price字段
            return fare.getPrice();
        }

        // 查找反向 to→from
        fare = FareManager.getFare(to, from);
        if (fare != null && fare.getPrice() > 0) {
            return fare.getPrice();
        }

        // 未找到票价定义
        TicketSystemMod.LOGGER.debug("No fare defined for {} -> {}", from, to);
        return 0;
    }

    /**
     * 计算同一条线路上两站之间的累计票价
     * @param a 起点站编码
     * @param b 终点站编码
     * @param isRegular 是否为普通票价
     * @return 累计票价，如果不在同一条线路返回-1
     */
    public static int sumLineFare(String a, String b, boolean isRegular) {
        ParsedCode pa = parseCode(a);
        ParsedCode pb = parseCode(b);

        if (pa.prefix.isEmpty() || pb.prefix.isEmpty() || !pa.prefix.equals(pb.prefix)) {
            // 不同线路
            return -1;
        }

        int lo = Math.min(pa.num, pb.num);
        int hi = Math.max(pa.num, pb.num);

        int total = 0;
        boolean hasMissingFare = false;

        for (int i = lo; i < hi; i++) {
            String from = String.format("%s-%02d", pa.prefix, i);
            String to = String.format("%s-%02d", pa.prefix, i + 1);

            int segmentFare = segFare(from, to, isRegular);
            if (segmentFare == 0) {
                hasMissingFare = true;
                TicketSystemMod.LOGGER.warn("Missing fare for segment: {} -> {}", from, to);
            }
            total += segmentFare;
        }

        if (hasMissingFare) {
            TicketSystemMod.LOGGER.warn("Some fares missing for line {}: {} -> {}", pa.prefix, a, b);
        }

        return total;
    }

    /**
     * 自动检测同名车站组（中文名或英文名相同的车站视为同一物理车站）
     * 用于零成本换乘计算
     */
    public static Map<String, List<String>> buildStationGroups() {
        NetworkManager.initialize();
        Collection<Station> stations = NetworkManager.getAllStations();

        Map<String, List<String>> groups = new HashMap<>();

        for (Station station : stations) {
            // 使用中文名作为分组键
            String nameKey = station.getName().trim();
            if (nameKey.isEmpty()) {
                continue;
            }

            groups.computeIfAbsent(nameKey, k -> new ArrayList<>())
                  .add(station.getCode());

            // 如果英文名非空，也加入分组（可选项）
            if (station.getEnName() != null && !station.getEnName().trim().isEmpty()) {
                String enKey = station.getEnName().trim();
                groups.computeIfAbsent(enKey, k -> new ArrayList<>())
                      .add(station.getCode());
            }
        }

        // 只保留有多个车站的组
        return groups.entrySet().stream()
            .filter(entry -> entry.getValue().size() > 1)
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    /**
     * 计算包含换乘的票价（支持零成本换乘）
     * @param from 起点站编码
     * @param to 终点站编码
     * @param isRegular 是否为普通票价
     * @return 包含换乘的最优票价，如果无法到达返回-1
     */
    public static int sumWithTransfer(String from, String to, boolean isRegular) {
        // 1. 首先尝试直接同线票价
        int directFare = sumLineFare(from, to, isRegular);
        if (directFare >= 0) {
            return directFare;
        }

        // 2. 如果不同线，则通过同名车站组进行换乘计算
        Map<String, List<String>> stationGroups = buildStationGroups();
        if (stationGroups.isEmpty()) {
            return -1; // 无换乘组可用
        }

        // 查找起点站和终点站所属的组
        String fromGroup = findStationGroup(from, stationGroups);
        String toGroup = findStationGroup(to, stationGroups);

        if (fromGroup == null || toGroup == null) {
            return -1; // 车站不在任何组中
        }

        // 如果起点和终点在同一组（同名车站），返回0（零成本换乘）
        if (fromGroup.equals(toGroup)) {
            return 0;
        }

        // 3. 查找连接两个组的换乘路径
        // 简化实现：查找同时属于两个组的车站
        // 实际上需要更复杂的图搜索算法，这里简化
        List<String> fromGroupStations = stationGroups.get(fromGroup);
        List<String> toGroupStations = stationGroups.get(toGroup);

        int bestFare = Integer.MAX_VALUE;

        // 遍历所有可能的换乘点
        for (String transferFrom : fromGroupStations) {
            for (String transferTo : toGroupStations) {
                // 计算起点到换乘点的票价（同组内零成本）
                int fare1 = 0; // 同组内零成本

                // 计算换乘点到终点的票价
                int fare2 = sumLineFare(transferFrom, transferTo, isRegular);
                if (fare2 < 0) {
                    continue; // 无法到达
                }

                int totalFare = fare1 + fare2;
                if (totalFare < bestFare) {
                    bestFare = totalFare;
                }
            }
        }

        if (bestFare == Integer.MAX_VALUE) {
            return -1; // 无法找到换乘路径
        }

        return bestFare;
    }

    /**
     * 查找车站所属的组
     */
    private static String findStationGroup(String stationCode, Map<String, List<String>> stationGroups) {
        for (Map.Entry<String, List<String>> entry : stationGroups.entrySet()) {
            if (entry.getValue().contains(stationCode)) {
                return entry.getKey();
            }
        }
        return null;
    }

    /**
     * 计算票价（主入口）
     * @param from 起点站编码
     * @param to 终点站编码
     * @param isRegular 是否为普通票价
     * @return 票价，如果无法计算返回-1
     */
    public static int calculateFare(String from, String to, boolean isRegular) {
        if (from == null || to == null || from.isEmpty() || to.isEmpty()) {
            return -1;
        }

        if (from.equals(to)) {
            return 0;
        }

        // 尝试包含换乘的计算
        int fare = sumWithTransfer(from, to, isRegular);
        if (fare >= 0) {
            return fare;
        }

        // 尝试直接计算（即使不同线，也尝试累加相邻票价）
        // 这需要更复杂的图搜索算法，暂时返回-1
        return -1;
    }

    /**
     * 计算票价（简化接口，默认普通票价）
     */
    public static int calculateFare(String from, String to) {
        return calculateFare(from, to, true);
    }

    /**
     * 生成票价矩阵（用于调试或导出）
     * @param stationCodes 车站编码列表
     * @param isRegular 是否为普通票价
     * @return 票价矩阵，matrix[i][j]表示从i到j的票价
     */
    public static int[][] generateFareMatrix(List<String> stationCodes, boolean isRegular) {
        int n = stationCodes.size();
        int[][] matrix = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    matrix[i][j] = 0;
                } else {
                    int fare = calculateFare(stationCodes.get(i), stationCodes.get(j), isRegular);
                    matrix[i][j] = fare >= 0 ? fare : -1; // -1表示无法到达
                }
            }
        }

        return matrix;
    }

    /**
     * 验证票价数据完整性
     * @return 错误消息列表
     */
    public static List<String> validateFareData() {
        List<String> errors = new ArrayList<>();

        NetworkManager.initialize();
        Collection<Station> stations = NetworkManager.getAllStations();

        // 检查相邻车站票价定义
        for (Station station : stations) {
            String code = station.getCode();
            ParsedCode parsed = parseCode(code);
            if (parsed.prefix.isEmpty()) {
                continue;
            }

            // 检查与下一站的票价定义
            String nextCode = String.format("%s-%02d", parsed.prefix, parsed.num + 1);
            if (NetworkManager.hasStation(nextCode)) {
                int fare = segFare(code, nextCode, true);
                if (fare == 0) {
                    errors.add(String.format("Missing fare for adjacent stations: %s -> %s", code, nextCode));
                }
            }
        }

        // 检查同名车站组
        Map<String, List<String>> groups = buildStationGroups();
        if (groups.isEmpty()) {
            errors.add("No station groups found for transfer calculations");
        }

        return errors;
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.data.Fare;

import java.util.Collection;

/**
 * 票价管理器
 * 提供票价管理的专门API，底层使用NetworkManager
 */
public class FareManager {
    /**
     * 初始化票价管理器
     */
    public static void initialize() {
        NetworkManager.initialize();
    }

    /**
     * 添加票价
     */
    public static boolean addFare(Fare fare) {
        return NetworkManager.addFare(fare);
    }

    /**
     * 添加票价（简化参数）
     */
    public static boolean addFare(String fromStation, String toStation, int price) {
        Fare fare = new Fare(fromStation, toStation, price);
        return addFare(fare);
    }

    /**
     * 添加双向票价
     */
    public static boolean addBidirectionalFare(Fare fare) {
        return NetworkManager.addBidirectionalFare(fare);
    }

    /**
     * 添加双向票价（简化参数）
     */
    public static boolean addBidirectionalFare(String station1, String station2, int price) {
        Fare fare = new Fare(station1, station2, price);
        return addBidirectionalFare(fare);
    }

    /**
     * 移除票价
     */
    public static boolean removeFare(String fromStation, String toStation) {
        return NetworkManager.removeFare(fromStation, toStation);
    }

    /**
     * 移除双向票价
     */
    public static boolean removeBidirectionalFare(String station1, String station2) {
        boolean removed1 = removeFare(station1, station2);
        boolean removed2 = removeFare(station2, station1);
        return removed1 || removed2;
    }

    /**
     * 获取票价
     */
    public static Fare getFare(String fromStation, String toStation) {
        return NetworkManager.getFare(fromStation, toStation);
    }

    /**
     * 获取票价价格，如果不存在返回0
     */
    public static int getFarePrice(String fromStation, String toStation) {
        Fare fare = getFare(fromStation, toStation);
        return fare != null ? fare.getPrice() : 0;
    }

    /**
     * 获取所有票价
     */
    public static Collection<Fare> getAllFares() {
        return NetworkManager.getAllFares();
    }

    /**
     * 检查票价是否存在
     */
    public static boolean hasFare(String fromStation, String toStation) {
        return NetworkManager.hasFare(fromStation, toStation);
    }

    /**
     * 检查双向票价是否存在
     */
    public static boolean hasBidirectionalFare(String station1, String station2) {
        return hasFare(station1, station2) || hasFare(station2, station1);
    }

    /**
     * 更新票价
     */
    public static boolean updateFare(Fare fare) {
        return NetworkManager.updateFare(fare);
    }

    /**
     * 更新票价（简化参数）
     */
    public static boolean updateFare(String fromStation, String toStation, int price) {
        Fare fare = getFare(fromStation, toStation);
        if (fare == null) {
            return false;
        }

        Fare newFare = new Fare(fromStation, toStation, price);
        return updateFare(newFare);
    }

    /**
     * 更新双向票价
     */
    public static boolean updateBidirectionalFare(String station1, String station2, int price) {
        boolean updated1 = updateFare(station1, station2, price);
        boolean updated2 = updateFare(station2, station1, price);
        return updated1 || updated2;
    }

    /**
     * 根据线路自动生成票价
     * 为线路中相邻车站生成基础票价
     */
    public static boolean generateFaresForLine(String lineId, int basePrice) {
        LineManager.initialize(); // 确保线路管理器初始化

        com.easttown.ticketsystem.data.Line line = LineManager.getLine(lineId);
        if (line == null || !line.isValid()) {
            return false;
        }

        boolean success = true;
        java.util.List<String> stations = line.getStationCodes();

        for (int i = 0; i < stations.size() - 1; i++) {
            String from = stations.get(i);
            String to = stations.get(i + 1);

            // 如果票价不存在，则添加
            if (!hasBidirectionalFare(from, to)) {
                boolean added = addBidirectionalFare(from, to, basePrice);
                if (!added) {
                    success = false;
                }
            }
        }

        return success;
    }

    /**
     * 计算路径总票价（简单累加）
     * 假设路径是有效的车站序列
     */
    public static int calculatePathFare(java.util.List<String> stationPath) {
        if (stationPath == null || stationPath.size() < 2) {
            return 0;
        }

        int total = 0;
        for (int i = 0; i < stationPath.size() - 1; i++) {
            String from = stationPath.get(i);
            String to = stationPath.get(i + 1);
            int price = getFarePrice(from, to);
            if (price <= 0) {
                // 没有票价定义，使用默认值或标记为无效
                return -1;
            }
            total += price;
        }

        return total;
    }

    /**
     * 验证票价表完整性
     * 检查所有相邻车站（在线路中）是否有票价定义
     */
    public static java.util.List<String> validateFareCompleteness() {
        java.util.List<String> issues = new java.util.ArrayList<>();

        for (com.easttown.ticketsystem.data.Line line : LineManager.getAllLines()) {
            java.util.List<String> stations = line.getStationCodes();
            for (int i = 0; i < stations.size() - 1; i++) {
                String from = stations.get(i);
                String to = stations.get(i + 1);

                if (!hasBidirectionalFare(from, to)) {
                    issues.add(String.format("线路 %s: 车站 %s -> %s 缺少票价定义",
                            line.getId(), from, to));
                }
            }
        }

        return issues;
    }

    /**
     * 重新加载票价数据
     */
    public static void reloadFares() {
        NetworkManager.reloadAll();
    }

    /**
     * 获取票价统计信息
     */
    public static String getFareStats() {
        Collection<Fare> fares = getAllFares();
        int uniqueSegments = fares.size();
        int totalPriceSum = 0;
        int minPrice = Integer.MAX_VALUE;
        int maxPrice = 0;

        for (Fare fare : fares) {
            int price = fare.getPrice();
            totalPriceSum += price;
            minPrice = Math.min(minPrice, price);
            maxPrice = Math.max(maxPrice, price);
        }

        if (uniqueSegments == 0) {
            return "票价表为空";
        }

        int avgPrice = totalPriceSum / uniqueSegments;
        return String.format("票价表: %d个区间, 价格范围: %d-%d铜币, 平均: %d铜币",
                uniqueSegments, minPrice, maxPrice, avgPrice);
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.data.Fare;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.data.Route;
import com.easttown.ticketsystem.data.Station;

import java.util.*;

/**
 * 路线计算器 - 实现最短路径算法（Dijkstra）
 * 用于计算最低价格的路径，支持换乘
 */
public class RouteCalculator {
    /**
     * 计算从起点到终点的最低价格路径
     * @param startStationCode 起点车站编码
     * @param endStationCode 终点车站编码
     * @return 最优路径，如果没有路径则返回null
     */
    public static Route findCheapestRoute(String startStationCode, String endStationCode) {
        // 输入验证
        if (startStationCode == null || endStationCode == null ||
                startStationCode.isEmpty() || endStationCode.isEmpty()) {
            return null;
        }

        if (startStationCode.equals(endStationCode)) {
            return createDirectRoute(startStationCode, endStationCode);
        }

        // 初始化数据结构
        Map<String, Integer> distances = new HashMap<>();
        Map<String, String> previousStations = new HashMap<>();
        Map<String, String> previousLines = new HashMap<>();
        PriorityQueue<Node> queue = new PriorityQueue<>(Comparator.comparingInt(n -> n.distance));

        // 初始化所有车站
        for (Station station : NetworkManager.getAllStations()) {
            String code = station.getCode();
            distances.put(code, Integer.MAX_VALUE);
        }

        // 设置起点
        distances.put(startStationCode, 0);
        queue.add(new Node(startStationCode, 0, null));

        // Dijkstra算法主循环
        while (!queue.isEmpty()) {
            Node current = queue.poll();

            // 如果找到终点，提前结束
            if (current.stationCode.equals(endStationCode)) {
                break;
            }

            // 如果当前距离大于已知最短距离，跳过
            if (current.distance > distances.get(current.stationCode)) {
                continue;
            }

            // 探索邻居车站
            exploreNeighbors(current, distances, previousStations, previousLines, queue);
        }

        // 构建路径
        return buildRoute(startStationCode, endStationCode, distances, previousStations, previousLines);
    }

    /**
     * 探索当前车站的邻居
     */
    private static void exploreNeighbors(Node current,
                                        Map<String, Integer> distances,
                                        Map<String, String> previousStations,
                                        Map<String, String> previousLines,
                                        PriorityQueue<Node> queue) {
        String currentStation = current.stationCode;

        // 获取所有相邻车站（通过票价定义）
        List<Neighbor> neighbors = getNeighbors(currentStation, current.lineId);

        for (Neighbor neighbor : neighbors) {
            String neighborStation = neighbor.stationCode;
            int farePrice = neighbor.farePrice;
            String lineId = neighbor.lineId;

            // 计算新距离
            int newDistance = distances.get(currentStation) + farePrice;

            // 如果找到更短路径
            if (newDistance < distances.get(neighborStation)) {
                distances.put(neighborStation, newDistance);
                previousStations.put(neighborStation, currentStation);
                if (lineId != null) {
                    previousLines.put(neighborStation, lineId);
                }

                queue.add(new Node(neighborStation, newDistance, lineId));
            }
        }
    }

    /**
     * 获取车站的所有邻居（相邻车站）
     */
    private static List<Neighbor> getNeighbors(String stationCode, String currentLineId) {
        List<Neighbor> neighbors = new ArrayList<>();

        // 方法1：通过票价定义查找邻居
        for (Fare fare : NetworkManager.getAllFares()) {
            if (fare.getFromStation().equals(stationCode)) {
                int price = fare.getPrice();
                if (price <= 0) continue; // 跳过无效票价

                // 尝试确定线路
                String lineId = findLineForSegment(stationCode, fare.getToStation(), currentLineId);
                neighbors.add(new Neighbor(fare.getToStation(), price, lineId));
            }
        }

        // 方法2：通过线路查找相邻车站（如果没有票价定义）
        if (neighbors.isEmpty()) {
            for (Line line : NetworkManager.getAllLines()) {
                if (line.containsStation(stationCode)) {
                    String[] adjacent = line.getAdjacentStations(stationCode);
                    if (adjacent != null) {
                        // 前一个车站
                        if (adjacent[0] != null) {
                            int price = estimateFare(stationCode, adjacent[0]);
                            neighbors.add(new Neighbor(adjacent[0], price, line.getId()));
                        }
                        // 后一个车站
                        if (adjacent[1] != null) {
                            int price = estimateFare(stationCode, adjacent[1]);
                            neighbors.add(new Neighbor(adjacent[1], price, line.getId()));
                        }
                    }
                }
            }
        }

        return neighbors;
    }

    /**
     * 为路径段查找线路
     */
    private static String findLineForSegment(String fromStation, String toStation, String currentLineId) {
        // 如果当前线路包含这两个连续车站，优先使用当前线路
        if (currentLineId != null) {
            Line currentLine = NetworkManager.getLine(currentLineId);
            if (currentLine != null) {
                String[] adjacent = currentLine.getAdjacentStations(fromStation);
                if (adjacent != null && (toStation.equals(adjacent[0]) || toStation.equals(adjacent[1]))) {
                    return currentLineId;
                }
            }
        }

        // 查找包含这两个车站的线路
        for (Line line : NetworkManager.getAllLines()) {
            if (line.containsStation(fromStation) && line.containsStation(toStation)) {
                // 检查是否相邻
                String[] adjacent = line.getAdjacentStations(fromStation);
                if (adjacent != null && (toStation.equals(adjacent[0]) || toStation.equals(adjacent[1]))) {
                    return line.getId();
                }
            }
        }

        return null; // 无法确定线路
    }

    /**
     * 估算票价（当没有明确定义时）
     */
    private static int estimateFare(String fromStation, String toStation) {
        // 先尝试获取已定义的票价
        Fare fare = NetworkManager.getFare(fromStation, toStation);
        if (fare != null) {
            return fare.getPrice();
        }

        // 使用基于距离的估算（回退到旧系统）
        Station s1 = NetworkManager.getStation(fromStation);
        Station s2 = NetworkManager.getStation(toStation);
        if (s1 == null || s2 == null) {
            return 100; // 默认票价
        }

        // 简单距离估算（简化版）
        long dx = (long) s1.getX() - s2.getX();
        long dy = (long) s1.getY() - s2.getY();
        long dz = (long) s1.getZ() - s2.getZ();
        double distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

        // 简单价格公式：每100格1铜币，最低10铜币
        return Math.max(10, (int) (distance / 100));
    }

    /**
     * 构建路径结果
     */
    private static Route buildRoute(String startStation, String endStation,
                                   Map<String, Integer> distances,
                                   Map<String, String> previousStations,
                                   Map<String, String> previousLines) {
        // 检查是否找到路径
        if (distances.get(endStation) == Integer.MAX_VALUE) {
            return null; // 没有路径
        }

        // 回溯构建车站路径
        List<String> stationPath = new ArrayList<>();
        List<String> linePath = new ArrayList<>();
        String current = endStation;

        while (current != null) {
            stationPath.add(0, current);
            String lineId = previousLines.get(current);
            if (lineId != null) {
                linePath.add(0, lineId);
            }
            current = previousStations.get(current);
        }

        // 确保起点正确
        if (!stationPath.get(0).equals(startStation)) {
            return null; // 路径不完整
        }

        // 计算换乘次数
        int transferCount = calculateTransferCount(linePath);

        // 创建路径对象
        Route route = new Route(startStation, endStation);
        route.setStationPath(stationPath);
        route.setLinePath(linePath);
        route.setTotalPrice(distances.get(endStation));
        route.setTransferCount(transferCount);

        return route;
    }

    /**
     * 计算换乘次数
     */
    private static int calculateTransferCount(List<String> linePath) {
        if (linePath.size() <= 1) {
            return 0;
        }

        int transfers = 0;
        String currentLine = linePath.get(0);
        for (int i = 1; i < linePath.size(); i++) {
            if (!linePath.get(i).equals(currentLine)) {
                transfers++;
                currentLine = linePath.get(i);
            }
        }

        return transfers;
    }

    /**
     * 创建直达路径（起点=终点）
     */
    private static Route createDirectRoute(String startStation, String endStation) {
        List<String> stationPath = new ArrayList<>();
        stationPath.add(startStation);
        stationPath.add(endStation);

        Route route = new Route(startStation, endStation);
        route.setStationPath(stationPath);
        route.setTotalPrice(0);
        route.setTransferCount(0);

        return route;
    }

    /**
     * 查找最少换乘路径（备选算法）
     */
    public static Route findMinTransferRoute(String startStationCode, String endStationCode) {
        // 简化实现：先找最低价格路径，然后优化换乘
        Route cheapest = findCheapestRoute(startStationCode, endStationCode);
        if (cheapest == null) {
            return null;
        }

        // 这里可以添加换乘优化逻辑
        return cheapest;
    }

    /**
     * 查找所有可能路径（限制数量）
     */
    public static List<Route> findAllRoutes(String startStationCode, String endStationCode, int maxPaths) {
        // 简化实现：返回最优路径
        List<Route> routes = new ArrayList<>();
        Route route = findCheapestRoute(startStationCode, endStationCode);
        if (route != null) {
            routes.add(route);
        }
        return routes;
    }

    // ==================== 内部辅助类 ====================

    /**
     * Dijkstra算法节点
     */
    private static class Node {
        String stationCode;
        int distance;
        String lineId;

        Node(String stationCode, int distance, String lineId) {
            this.stationCode = stationCode;
            this.distance = distance;
            this.lineId = lineId;
        }
    }

    /**
     * 邻居车站信息
     */
    private static class Neighbor {
        String stationCode;
        int farePrice;
        String lineId;

        Neighbor(String stationCode, int farePrice, String lineId) {
            this.stationCode = stationCode;
            this.farePrice = farePrice;
            this.lineId = lineId;
        }
    }

    /**
     * 获取路径描述
     */
    public static String getRouteDescription(Route route) {
        if (route == null) {
            return "无法找到路径";
        }
        return route.getDescription();
    }

    /**
     * 验证路径有效性
     */
    public static boolean validateRoute(Route route) {
        if (route == null) {
            return false;
        }

        List<String> stationPath = route.getStationPath();
        if (stationPath.size() < 2) {
            return false;
        }

        // 检查每个相邻车站是否有票价定义
        for (int i = 0; i < stationPath.size() - 1; i++) {
            String from = stationPath.get(i);
            String to = stationPath.get(i + 1);
            if (!NetworkManager.hasFare(from, to)) {
                return false;
            }
        }

        return true;
    }
}package com.easttown.ticketsystem.manager;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.config.TicketSystemConfig;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.world.level.storage.LevelResource;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

/**
 * 折扣管理器
 * 管理全局折扣配置，支持多个折扣活动
 * 折扣系数为0-1之间的小数，应用于总票价
 */
public class DiscountManager {
    // 折扣配置
    public static class DiscountConfig {
        private String name;          // 折扣活动名称
        private double discount;      // 折扣系数 (0-1)
        private boolean enabled;      // 是否启用
        private long startTime;       // 开始时间（毫秒时间戳）
        private long endTime;         // 结束时间（毫秒时间戳）

        public DiscountConfig() {
            this.name = "";
            this.discount = 1.0;
            this.enabled = false;
            this.startTime = 0;
            this.endTime = Long.MAX_VALUE;
        }

        public DiscountConfig(String name, double discount) {
            this.name = name;
            this.discount = discount;
            this.enabled = true;
            this.startTime = System.currentTimeMillis();
            this.endTime = Long.MAX_VALUE;
        }

        // Getters and setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }

        public double getDiscount() { return discount; }
        public void setDiscount(double discount) {
            // 确保折扣在合理范围内
            if (discount < 0) discount = 0;
            if (discount > 1) discount = 1;
            this.discount = discount;
        }

        public boolean isEnabled() { return enabled; }
        public void setEnabled(boolean enabled) { this.enabled = enabled; }

        public long getStartTime() { return startTime; }
        public void setStartTime(long startTime) { this.startTime = startTime; }

        public long getEndTime() { return endTime; }
        public void setEndTime(long endTime) { this.endTime = endTime; }

        /**
         * 检查折扣是否有效（启用且在有效期内）
         */
        public boolean isValid() {
            if (!enabled) return false;
            long now = System.currentTimeMillis();
            return now >= startTime && now <= endTime;
        }

        /**
         * 应用折扣到价格
         * @param originalPrice 原始价格
         * @return 折扣后价格（向下取整）
         */
        public int applyDiscount(int originalPrice) {
            if (!isValid() || discount >= 1.0) {
                return originalPrice;
            }
            double discounted = originalPrice * discount;
            return (int) Math.floor(discounted);
        }
    }

    // 配置文件路径
    private static final String CONFIG_FILE_NAME = "discounts.json";
    private static File configFile;

    // Gson实例
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    // 当前折扣配置
    private static DiscountConfig currentDiscount = new DiscountConfig();

    // 折扣历史记录（按名称索引）
    private static Map<String, DiscountConfig> discountHistory = new HashMap<>();

    // 初始化标志
    private static boolean initialized = false;

    /**
     * 初始化折扣管理器
     * @param world 服务器世界（用于确定配置文件路径）
     */
    public static void initialize(ServerLevel world) {
        if (initialized) {
            return;
        }

        try {
            // 确定配置文件路径
            File modDir = new File("mods/" + TicketSystemMod.MODID);
            if (!modDir.exists()) {
                modDir.mkdirs();
            }
            configFile = new File(modDir, CONFIG_FILE_NAME);

            // 加载现有配置
            loadConfig();

            initialized = true;
            TicketSystemMod.LOGGER.info("DiscountManager initialized");
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to initialize DiscountManager", e);
        }
    }

    /**
     * 初始化（简化版本，用于客户端或测试）
     */
    public static void initialize() {
        try {
            File modDir = new File("mods/" + TicketSystemMod.MODID);
            if (!modDir.exists()) {
                modDir.mkdirs();
            }
            configFile = new File(modDir, CONFIG_FILE_NAME);

            // 尝试加载配置，如果文件不存在则使用默认值
            if (configFile.exists()) {
                loadConfig();
            }

            initialized = true;
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to initialize DiscountManager", e);
        }
    }

    /**
     * 加载折扣配置
     */
    private static void loadConfig() {
        try (FileReader reader = new FileReader(configFile)) {
            DiscountConfig loaded = GSON.fromJson(reader, DiscountConfig.class);
            if (loaded != null) {
                currentDiscount = loaded;
                TicketSystemMod.LOGGER.debug("Loaded discount config: {} ({}%)",
                    currentDiscount.getName(), currentDiscount.getDiscount() * 100);
            }
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to load discount config", e);
            // 使用默认配置
            currentDiscount = new DiscountConfig();
        }
    }

    /**
     * 保存折扣配置
     */
    private static void saveConfig() {
        try (FileWriter writer = new FileWriter(configFile)) {
            GSON.toJson(currentDiscount, writer);
        } catch (IOException e) {
            TicketSystemMod.LOGGER.error("Failed to save discount config", e);
        }
    }

    /**
     * 设置当前折扣
     * @param name 折扣名称
     * @param discount 折扣系数 (0-1)
     * @return 是否成功
     */
    public static boolean setDiscount(String name, double discount) {
        // 验证折扣系数
        if (discount < 0 || discount > 1) {
            TicketSystemMod.LOGGER.error("Invalid discount value: {} (must be between 0 and 1)", discount);
            return false;
        }

        // 创建新的折扣配置
        DiscountConfig newDiscount = new DiscountConfig(name, discount);
        newDiscount.setEnabled(true);

        // 保存到历史记录
        discountHistory.put(name, newDiscount);

        // 更新当前折扣
        currentDiscount = newDiscount;

        // 保存到文件
        saveConfig();

        TicketSystemMod.LOGGER.info("Discount set: {} ({}%)", name, discount * 100);
        return true;
    }

    /**
     * 清除当前折扣（恢复原价）
     */
    public static void clearDiscount() {
        currentDiscount = new DiscountConfig();
        saveConfig();
        TicketSystemMod.LOGGER.info("Discount cleared");
    }

    /**
     * 禁用当前折扣（但保留配置）
     */
    public static void disableDiscount() {
        currentDiscount.setEnabled(false);
        saveConfig();
        TicketSystemMod.LOGGER.info("Discount disabled");
    }

    /**
     * 启用当前折扣
     */
    public static void enableDiscount() {
        currentDiscount.setEnabled(true);
        saveConfig();
        TicketSystemMod.LOGGER.info("Discount enabled");
    }

    /**
     * 检查是否有有效折扣
     */
    public static boolean hasActiveDiscount() {
        return currentDiscount.isValid();
    }

    /**
     * 获取当前折扣名称
     */
    public static String getCurrentDiscountName() {
        return currentDiscount.getName();
    }

    /**
     * 获取当前折扣系数
     */
    public static double getCurrentDiscountFactor() {
        return currentDiscount.getDiscount();
    }

    /**
     * 应用折扣到价格
     * @param originalPrice 原始价格
     * @return 折扣后价格
     */
    public static int applyDiscount(int originalPrice) {
        return currentDiscount.applyDiscount(originalPrice);
    }

    /**
     * 获取折扣信息（用于显示）
     */
    public static String getDiscountInfo() {
        if (!hasActiveDiscount()) {
            return "无折扣";
        }
        return String.format("%s (%.0f%%)",
            currentDiscount.getName(),
            currentDiscount.getDiscount() * 100);
    }

    /**
     * 获取折扣节省金额
     * @param originalPrice 原始价格
     * @return 节省的金额
     */
    public static int getDiscountSavings(int originalPrice) {
        if (!hasActiveDiscount()) {
            return 0;
        }
        int discounted = applyDiscount(originalPrice);
        return originalPrice - discounted;
    }

    /**
     * 验证折扣配置
     * @return 验证错误信息列表，空列表表示配置有效
     */
    public static java.util.List<String> validateConfig() {
        java.util.List<String> errors = new java.util.ArrayList<>();

        if (currentDiscount.getDiscount() < 0 || currentDiscount.getDiscount() > 1) {
            errors.add(String.format("折扣系数超出范围: %.2f (必须介于0-1之间)", currentDiscount.getDiscount()));
        }

        if (currentDiscount.isEnabled() && currentDiscount.getEndTime() < System.currentTimeMillis()) {
            errors.add("折扣已过期");
        }

        return errors;
    }

    /**
     * 重新加载配置（热重载）
     */
    public static void reload() {
        if (configFile != null && configFile.exists()) {
            loadConfig();
            TicketSystemMod.LOGGER.info("Discount config reloaded");
        }
    }
}package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.block.GateBlockEntity;
import com.easttown.ticketsystem.screen.GateConfigMenu;
import com.easttown.ticketsystem.screen.GateConfigScreen;
import net.minecraft.client.Minecraft;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.chat.Component;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;
import net.minecraftforge.fml.DistExecutor;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public class OpenGateConfigPacket {
    private final BlockPos pos;

    public OpenGateConfigPacket(BlockPos pos) {
        this.pos = pos;
    }

    public static void encode(OpenGateConfigPacket packet, FriendlyByteBuf buffer) {
        buffer.writeBlockPos(packet.pos);
    }

    public static OpenGateConfigPacket decode(FriendlyByteBuf buffer) {
        return new OpenGateConfigPacket(buffer.readBlockPos());
    }

    public static void handle(OpenGateConfigPacket packet, Supplier<NetworkEvent.Context> context) {
        // 标记为已处理
        context.get().setPacketHandled(true);
        
        // 只在客户端执行
        if (context.get().getDirection().getReceptionSide().isClient()) {
            context.get().enqueueWork(() -> {
                // 使用DistExecutor确保在客户端执行
                DistExecutor.unsafeRunWhenOn(Dist.CLIENT, () -> () -> handleClient(packet));
            });
        }
    }

    @OnlyIn(Dist.CLIENT)
    private static void handleClient(OpenGateConfigPacket packet) {
        Minecraft minecraft = Minecraft.getInstance();
        Player player = minecraft.player;
        if (player != null && minecraft.level != null) {
            // 获取方块实体
            if (minecraft.level.getBlockEntity(packet.pos) instanceof GateBlockEntity blockEntity) {
                // 创建菜单对象
                GateConfigMenu menu = new GateConfigMenu(
                        0,
                        player.getInventory(),
                        blockEntity
                );
                
                // 创建屏幕对象
                GateConfigScreen screen = new GateConfigScreen(
                        menu,
                        player.getInventory(),
                        Component.translatable("ticketsystem.gui.gate_config")
                );
                
                // 打开屏幕
                minecraft.setScreen(screen);
            }
        }
    }
}
package com.easttown.ticketsystem.network;

import net.minecraft.resources.ResourceLocation;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.fml.loading.FMLLoader;
import net.minecraft.server.level.ServerPlayer;
import net.minecraftforge.network.NetworkDirection;
import net.minecraftforge.network.NetworkRegistry;
import net.minecraftforge.network.PacketDistributor;
import net.minecraftforge.network.simple.SimpleChannel;

public class NetworkHandler {
    private static final String PROTOCOL_VERSION = "1";
    public static SimpleChannel INSTANCE;
    
    public static void register() {
        ResourceLocation location = ResourceLocation.fromNamespaceAndPath("ticketsystem", "main");
        
        INSTANCE = NetworkRegistry.newSimpleChannel(
            location,
            () -> PROTOCOL_VERSION,
            PROTOCOL_VERSION::equals,
            PROTOCOL_VERSION::equals
        );
        
        int id = 0;
        INSTANCE.registerMessage(id++, PrintTicketPacket.class, 
            PrintTicketPacket::encode, PrintTicketPacket::decode, PrintTicketPacket::handle);
        INSTANCE.registerMessage(id++, SetStartStationPacket.class, 
            SetStartStationPacket::encode, SetStartStationPacket::decode, SetStartStationPacket::handle);
        // 修复：只在客户端注册OpenGateConfigPacket
        if (FMLLoader.getDist() == Dist.CLIENT) {
            INSTANCE.registerMessage(id++, OpenGateConfigPacket.class, 
                OpenGateConfigPacket::encode, OpenGateConfigPacket::decode, OpenGateConfigPacket::handle);
        }
        INSTANCE.registerMessage(id++, UpdateGateConfigPacket.class, 
            UpdateGateConfigPacket::encode, UpdateGateConfigPacket::decode, UpdateGateConfigPacket::handle);
        INSTANCE.registerMessage(id++, WithdrawCoinsPacket.class,
            WithdrawCoinsPacket::encode, WithdrawCoinsPacket::decode, WithdrawCoinsPacket::handle);
        INSTANCE.registerMessage(id++, WithdrawCoinsByAmountPacket.class,
            WithdrawCoinsByAmountPacket::encode, WithdrawCoinsByAmountPacket::decode, WithdrawCoinsByAmountPacket::handle);
        INSTANCE.registerMessage(id++, LineOperationPacket.class,
            LineOperationPacket::encode, LineOperationPacket::decode, LineOperationPacket::handle);
        INSTANCE.registerMessage(id++, DiscountOperationPacket.class,
            DiscountOperationPacket::encode, DiscountOperationPacket::decode, DiscountOperationPacket::handle);
        INSTANCE.registerMessage(id++, OpenStationManagementPacket.class,
            OpenStationManagementPacket::encode, OpenStationManagementPacket::decode, OpenStationManagementPacket::handle);
    }
    
    public static void sendToPlayer(Object packet, ServerPlayer player) {
        if (INSTANCE != null) {
            INSTANCE.send(PacketDistributor.PLAYER.with(() -> player), packet);
        }
    }
    
    public static void sendToServer(Object packet) {
        if (INSTANCE != null) {
            INSTANCE.sendToServer(packet);
        }
    }
}
package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.block.TicketMachineBlockEntity;
import com.easttown.ticketsystem.manager.CoinSystem;
import com.easttown.ticketsystem.manager.PriceCalculator;
import com.easttown.ticketsystem.manager.StationManager;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.ChatFormatting;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.level.Level;
import net.minecraftforge.network.NetworkEvent;

import java.util.Map;
import java.util.function.Supplier;

public class PrintTicketPacket {
    private final BlockPos pos;
    private final String destination;
    
    public PrintTicketPacket(BlockPos pos, String destination) {
        this.pos = pos;
        this.destination = destination;
    }
    
    public static void encode(PrintTicketPacket packet, FriendlyByteBuf buffer) {
        buffer.writeBlockPos(packet.pos);
        buffer.writeUtf(packet.destination);
    }
    
    public static PrintTicketPacket decode(FriendlyByteBuf buffer) {
        return new PrintTicketPacket(buffer.readBlockPos(), buffer.readUtf());
    }
    
    public static void handle(PrintTicketPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerPlayer player = context.get().getSender();
            if (player != null) {
                Level level = player.level();
                if (level.getBlockEntity(packet.pos) instanceof TicketMachineBlockEntity blockEntity) {
                    String startStation = blockEntity.getStartStation();
                    
                    if (startStation == null || startStation.isEmpty()) {
                        player.displayClientMessage(
                                LanguageHelper.translate("command.start_not_set")
                                        .copy().withStyle(ChatFormatting.RED), 
                                false
                        );
                        return;
                    }
                    
                    if (startStation.equals(packet.destination)) {
                        player.displayClientMessage(
                                LanguageHelper.translate("command.same_station")
                                        .copy().withStyle(ChatFormatting.RED), 
                                false
                        );
                        return;
                    }
                    
                    if (!StationManager.containsStation(packet.destination)) {
                        player.displayClientMessage(
                                LanguageHelper.translate("command.station_not_found", packet.destination)
                                        .copy().withStyle(ChatFormatting.RED), 
                                false
                        );
                        return;
                    }
                    
                    int price = PriceCalculator.calculatePrice(startStation, packet.destination);
                    
                    // 检查输出槽是否空闲
                    if (!blockEntity.canPrintTicket()) {
                        player.displayClientMessage(
                                LanguageHelper.translate("command.output_occupied")
                                        .copy().withStyle(ChatFormatting.RED), 
                                false
                        );
                        return;
                    }
                    
                    if (CoinSystem.hasSufficientCoins(player, price)) {
                        // 支付并获取实际扣除的硬币
                        Map<String, Integer> paidCoins = CoinSystem.deductWithChange(player, price);
                        
                        // 将硬币存入售票机
                        blockEntity.addCoins(paidCoins);
                        
                        blockEntity.printTicket(packet.destination, player);
                        player.displayClientMessage(
                                LanguageHelper.translate("command.ticket_printed", price), 
                                false
                        );
                    } else {
                        int deficit = price - CoinSystem.getPlayerCopperValue(player);
                        String deficitText = CoinSystem.formatDeficit(deficit);
                        
                        player.displayClientMessage(
                                LanguageHelper.translate("command.insufficient_coins", price, deficitText)
                                        .copy().withStyle(ChatFormatting.RED), 
                                false
                        );
                    }
                }
            }
        });
        context.get().setPacketHandled(true);
    }
}
package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.block.GateBlockEntity;
import com.easttown.ticketsystem.block.GateType;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.server.level.ServerLevel;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public class UpdateGateConfigPacket {
    private final BlockPos pos;
    private final String gateId;
    private final String stationId;
    private final String gateType;
    private final boolean allowReentry;
    private final int maxTravelMinutes;
    private final boolean destroyTicket;
    private final boolean enabled;

    public UpdateGateConfigPacket(BlockPos pos, String gateId, String stationId, String gateType, boolean allowReentry, 
                                  int maxTravelMinutes, boolean destroyTicket, boolean enabled) {
        this.pos = pos;
        this.gateId = gateId;
        this.stationId = stationId;
        this.gateType = gateType;
        this.allowReentry = allowReentry;
        this.maxTravelMinutes = maxTravelMinutes;
        this.destroyTicket = destroyTicket;
        this.enabled = enabled;
    }

    public static void encode(UpdateGateConfigPacket packet, FriendlyByteBuf buffer) {
        buffer.writeBlockPos(packet.pos);
        buffer.writeUtf(packet.gateId);
        buffer.writeUtf(packet.stationId);
        buffer.writeUtf(packet.gateType);
        buffer.writeBoolean(packet.allowReentry);
        buffer.writeInt(packet.maxTravelMinutes);
        buffer.writeBoolean(packet.destroyTicket);
        buffer.writeBoolean(packet.enabled);
    }

    public static UpdateGateConfigPacket decode(FriendlyByteBuf buffer) {
        return new UpdateGateConfigPacket(
            buffer.readBlockPos(),
            buffer.readUtf(),
            buffer.readUtf(),
            buffer.readUtf(),
            buffer.readBoolean(),
            buffer.readInt(),
            buffer.readBoolean(),
            buffer.readBoolean()
        );
    }

    public static void handle(UpdateGateConfigPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerLevel level = (ServerLevel) context.get().getSender().level();
            if (level.getBlockEntity(packet.pos) instanceof GateBlockEntity gate) {
                gate.setGateId(packet.gateId);
                gate.setStationId(packet.stationId);
                gate.setGateType(GateType.valueOf(packet.gateType));
                gate.setAllowReentry(packet.allowReentry);
                gate.setMaxTravelMinutes(packet.maxTravelMinutes);
                gate.setDestroyTicket(packet.destroyTicket);
                gate.setEnabled(packet.enabled);
                
                gate.setChanged();
                level.sendBlockUpdated(packet.pos, gate.getBlockState(), gate.getBlockState(), 3);
            }
        });
        context.get().setPacketHandled(true);
    }
}
package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.block.TicketMachineBlockEntity;
import com.easttown.ticketsystem.manager.CoinSystem;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.Item;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.network.NetworkEvent;
import net.minecraftforge.registries.ForgeRegistries;
import com.easttown.ticketsystem.init.ItemInit; // 添加导入
import net.minecraft.network.chat.Component; // 添加导入
import net.minecraft.resources.ResourceLocation;

import java.util.Map;
import java.util.function.Supplier;

public class WithdrawCoinsPacket {
    private final BlockPos pos;
    
    public WithdrawCoinsPacket(BlockPos pos) {
        this.pos = pos;
    }
    
    public static void encode(WithdrawCoinsPacket packet, FriendlyByteBuf buffer) {
        buffer.writeBlockPos(packet.pos);
    }
    
    public static WithdrawCoinsPacket decode(FriendlyByteBuf buffer) {
        return new WithdrawCoinsPacket(buffer.readBlockPos());
    }
    
    public static void handle(WithdrawCoinsPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerPlayer player = context.get().getSender();
            if (player != null) {
                if (player.level().getBlockEntity(packet.pos) instanceof TicketMachineBlockEntity blockEntity) {
                    // 检查是否是管理员
                    if (!player.getMainHandItem().getItem().equals(ItemInit.ADMIN_KEY.get())) {
                        player.displayClientMessage(Component.translatable("ticketsystem.command.not_admin"), true);
                        return;
                    }
                    
                    // 取出所有硬币
                    Map<String, Integer> coins = blockEntity.withdrawCoins();
                    int totalValue = blockEntity.getTotalCopperValue();
                    
                    if (coins.isEmpty()) {
                        player.displayClientMessage(Component.translatable("ticketsystem.command.no_coins"), true);
                        return;
                    }
                    
                    // 给予玩家硬币
                    for (Map.Entry<String, Integer> entry : coins.entrySet()) {
                        Item coinItem = ForgeRegistries.ITEMS.getValue(ResourceLocation.tryParse(entry.getKey()));
                        if (coinItem != null) {
                            int amount = entry.getValue();
                            while (amount > 0) {
                                int stackSize = Math.min(coinItem.getMaxStackSize(), amount);
                                ItemStack stack = new ItemStack(coinItem, stackSize);
                                if (!player.addItem(stack)) {
                                    player.drop(stack, false);
                                }
                                amount -= stackSize;
                            }
                        }
                    }
                    
                    player.displayClientMessage(Component.translatable("ticketsystem.command.coins_withdrawn", totalValue), false);
                }
            }
        });
        context.get().setPacketHandled(true);
    }
}
package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.block.TicketMachineBlockEntity;
import com.easttown.ticketsystem.util.LanguageHelper;

import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.level.Level;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public class SetStartStationPacket {
    private final BlockPos pos;
    private final String station;
    
    public SetStartStationPacket(BlockPos pos, String station) {
        this.pos = pos;
        this.station = station;
    }
    
    public static void encode(SetStartStationPacket packet, FriendlyByteBuf buffer) {
        buffer.writeBlockPos(packet.pos);
        buffer.writeUtf(packet.station);
    }
    
    public static SetStartStationPacket decode(FriendlyByteBuf buffer) {
        return new SetStartStationPacket(buffer.readBlockPos(), buffer.readUtf());
    }
    
    public static void handle(SetStartStationPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerPlayer player = context.get().getSender();
            if (player != null) {
                Level level = player.level();
                if (level.getBlockEntity(packet.pos) instanceof TicketMachineBlockEntity blockEntity) {
                    blockEntity.setStartStation(packet.station);
                    player.displayClientMessage(
                        LanguageHelper.translate("command.start_set", packet.station), false);
                }
            }
        });
        context.get().setPacketHandled(true);
    }
}package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.block.ReissueMachineBlockEntity;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.player.Player;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

public class WithdrawCoinsByAmountPacket {
    private final BlockPos pos;

    public WithdrawCoinsByAmountPacket(BlockPos pos) {
        this.pos = pos;
    }

    public static void encode(WithdrawCoinsByAmountPacket packet, FriendlyByteBuf buffer) {
        buffer.writeBlockPos(packet.pos);
    }

    public static WithdrawCoinsByAmountPacket decode(FriendlyByteBuf buffer) {
        return new WithdrawCoinsByAmountPacket(buffer.readBlockPos());
    }

    public static void handle(WithdrawCoinsByAmountPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerPlayer player = context.get().getSender();
            if (player != null) {
                com.easttown.ticketsystem.util.DebugLogger.info("WithdrawCoinsByAmountPacket: 收到退票请求，玩家: " + player.getName().getString() + ", 位置: " + packet.pos);

                if (player.level().getBlockEntity(packet.pos) instanceof ReissueMachineBlockEntity blockEntity) {
                    // 调用退币方法，根据车票价格退款
                    ReissueMachineBlockEntity.RefundResult result = blockEntity.refundTicketByPrice(player);

                    switch (result) {
                        case NO_TICKET:
                            player.displayClientMessage(LanguageHelper.translate("reissue_machine.no_ticket"), false);
                            break;
                        case INVALID_TICKET:
                            player.displayClientMessage(LanguageHelper.translate("reissue_machine.invalid_ticket"), false);
                            break;
                        case INSUFFICIENT_COINS:
                            player.displayClientMessage(LanguageHelper.translate("reissue_machine.insufficient_coins"), false);
                            break;
                        case TICKET_EXPIRED:
                            player.displayClientMessage(LanguageHelper.translate("reissue_machine.ticket_expired"), false);
                            break;
                        default:
                            // SUCCESS 不需要显示额外消息
                            break;
                    }
                }
            }
        });
        context.get().setPacketHandled(true);
    }
}package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.manager.LineManager;
import com.easttown.ticketsystem.util.LanguageHelper;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraftforge.network.NetworkEvent;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

/**
 * 线路操作网络包
 * 客户端发送线路创建/更新/删除请求到服务器
 */
public class LineOperationPacket {
    // 操作类型
    public enum Operation {
        CREATE,     // 创建线路
        UPDATE,     // 更新线路
        DELETE      // 删除线路
    }

    private final Operation operation;
    private final String lineId;
    private final String lineDataJson; // 序列化的线路数据（CREATE/UPDATE时使用）

    // Gson实例（线程安全）
    private static final Gson GSON = new GsonBuilder().create();
    private static final Type STRING_LIST_TYPE = new TypeToken<List<String>>() {}.getType();

    /**
     * 创建线路操作包
     */
    public LineOperationPacket(Operation operation, String lineId, Line line) {
        this.operation = operation;
        this.lineId = lineId;
        this.lineDataJson = line != null ? serializeLine(line) : "";
    }

    /**
     * 删除线路操作包
     */
    public LineOperationPacket(Operation operation, String lineId) {
        this.operation = operation;
        this.lineId = lineId;
        this.lineDataJson = "";
    }

    /**
     * 序列化线路
     */
    private String serializeLine(Line line) {
        try {
            // 创建简化数据传输对象
            SimpleLineData data = new SimpleLineData();
            data.id = line.getId();
            data.name = line.getName();
            data.enName = line.getEnName();
            data.color = line.getColor();
            data.stationCodes = new ArrayList<>(line.getStationCodes());
            return GSON.toJson(data);
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to serialize line: {}", lineId, e);
            return "{}";
        }
    }

    /**
     * 反序列化线路
     */
    private Line deserializeLine(String json) {
        try {
            SimpleLineData data = GSON.fromJson(json, SimpleLineData.class);
            if (data == null) {
                return null;
            }

            Line line = new Line(data.id, data.name, data.color);
            line.setEnName(data.enName);
            if (data.stationCodes != null) {
                line.setStationCodes(new ArrayList<>(data.stationCodes));
            }
            return line;
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to deserialize line data: {}", json, e);
            return null;
        }
    }

    // 编码
    public static void encode(LineOperationPacket packet, FriendlyByteBuf buffer) {
        buffer.writeEnum(packet.operation);
        buffer.writeUtf(packet.lineId);
        buffer.writeUtf(packet.lineDataJson);
    }

    // 解码
    public static LineOperationPacket decode(FriendlyByteBuf buffer) {
        Operation operation = buffer.readEnum(Operation.class);
        String lineId = buffer.readUtf();
        String lineDataJson = buffer.readUtf();

        if (operation == Operation.DELETE || lineDataJson.isEmpty()) {
            return new LineOperationPacket(operation, lineId);
        } else {
            // 反序列化线路数据
            Line line = null;
            try {
                SimpleLineData data = GSON.fromJson(lineDataJson, SimpleLineData.class);
                if (data != null) {
                    line = new Line(data.id, data.name, data.color);
                    line.setEnName(data.enName);
                    if (data.stationCodes != null) {
                        line.setStationCodes(new ArrayList<>(data.stationCodes));
                    }
                }
            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Failed to decode line data", e);
            }
            return new LineOperationPacket(operation, lineId, line);
        }
    }

    // 处理
    public static void handle(LineOperationPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerPlayer player = context.get().getSender();
            if (player == null) {
                return; // 必须在服务器端处理
            }

            boolean success = false;
            String messageKey = "";
            Object[] messageArgs = new Object[0];

            try {
                switch (packet.operation) {
                    case CREATE:
                        success = handleCreate(packet, player);
                        messageKey = success ? "gui.line_created" : "gui.line_create_failed";
                        messageArgs = new Object[]{packet.lineId};
                        break;

                    case UPDATE:
                        success = handleUpdate(packet, player);
                        messageKey = success ? "gui.line_updated" : "gui.line_update_failed";
                        messageArgs = new Object[]{packet.lineId};
                        break;

                    case DELETE:
                        success = handleDelete(packet, player);
                        messageKey = success ? "gui.line_deleted" : "gui.line_delete_failed";
                        messageArgs = new Object[]{packet.lineId};
                        break;
                }
            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Error handling line operation: {}", packet.operation, e);
                messageKey = "gui.line_operation_error";
                messageArgs = new Object[]{packet.operation.name()};
            }

            // 发送反馈消息给玩家
            if (player != null) {
                Component message = LanguageHelper.translate(messageKey, messageArgs);
                player.displayClientMessage(message, true);
            }
        });
        context.get().setPacketHandled(true);
    }

    /**
     * 处理创建线路
     */
    private static boolean handleCreate(LineOperationPacket packet, ServerPlayer player) {
        Line line = packet.deserializeLine(packet.lineDataJson);
        if (line == null) {
            TicketSystemMod.LOGGER.error("Failed to deserialize line for creation: {}", packet.lineId);
            return false;
        }

        // 验证线路ID
        if (!line.getId().equals(packet.lineId)) {
            TicketSystemMod.LOGGER.error("Line ID mismatch: {} != {}", line.getId(), packet.lineId);
            return false;
        }

        // 验证线路数据
        if (line.getStationCodes().size() < 2) {
            TicketSystemMod.LOGGER.warn("Line {} needs at least 2 stations, got {}",
                    line.getId(), line.getStationCodes().size());
            return false;
        }

        // 执行创建
        return LineManager.addLine(line);
    }

    /**
     * 处理更新线路
     */
    private static boolean handleUpdate(LineOperationPacket packet, ServerPlayer player) {
        Line line = packet.deserializeLine(packet.lineDataJson);
        if (line == null) {
            TicketSystemMod.LOGGER.error("Failed to deserialize line for update: {}", packet.lineId);
            return false;
        }

        // 验证线路ID
        if (!line.getId().equals(packet.lineId)) {
            TicketSystemMod.LOGGER.error("Line ID mismatch in update: {} != {}", line.getId(), packet.lineId);
            return false;
        }

        // 验证线路存在
        Line existingLine = LineManager.getLine(packet.lineId);
        if (existingLine == null) {
            TicketSystemMod.LOGGER.error("Line not found for update: {}", packet.lineId);
            return false;
        }

        // 验证线路数据
        if (line.getStationCodes().size() < 2) {
            TicketSystemMod.LOGGER.warn("Line {} needs at least 2 stations, got {}",
                    line.getId(), line.getStationCodes().size());
            return false;
        }

        // 执行更新
        return LineManager.updateLine(line);
    }

    /**
     * 处理删除线路
     */
    private static boolean handleDelete(LineOperationPacket packet, ServerPlayer player) {
        // 验证线路存在
        Line existingLine = LineManager.getLine(packet.lineId);
        if (existingLine == null) {
            TicketSystemMod.LOGGER.error("Line not found for deletion: {}", packet.lineId);
            return false;
        }

        // 执行删除
        return LineManager.removeLine(packet.lineId);
    }

    // ==================== 数据传输对象 ====================

    /**
     * 简化的线路数据传输对象
     * 避免Gson序列化复杂对象带来的问题
     */
    private static class SimpleLineData {
        public String id;
        public String name;
        public String enName;
        public String color;
        public List<String> stationCodes;
    }
}package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.manager.DiscountManager;
import com.easttown.ticketsystem.util.LanguageHelper;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.chat.Component;
import net.minecraft.server.level.ServerPlayer;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

/**
 * 折扣操作网络包
 * 客户端发送折扣设置/清除请求到服务器
 */
public class DiscountOperationPacket {
    // 操作类型
    public enum Operation {
        SET,        // 设置折扣
        CLEAR,      // 清除折扣
        ENABLE,     // 启用折扣
        DISABLE     // 禁用折扣
    }

    private final Operation operation;
    private final String discountName;
    private final double discountValue;

    // Gson实例（线程安全）
    private static final Gson GSON = new GsonBuilder().create();

    /**
     * 设置折扣操作包
     */
    public DiscountOperationPacket(Operation operation, String discountName, double discountValue) {
        this.operation = operation;
        this.discountName = discountName;
        this.discountValue = discountValue;
    }

    /**
     * 清除/启用/禁用折扣操作包
     */
    public DiscountOperationPacket(Operation operation) {
        this.operation = operation;
        this.discountName = "";
        this.discountValue = 1.0;
    }

    // 编码
    public static void encode(DiscountOperationPacket packet, FriendlyByteBuf buffer) {
        buffer.writeEnum(packet.operation);
        buffer.writeUtf(packet.discountName);
        buffer.writeDouble(packet.discountValue);
    }

    // 解码
    public static DiscountOperationPacket decode(FriendlyByteBuf buffer) {
        Operation operation = buffer.readEnum(Operation.class);
        String discountName = buffer.readUtf();
        double discountValue = buffer.readDouble();

        if (operation == Operation.CLEAR || operation == Operation.ENABLE || operation == Operation.DISABLE) {
            return new DiscountOperationPacket(operation);
        } else {
            return new DiscountOperationPacket(operation, discountName, discountValue);
        }
    }

    // 处理
    public static void handle(DiscountOperationPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            ServerPlayer player = context.get().getSender();
            if (player == null) {
                return; // 必须在服务器端处理
            }

            boolean success = false;
            String messageKey = "";
            Object[] messageArgs = new Object[0];

            try {
                switch (packet.operation) {
                    case SET:
                        success = handleSet(packet, player);
                        messageKey = success ? "gui.discount_set" : "gui.discount_set_failed";
                        messageArgs = new Object[]{packet.discountName, (int)(packet.discountValue * 100)};
                        break;

                    case CLEAR:
                        success = handleClear(player);
                        messageKey = success ? "gui.discount_cleared" : "gui.discount_clear_failed";
                        break;

                    case ENABLE:
                        success = handleEnable(player);
                        messageKey = success ? "gui.discount_enabled" : "gui.discount_enable_failed";
                        break;

                    case DISABLE:
                        success = handleDisable(player);
                        messageKey = success ? "gui.discount_disabled" : "gui.discount_disable_failed";
                        break;
                }
            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Error handling discount operation: {}", packet.operation, e);
                messageKey = "gui.discount_operation_error";
                messageArgs = new Object[]{packet.operation.name()};
            }

            // 发送反馈消息给玩家
            if (player != null) {
                Component message = LanguageHelper.translate(messageKey, messageArgs);
                player.displayClientMessage(message, true);
            }
        });
        context.get().setPacketHandled(true);
    }

    /**
     * 处理设置折扣
     */
    private static boolean handleSet(DiscountOperationPacket packet, ServerPlayer player) {
        // 验证折扣值
        if (packet.discountValue < 0 || packet.discountValue > 1) {
            TicketSystemMod.LOGGER.error("Invalid discount value: {} (must be between 0 and 1)", packet.discountValue);
            return false;
        }

        // 验证折扣名称
        if (packet.discountName == null || packet.discountName.trim().isEmpty()) {
            TicketSystemMod.LOGGER.error("Discount name cannot be empty");
            return false;
        }

        // 执行设置
        return DiscountManager.setDiscount(packet.discountName.trim(), packet.discountValue);
    }

    /**
     * 处理清除折扣
     */
    private static boolean handleClear(ServerPlayer player) {
        DiscountManager.clearDiscount();
        return true;
    }

    /**
     * 处理启用折扣
     */
    private static boolean handleEnable(ServerPlayer player) {
        DiscountManager.enableDiscount();
        return true;
    }

    /**
     * 处理禁用折扣
     */
    private static boolean handleDisable(ServerPlayer player) {
        DiscountManager.disableDiscount();
        return true;
    }

    // Getter方法（用于测试）
    public Operation getOperation() {
        return operation;
    }

    public String getDiscountName() {
        return discountName;
    }

    public double getDiscountValue() {
        return discountValue;
    }
}package com.easttown.ticketsystem.network;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.screen.StationManagementScreen;
import net.minecraft.client.Minecraft;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.fml.DistExecutor;
import net.minecraftforge.network.NetworkEvent;

import java.util.function.Supplier;

/**
 * 打开车站管理GUI网络包
 * 服务器发送此包到客户端，打开车站管理界面
 */
public class OpenStationManagementPacket {
    // 可以包含一些初始数据，如当前车站列表
    // 目前为空，客户端从NetworkManager加载数据

    public OpenStationManagementPacket() {
        // 空构造器
    }

    // 编码
    public static void encode(OpenStationManagementPacket packet, FriendlyByteBuf buffer) {
        // 无数据需要编码
    }

    // 解码
    public static OpenStationManagementPacket decode(FriendlyByteBuf buffer) {
        return new OpenStationManagementPacket();
    }

    // 处理
    public static void handle(OpenStationManagementPacket packet, Supplier<NetworkEvent.Context> context) {
        context.get().enqueueWork(() -> {
            // 确保在客户端执行
            DistExecutor.unsafeRunWhenOn(Dist.CLIENT, () -> () -> {
                try {
                    // 打开车站管理屏幕
                    Minecraft.getInstance().setScreen(new StationManagementScreen());
                    TicketSystemMod.LOGGER.debug("Opened StationManagementScreen via network packet");
                } catch (Exception e) {
                    TicketSystemMod.LOGGER.error("Failed to open StationManagementScreen", e);
                }
            });
        });
        context.get().setPacketHandled(true);
    }
}package com.easttown.ticketsystem.screen.terminal.menu;

import com.easttown.ticketsystem.block.ReissueMachineBlockEntity;
import com.easttown.ticketsystem.init.MenuInit;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.Slot;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.block.entity.BlockEntity;

public class ReissueMachineAdminMenu extends AbstractContainerMenu {

    // 槽位定义 - 硬币存储槽
    public static final int COIN_STORAGE_START = 10; // 与BlockEntity中的硬币存储槽索引对齐
    public static final int COIN_STORAGE_END = 63; // 6x9 = 54个槽位，索引10-63

    // 槽位位置
    public static final int COIN_STORAGE_START_X = 8;
    public static final int COIN_STORAGE_START_Y = 18;
    public static final int COIN_STORAGE_SPACING_X = 18;
    public static final int COIN_STORAGE_SPACING_Y = 18;

    // 玩家物品栏位置 - 重新调整以避免与硬币存储槽重叠
    public static final int PLAYER_INVENTORY_X = 8;
    public static final int PLAYER_INVENTORY_Y = 180; // 从140调整到180
    public static final int HOTBAR_X = 8;
    public static final int HOTBAR_Y = 238; // 从198调整到238

    private final ReissueMachineBlockEntity blockEntity;
    private final BlockPos pos;

    public ReissueMachineAdminMenu(int containerId, Inventory playerInventory, FriendlyByteBuf data) {
        this(containerId, playerInventory, playerInventory.player.level().getBlockEntity(data.readBlockPos()));
    }

    public ReissueMachineAdminMenu(int containerId, Inventory playerInventory, BlockEntity blockEntity) {
        super(MenuInit.REISSUE_MACHINE_ADMIN_MENU.get(), containerId);
        this.blockEntity = (ReissueMachineBlockEntity) blockEntity;
        this.pos = blockEntity.getBlockPos();

        // 添加硬币存储槽位
        addCoinStorageSlots(playerInventory);

        // 添加玩家物品栏
        addPlayerInventory(playerInventory);
        addPlayerHotbar(playerInventory);
    }

    private void addCoinStorageSlots(Inventory playerInventory) {
        // 6x9的硬币存储槽位 - 这些槽位连接到退票机器的硬币存储系统
        for (int row = 0; row < 6; row++) {
            for (int col = 0; col < 9; col++) {
                int slotIndex = COIN_STORAGE_START + col + row * 9;
                int x = COIN_STORAGE_START_X + col * COIN_STORAGE_SPACING_X;
                int y = COIN_STORAGE_START_Y + row * COIN_STORAGE_SPACING_Y;

                this.addSlot(new Slot(blockEntity, slotIndex, x, y) {
                    @Override
                    public boolean mayPlace(ItemStack stack) {
                        // 只允许放入硬币
                        return isCoin(stack);
                    }

                    @Override
                    public boolean mayPickup(Player player) {
                        return true; // 允许玩家取出硬币
                    }

                    private boolean isCoin(ItemStack stack) {
                        String itemId = net.minecraftforge.registries.ForgeRegistries.ITEMS.getKey(stack.getItem()).toString();
                        return itemId.contains("coin");
                    }
                });
            }
        }
    }

    private void addPlayerInventory(Inventory playerInventory) {
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 9; ++j) {
                int slotIndex = j + i * 9 + 9;
                this.addSlot(new Slot(playerInventory, slotIndex,
                PLAYER_INVENTORY_X + j * 18, PLAYER_INVENTORY_Y + i * 18));
            }
        }
    }

    private void addPlayerHotbar(Inventory playerInventory) {
        for (int i = 0; i < 9; ++i) {
            this.addSlot(new Slot(playerInventory, i, HOTBAR_X + i * 18, HOTBAR_Y));
        }
    }

    @Override
    public ItemStack quickMoveStack(Player player, int index) {
        // 禁用快速移动功能
        return ItemStack.EMPTY;
    }

    @Override
    public boolean stillValid(Player player) {
        return this.blockEntity != null &&
                !this.blockEntity.isRemoved() &&
                this.blockEntity.isAdmin(player) && // 检查是否是管理员
                player.distanceToSqr(
                                this.pos.getX() + 0.5,
                                this.pos.getY() + 0.5,
                                this.pos.getZ() + 0.5) <= 64;
    }

    public ReissueMachineBlockEntity getBlockEntity() {
        return blockEntity;
    }

    public BlockPos getPos() {
        return pos;
    }
}package com.easttown.ticketsystem.screen.terminal.menu;

import com.easttown.ticketsystem.block.ReissueMachineBlockEntity;
import com.easttown.ticketsystem.init.MenuInit;
import net.minecraft.core.BlockPos;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.Slot;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.level.block.entity.BlockEntity;

public class ReissueMachineMainMenu extends AbstractContainerMenu {

    // 槽位定义
    public static final int TICKET_INPUT_SLOT = 0;
    public static final int COIN_OUTPUT_SLOT_START = 1;
    public static final int COIN_OUTPUT_SLOT_END = 9;
    // 退票时车票会被销毁，不需要输出槽

    // 槽位位置配置 - 基于贴图自动对准
    // 这些坐标对应贴图中每个槽位的左上角位置

    // 车票输入槽位置 - 基于18像素间距调整
    public static final int TICKET_INPUT_X = 8;
    public static final int TICKET_INPUT_Y = 22; // 第一排槽口位置

    // 硬币输出槽位置 - 水平排列，基于18像素间距
    public static final int COIN_OUTPUT_START_X = 8;
    public static final int COIN_OUTPUT_START_Y = 74; // 第6排槽口位置
    public static final int COIN_OUTPUT_SPACING = 18;

    // 玩家物品栏位置 - 3行9列网格，基于18像素间距
    public static final int PLAYER_INVENTORY_START_X = 8;
    public static final int PLAYER_INVENTORY_START_Y = 115; // 第8排槽口位置
    private static final int PLAYER_INVENTORY_SPACING_X = 18;
    private static final int PLAYER_INVENTORY_SPACING_Y = 18;

    // 快捷栏位置 - 水平排列，基于18像素间距
    public static final int HOTBAR_START_X = 8;
    public static final int HOTBAR_START_Y = 172; // 第12排槽口位置
    private static final int HOTBAR_SPACING = 18;

    private final ReissueMachineBlockEntity blockEntity;
    private final BlockPos pos;

    public ReissueMachineMainMenu(int containerId, Inventory playerInventory, FriendlyByteBuf data) {
        this(containerId, playerInventory, playerInventory.player.level().getBlockEntity(data.readBlockPos()));
    }

    public ReissueMachineMainMenu(int containerId, Inventory playerInventory, BlockEntity blockEntity) {
        super(MenuInit.REISSUE_MACHINE_MAIN_MENU.get(), containerId);
        this.blockEntity = (ReissueMachineBlockEntity) blockEntity;
        this.pos = blockEntity.getBlockPos();

        // 添加退票机器槽位
        addMachineSlots();

        // 添加玩家物品栏
        addPlayerInventory(playerInventory);
        addPlayerHotbar(playerInventory);
    }

    private void addMachineSlots() {
        // 车票输入槽 - 只能放入未使用的车票，但可以取出
        this.addSlot(new Slot(blockEntity, TICKET_INPUT_SLOT, TICKET_INPUT_X, TICKET_INPUT_Y) {
            @Override
            public boolean mayPlace(ItemStack stack) {
                return blockEntity.canPlaceItem(TICKET_INPUT_SLOT, stack);
            }

            @Override
            public boolean mayPickup(Player player) {
                return true; // 车票输入槽允许玩家提取
            }
        });

        // 9个硬币输出槽 - 只能由机器放入
        for (int i = COIN_OUTPUT_SLOT_START; i <= COIN_OUTPUT_SLOT_END; i++) {
            int x = COIN_OUTPUT_START_X + (i - COIN_OUTPUT_SLOT_START) * COIN_OUTPUT_SPACING;
            this.addSlot(new Slot(blockEntity, i, x, COIN_OUTPUT_START_Y) {
                @Override
                public boolean mayPlace(ItemStack stack) {
                    return false; // 硬币输出槽不允许玩家放入
                }
            });
        }
    }

    private void addPlayerInventory(Inventory playerInventory) {
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 9; ++j) {
                int slotIndex = j + i * 9 + 9;
                int x = PLAYER_INVENTORY_START_X + j * PLAYER_INVENTORY_SPACING_X;
                int y = PLAYER_INVENTORY_START_Y + i * PLAYER_INVENTORY_SPACING_Y;
                this.addSlot(new Slot(playerInventory, slotIndex, x, y));
            }
        }
    }

    private void addPlayerHotbar(Inventory playerInventory) {
        for (int i = 0; i < 9; ++i) {
            int x = HOTBAR_START_X + i * HOTBAR_SPACING;
            this.addSlot(new Slot(playerInventory, i, x, HOTBAR_START_Y));
        }
    }

    @Override
    public ItemStack quickMoveStack(Player player, int index) {
        // 禁用快速移动功能
        return ItemStack.EMPTY;
    }

    @Override
    public boolean stillValid(Player player) {
        return this.blockEntity != null &&
                !this.blockEntity.isRemoved() &&
                player.distanceToSqr(
                                this.pos.getX() + 0.5,
                                this.pos.getY() + 0.5,
                                this.pos.getZ() + 0.5) <= 64;
    }

    public ReissueMachineBlockEntity getBlockEntity() {
        return blockEntity;
    }

    public BlockPos getPos() {
        return pos;
    }

}package com.easttown.ticketsystem.screen.terminal;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineAdminMenu;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
import net.minecraft.client.renderer.GameRenderer;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Inventory;

public class ReissueMachineAdminScreen extends AbstractContainerScreen<ReissueMachineAdminMenu> {

    private static final ResourceLocation TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/admin_coin_storage.png");
    private static final ResourceLocation SLOT_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/slot.png");
    private static final ResourceLocation CREATE_INVENTORY_9X6 = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/create_inventory_9x6.png");
    private static final ResourceLocation CREATE_INVENTORY_9X3 = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/create_inventory_9x3.png");
    private static final ResourceLocation CREATE_INVENTORY_9X1 = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/create_inventory_9x1.png");

    // GUI尺寸
    public static final int IMAGE_WIDTH = 176;
    public static final int IMAGE_HEIGHT = 256; // 增加高度以适应新的物品栏位置

    public ReissueMachineAdminScreen(ReissueMachineAdminMenu menu, Inventory inventory, Component title) {
        super(menu, inventory, title);
        this.imageWidth = IMAGE_WIDTH;
        this.imageHeight = IMAGE_HEIGHT;
        this.inventoryLabelY = this.imageHeight - 94;
    }

    @Override
    protected void init() {
        super.init();
        // 管理员界面不需要额外按钮
    }

    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTick) {
        this.renderBackground(guiGraphics);

        RenderSystem.setShader(GameRenderer::getPositionTexShader);
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);
        RenderSystem.setShaderTexture(0, TEXTURE);

        int x = this.leftPos;
        int y = this.topPos;

        // 绘制背景
        guiGraphics.blit(TEXTURE, x, y, 0, 0, this.imageWidth, this.imageHeight);

        // 渲染玩家物品栏和工具提示
        super.render(guiGraphics, mouseX, mouseY, partialTick);
        this.renderTooltip(guiGraphics, mouseX, mouseY);
    }

    @Override
    protected void renderBg(GuiGraphics guiGraphics, float partialTick, int mouseX, int mouseY) {
      /*  RenderSystem.setShader(GameRenderer::getPositionTexShader);
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);
        RenderSystem.setShaderTexture(0, TEXTURE);*/

        int x = this.leftPos;
        int y = this.topPos;

        // 绘制背景
        guiGraphics.blit(TEXTURE, x, y, 0, 0, this.imageWidth, this.imageHeight);

        // 绘制槽位背景
        renderSlotBackgrounds(guiGraphics, x, y);
    }

    // 绘制槽位背景
    private void renderSlotBackgrounds(GuiGraphics guiGraphics, int x, int y) {
        // 对于 18×18 纹理，明确指定纹理尺寸
        final int SLOT_SIZE = 18;
        final int TEXTURE_SIZE = 18; // 因为你的纹理就是 18×18

        // 硬币存储槽 (6x9) - 使用9×6图片一次性渲染
        guiGraphics.blit(CREATE_INVENTORY_9X6,
                x + ReissueMachineAdminMenu.COIN_STORAGE_START_X - 1,
                y + ReissueMachineAdminMenu.COIN_STORAGE_START_Y - 1,
                0, 0,
                9 * SLOT_SIZE, 6 * SLOT_SIZE,
                9 * TEXTURE_SIZE, 6 * TEXTURE_SIZE);

        // 玩家物品栏 (3行9列) - 使用9×3图片一次性渲染
        guiGraphics.blit(CREATE_INVENTORY_9X3,
                x + ReissueMachineAdminMenu.PLAYER_INVENTORY_X - 1,
                y + ReissueMachineAdminMenu.PLAYER_INVENTORY_Y - 1,
                0, 0,
                9 * SLOT_SIZE, 3 * SLOT_SIZE,
                9 * TEXTURE_SIZE, 3 * TEXTURE_SIZE);

        // 快捷栏 (9个) - 使用9×1图片一次性渲染
        guiGraphics.blit(CREATE_INVENTORY_9X1,
                x + ReissueMachineAdminMenu.HOTBAR_X - 1,
                y + ReissueMachineAdminMenu.HOTBAR_Y - 1,
                0, 0,
                9 * SLOT_SIZE, SLOT_SIZE,
                9 * TEXTURE_SIZE, TEXTURE_SIZE);
    }
}package com.easttown.ticketsystem.screen.terminal;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.screen.terminal.menu.ReissueMachineMainMenu;
import com.easttown.ticketsystem.network.NetworkHandler;
import com.easttown.ticketsystem.network.WithdrawCoinsByAmountPacket;
import com.easttown.ticketsystem.util.LanguageHelper;
import com.easttown.ticketsystem.manager.CoinSystem;
import com.mojang.blaze3d.systems.RenderSystem;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
import net.minecraft.client.renderer.GameRenderer;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Inventory;
import java.util.Map;

public class ReissueMachineMainScreen extends AbstractContainerScreen<ReissueMachineMainMenu> {

    private static final ResourceLocation TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/reissue_machine_gui.png");
    private static final ResourceLocation SLOT_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/slot.png");
    private static final ResourceLocation SLOT_9X6_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/create_inventory_9x6.png");
    private static final ResourceLocation SLOT_3X6_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/create_inventory_9x3.png");
    private static final ResourceLocation SLOT_1X6_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID, "textures/gui/gui_slots/create_inventory_9x1.png");

    // GUI尺寸
    public static final int IMAGE_WIDTH = 176;
    public static final int IMAGE_HEIGHT = 196; // 根据新的槽位布局调整高度

    // 退还硬币信息在主GUI中的位置
    public static final int REFUND_INFO_X = 8;
    public static final int REFUND_INFO_Y = 70;
    public static final int REFUND_INFO_LINE_SPACING = 10;

    // 数据刷新相关变量
    private long lastDataRefreshTime = 0;
    private static final long DATA_REFRESH_INTERVAL = 500; // 每500毫秒刷新一次数据
    private String lastTicketStatus = "false"; // 记录上次的车票状态

    // 按钮定义
    private Button withdrawCoinsButton;

    public ReissueMachineMainScreen(ReissueMachineMainMenu menu, Inventory inventory, Component title) {
        super(menu, inventory, title);
        /*  this.imageWidth = IMAGE_WIDTH;
        this.imageHeight = IMAGE_HEIGHT;
        this.inventoryLabelY = this.imageHeight - 94;*/
    }

    @Override
    protected void init() {
        // 确保尺寸设置
        this.imageWidth = IMAGE_WIDTH;
        this.imageHeight = IMAGE_HEIGHT;

        super.init();

        // 双重保险：手动计算位置
        this.leftPos = (this.width - this.imageWidth) / 2;
        this.topPos = (this.height - this.imageHeight) / 2;

        // 设置物品栏标签位置
        this.inventoryLabelX = 8;
        this.inventoryLabelY = 99; // 或者使用你原来的 114

        // 添加调试信息
        com.easttown.ticketsystem.util.DebugLogger.info(
                String.format("GUI初始化: 屏幕=%dx%d, GUI=%dx%d, 位置=(%d,%d)",
                        this.width, this.height, this.imageWidth, this.imageHeight,
                        this.leftPos, this.topPos)
        );

        // 初始化时强制刷新车票数据
        if (this.menu != null && this.menu.getBlockEntity() != null) {
            this.menu.getBlockEntity().setChanged();
            com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineMainScreen: 初始化完成，强制刷新车票数据");
        }

        // 添加退币按钮
        int buttonX = this.leftPos + 30;
        int buttonY = this.topPos + 21;
        int buttonWidth = 75;
        int buttonHeight = 18;

        this.withdrawCoinsButton = Button.builder(
                LanguageHelper.translate("reissue_machine.withdraw_coins"),
                button -> {
                    com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineMainScreen: 退票按钮被点击，位置: " + this.menu.getPos());
                    NetworkHandler.sendToServer(new WithdrawCoinsByAmountPacket(this.menu.getPos()));
                }
        )
                .bounds(buttonX, buttonY, buttonWidth, buttonHeight)
                .build();

        this.addRenderableWidget(this.withdrawCoinsButton);
    }

    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTick) {
        this.renderBackground(guiGraphics);

        /*    RenderSystem.setShader(GameRenderer::getPositionTexShader);
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);
        RenderSystem.setShaderTexture(0, TEXTURE);*/

        int x = (this.width - this.imageWidth) / 2;
        int y = (this.height - this.imageHeight) / 2;

        // 渲染玩家物品栏和工具提示
        super.render(guiGraphics, mouseX, mouseY, partialTick);
        guiGraphics.drawString(this.font, Component.translatable("ticketsystem.gui.reissue_machine_block.tips"), x + 8, y + 45, 0xFFFFFF, true);
        guiGraphics.drawString(this.font, Component.translatable("ticketsystem.gui.reissue_machine_block.tips2"), x + 8, y + 45 + 8 + 3, 0xFFFFFF, true);
        // 在主GUI中直接渲染退还硬币信息
        renderRefundCoinsInfo(guiGraphics, x, y);

        this.renderTooltip(guiGraphics, mouseX, mouseY);
    }

    // 刷新车票详情数据
    private void refreshTicketData() {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastDataRefreshTime > DATA_REFRESH_INTERVAL) {
            lastDataRefreshTime = currentTime;

            // 强制刷新数据
            if (this.menu != null && this.menu.getBlockEntity() != null) {
                // 检查车票状态是否发生变化
                Map<String, String> ticketDetails = this.menu.getBlockEntity().getTicketDetails();
                if (ticketDetails != null) {
                    String currentTicketStatus = ticketDetails.get("hasTicket");
                    if (!currentTicketStatus.equals(lastTicketStatus)) {
                        // 车票状态发生变化，强制重新渲染
                        lastTicketStatus = currentTicketStatus;
                        com.easttown.ticketsystem.util.DebugLogger.info("ReissueMachineMainScreen: 车票状态变化，从 " + lastTicketStatus + " 变为 " + currentTicketStatus);
                    }
                }
            }
        }
    }

    // 渲染退还硬币信息 - 直接在主GUI中显示
    private void renderRefundCoinsInfo(GuiGraphics guiGraphics, int x, int y) {
        // 刷新车票数据
        refreshTicketData();

        // 获取车票详情 - 添加空值检查
        if (this.menu == null || this.menu.getBlockEntity() == null) {
            return;
        }

        Map<String, String> ticketDetails = this.menu.getBlockEntity().getTicketDetails();

        // 检查车票详情状态
        if (ticketDetails == null) {
            return;
        }

        if (ticketDetails.get("hasTicket").equals("false")) {
            // 没有车票时显示提示
            guiGraphics.drawString(this.font, LanguageHelper.translate("reissue_machine.insert_ticket").getString(),
                    x + REFUND_INFO_X, y + REFUND_INFO_Y, 0xFFFFFF, false);
            return;
        }

        // 计算预计退还硬币
        int ticketPrice = Integer.parseInt(ticketDetails.get("price"));
        long issueTime = 0;
        try {
            // 解析时间字符串，这里简化处理，实际需要从NBT获取
            issueTime = System.currentTimeMillis() - 3600000; // 假设1小时前
        } catch (Exception e) {
            issueTime = System.currentTimeMillis();
        }

        int refundAmount = calculateRefundAmount(ticketPrice, issueTime);

        // 直接在GUI中显示退还信息
        int textX = x + REFUND_INFO_X;
        int textY = y + REFUND_INFO_Y;

        // 显示原价
        guiGraphics.drawString(this.font,
                LanguageHelper.translate("reissue_machine.original_price").getString() + ": " + ticketPrice + " " + LanguageHelper.translate("currency.copper").getString(),
                textX, textY, 0xFFFFFF, false);

        // 显示退还金额
        guiGraphics.drawString(this.font,
                LanguageHelper.translate("reissue_machine.refund_amount").getString() + ": " + refundAmount + " " + LanguageHelper.translate("currency.copper").getString(),
                textX, textY + REFUND_INFO_LINE_SPACING, 0xFFFFFF, false);

        // 显示硬币组合
        Map<String, Integer> coinCombination = CoinSystem.calculateOptimalCoins(refundAmount);
        int line = 2;
        for (Map.Entry<String, Integer> entry : coinCombination.entrySet()) {
            if (entry.getValue() > 0) {
                String coinName = CoinSystem.getCoinName(entry.getKey());
                guiGraphics.drawString(this.font,
                        coinName + ": " + entry.getValue() + " 枚",
                        textX, textY + REFUND_INFO_LINE_SPACING * line, 0xFFFFFF, false);
                line++;
            }
        }
    }

    // 计算退款金额（简化版本）
    private int calculateRefundAmount(int originalPrice, long issueTime) {
        long currentTime = System.currentTimeMillis();
        long timeDiff = currentTime - issueTime;

        // 时间阈值（毫秒）
        long halfHour = 30 * 60 * 1000; // 30分钟
        long oneHour = 60 * 60 * 1000; // 1小时
        long twoHours = 2 * 60 * 60 * 1000; // 2小时
        long sixHours = 6 * 60 * 60 * 1000; // 6小时
        long oneDay = 24 * 60 * 60 * 1000; // 24小时

        // 阶梯式退款比例
        if (timeDiff <= halfHour) {
            // 30分钟内：全额退款
            return (int) (originalPrice * 1.0);
        } else if (timeDiff <= oneHour) {
            // 1小时内：75%退款
            return (int) (originalPrice * 0.75);
        } else if (timeDiff <= twoHours) {
            // 2小时内：50%退款
            return (int) (originalPrice * 0.5);
        } else if (timeDiff <= sixHours) {
            // 6小时内：25%退款
            return (int) (originalPrice * 0.25);
        } else if (timeDiff <= oneDay) {
            // 24小时内：10%退款
            return (int) (originalPrice * 0.1);
        } else {
            // 超过24小时：不可退款
            return 0;
        }
    }

    @Override
    protected void renderBg(GuiGraphics guiGraphics, float partialTick, int mouseX, int mouseY) {
        /*  RenderSystem.setShader(GameRenderer::getPositionTexShader);
        RenderSystem.setShaderColor(1.0F, 1.0F, 1.0F, 1.0F);*/
        RenderSystem.setShaderTexture(0, TEXTURE);

        int x = (this.width - this.imageWidth) / 2;
        int y = (this.height - this.imageHeight) / 2;

        // 绘制背景
        guiGraphics.blit(TEXTURE, x, y, 0, 0, this.imageWidth, this.imageHeight, this.imageWidth, this.imageHeight);

        // 绘制槽位背景 - 在背景层渲染，不会干扰原版交互
        renderSlotBackgrounds(guiGraphics, x, y);
    }

    // 绘制槽位背景
    private void renderSlotBackgrounds(GuiGraphics guiGraphics, int x, int y) {
        // 切换到槽位纹理
        //  RenderSystem.setShaderTexture(0, SLOT_TEXTURE);

        // 对于 18×18 纹理，明确指定纹理尺寸
        final int SLOT_SIZE = 18;
        final int TEXTURE_SIZE = 18; // 因为你的纹理就是 18×18

        // 车票输入槽
        guiGraphics.blit(SLOT_TEXTURE,
                x + ReissueMachineMainMenu.TICKET_INPUT_X - 1, y + ReissueMachineMainMenu.TICKET_INPUT_Y - 1,
                0, 0,
                SLOT_SIZE, SLOT_SIZE,
                TEXTURE_SIZE, TEXTURE_SIZE);

        // 硬币输出槽 (9个) - 使用9×6图片一次性渲染
        guiGraphics.blit(SLOT_1X6_TEXTURE,
                x + ReissueMachineMainMenu.COIN_OUTPUT_START_X - 1, y + ReissueMachineMainMenu.COIN_OUTPUT_START_Y - 1,
                0, 0,
                9 * SLOT_SIZE, SLOT_SIZE,
                9 * TEXTURE_SIZE, TEXTURE_SIZE);

        // 玩家物品栏 (3行9列) - 使用3×6图片一次性渲染
        guiGraphics.blit(SLOT_3X6_TEXTURE,
                x + ReissueMachineMainMenu.PLAYER_INVENTORY_START_X - 1, y + ReissueMachineMainMenu.PLAYER_INVENTORY_START_Y - 1,
                0, 0,
                9 * SLOT_SIZE, 3 * SLOT_SIZE,
                9 * TEXTURE_SIZE, 3 * TEXTURE_SIZE);

        // 快捷栏 (9个) - 使用1×6图片一次性渲染
        guiGraphics.blit(SLOT_1X6_TEXTURE,
                x + ReissueMachineMainMenu.HOTBAR_START_X - 1, y + ReissueMachineMainMenu.HOTBAR_START_Y - 1,
                0, 0,
                9 * SLOT_SIZE, SLOT_SIZE,
                9 * TEXTURE_SIZE, TEXTURE_SIZE);
    }

}package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.manager.StationManager;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.EditBox;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.core.BlockPos;
import net.minecraft.network.chat.Component;

public class AddStationScreen extends Screen {
    private EditBox stationNameField;
    private EditBox xField, yField, zField;
    private final BlockPos playerPos;
    
    public AddStationScreen(BlockPos playerPos) {
        super(LanguageHelper.translate("gui.add_station.title"));
        this.playerPos = playerPos;
    }
    
    @Override
    protected void init() {
        super.init();
        int centerX = width / 2 - 100;
        int centerY = height / 2 - 30;
        
        // 车站名称输入框
        stationNameField = new EditBox(font, centerX, centerY - 40, 200, 20, 
            LanguageHelper.translate("gui.station_name"));
        stationNameField.setMaxLength(32);
        addRenderableWidget(stationNameField);
        setInitialFocus(stationNameField);
        
        // 坐标输入框
        xField = new EditBox(font, centerX, centerY, 60, 20, Component.literal("X"));
        xField.setValue(String.valueOf(playerPos.getX()));
        addRenderableWidget(xField);
        
        yField = new EditBox(font, centerX + 80, centerY, 60, 20, Component.literal("Y"));
        yField.setValue(String.valueOf(playerPos.getY()));
        addRenderableWidget(yField);
        
        zField = new EditBox(font, centerX + 160, centerY, 60, 20, Component.literal("Z"));
        zField.setValue(String.valueOf(playerPos.getZ()));
        addRenderableWidget(zField);
        
        // 添加按钮
        addRenderableWidget(Button.builder(LanguageHelper.translate("gui.add"), button -> {
            addStation();
        }).bounds(centerX, centerY + 40, 95, 20).build());
        
        // 取消按钮
        addRenderableWidget(Button.builder(LanguageHelper.translate("gui.cancel"), button -> {
            Minecraft.getInstance().setScreen(null);
        }).bounds(centerX + 105, centerY + 40, 95, 20).build());
    }
    
    // 添加车站逻辑
    private void addStation() {
        String stationName = stationNameField.getValue().trim();
        String xText = xField.getValue().trim().replace("~", "");
        String yText = yField.getValue().trim().replace("~", "");
        String zText = zField.getValue().trim().replace("~", "");
        
        if (stationName.isEmpty() || xText.isEmpty() || yText.isEmpty() || zText.isEmpty()) {
            // 显示缺失信息错误
            Minecraft.getInstance().player.displayClientMessage(
                LanguageHelper.translate("gui.missing_info"), false);
            return;
        }
        
        try {
            int x = Integer.parseInt(xText);
            int y = Integer.parseInt(yText);
            int z = Integer.parseInt(zText);
            
            // 添加车站到管理器
            StationManager.addStation(stationName, x, y, z);
            Minecraft.getInstance().setScreen(null);
            
            // 显示成功消息
            Minecraft.getInstance().player.displayClientMessage(
                LanguageHelper.translate("command.station_added", stationName), false);
        } catch (NumberFormatException e) {
            // 显示无效坐标错误
            Minecraft.getInstance().player.displayClientMessage(
                LanguageHelper.translate("gui.invalid_coord"), false);
        }
    }
    
    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
        // 渲染背景
        renderBackground(guiGraphics);
        // 居中绘制标题
        guiGraphics.drawCenteredString(font, title, width / 2, height / 2 - 80, 0xFFFFFF);
        
        // 绘制标签
        guiGraphics.drawString(font, LanguageHelper.translate("gui.station_name"), 
            width / 2 - 100, height / 2 - 55, 0xFFFFFF, false);
        
        guiGraphics.drawString(font, "X:", width / 2 - 115, height / 2 - 25, 0xFFFFFF);
        guiGraphics.drawString(font, "Y:", width / 2 - 45, height / 2 - 25, 0xFFFFFF);
        guiGraphics.drawString(font, "Z:", width / 2 + 25, height / 2 - 25, 0xFFFFFF);
        
        // 绘制波浪线提示
        guiGraphics.drawString(font, LanguageHelper.translate("gui.tilde_hint"), 
            width / 2 - 100, height / 2 - 5, 0xAAAAAA, false);
        
        // 渲染所有组件
        super.render(guiGraphics, mouseX, mouseY, partialTicks);
    }
}package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.block.GateBlockEntity;
import com.easttown.ticketsystem.init.MenuInit;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import org.jetbrains.annotations.Nullable;

public class GateConfigMenu extends AbstractContainerMenu {

    private final GateBlockEntity blockEntity;

    public GateConfigMenu(int containerId, Inventory inventory, GateBlockEntity blockEntity) {
        super(MenuInit.GATE_CONFIG_MENU.get(), containerId);
        this.blockEntity = blockEntity;
    }

    public GateConfigMenu(int containerId, Inventory inventory, FriendlyByteBuf extraData) {
        this(containerId, inventory, (GateBlockEntity) inventory.player.level().getBlockEntity(extraData.readBlockPos()));
    }

    public GateBlockEntity getBlockEntity() {
        return blockEntity;
    }

    @Override
    public boolean stillValid(Player player) {
        return blockEntity != null && !blockEntity.isRemoved();
    }

    @Nullable
    @Override
    public net.minecraft.world.item.ItemStack quickMoveStack(net.minecraft.world.entity.player.Player player, int index) {
        return null;
    }
}
package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.block.GateBlockEntity;
import com.easttown.ticketsystem.block.GateType;
import com.easttown.ticketsystem.network.NetworkHandler;
import com.easttown.ticketsystem.network.UpdateGateConfigPacket;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.EditBox;
import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.world.entity.player.Inventory;

public class GateConfigScreen extends AbstractContainerScreen<GateConfigMenu> {
    private static final int WIDTH = 256;
    private static final int HEIGHT = 300;
    
    private final GateBlockEntity blockEntity;
    
    // 配置控件
    private EditBox gateIdField;
    private EditBox stationIdField;
    private Button gateTypeButton;
    private Button allowReentryButton;
    private EditBox maxTravelMinutesField;
    private Button destroyTicketButton;
    private Button enabledButton;
    
    public GateConfigScreen(GateConfigMenu menu, Inventory inventory, Component title) {
        super(menu, inventory, title);
        this.blockEntity = menu.getBlockEntity();
        this.imageWidth = WIDTH;
        this.imageHeight = HEIGHT;
    }
    
    @Override
    protected void init() {
        super.init();
        this.leftPos = (this.width - imageWidth) / 2;
        this.topPos = (this.height - imageHeight) / 2;
        
        int labelX = leftPos + 10;
        int fieldX = leftPos + 120;
        int y = topPos + 25;
        int spacing = 25;
        
        // 闸机ID
        gateIdField = new EditBox(this.font, fieldX, y, 120, 20, Component.literal(""));
        gateIdField.setValue(blockEntity.getGateId());
        addRenderableWidget(gateIdField);
        y += spacing;
        
        // 站点ID
        stationIdField = new EditBox(this.font, fieldX, y, 120, 20, Component.literal(""));
        stationIdField.setValue(blockEntity.getStationId());
        addRenderableWidget(stationIdField);
        y += spacing;
        
        // 闸机类型按钮
        gateTypeButton = new Button.Builder(
                getGateTypeText(blockEntity.getGateType()), 
                button -> cycleGateType())
            .bounds(fieldX, y, 120, 20)
            .build();
        addRenderableWidget(gateTypeButton);
        y += spacing;
        
        // 允许重新进站
        allowReentryButton = new Button.Builder(
                getBooleanText(blockEntity.isAllowReentry(), "ticketsystem.gui.allow_reentry"), 
                button -> toggleBooleanSetting(button, "ticketsystem.gui.allow_reentry"))
            .bounds(fieldX, y, 120, 20)
            .build();
        addRenderableWidget(allowReentryButton);
        y += spacing;
        
        // 最大旅行时间
        maxTravelMinutesField = new EditBox(this.font, fieldX, y, 120, 20, Component.literal(""));
        maxTravelMinutesField.setValue(String.valueOf(blockEntity.getMaxTravelMinutes()));
        addRenderableWidget(maxTravelMinutesField);
        y += spacing;
        
        // 销毁车票
        destroyTicketButton = new Button.Builder(
                getBooleanText(blockEntity.isDestroyTicket(), "ticketsystem.gui.destroy_ticket"), 
                button -> toggleBooleanSetting(button, "ticketsystem.gui.destroy_ticket"))
            .bounds(fieldX, y, 120, 20)
            .build();
        addRenderableWidget(destroyTicketButton);
        y += spacing + 15;
        
        // 启用/禁用闸机
        enabledButton = new Button.Builder(
                getBooleanText(blockEntity.isEnabled(), "ticketsystem.gui.enabled"), 
                button -> toggleEnabled())
            .bounds(fieldX, y, 120, 20)
            .build();
        addRenderableWidget(enabledButton);
        
        // 按钮区域
        int buttonY = topPos + HEIGHT - 35;
        // 保存按钮
        addRenderableWidget(new Button.Builder(
                Component.translatable("ticketsystem.gui.save_settings"), 
                button -> saveSettings())
            .bounds(leftPos + 50, buttonY, 70, 20)
            .build());
        
        // 取消按钮
        addRenderableWidget(new Button.Builder(
                Component.translatable("ticketsystem.gui.cancel"), 
                button -> onClose())
            .bounds(leftPos + 130, buttonY, 70, 20)
            .build());
    }
    
    private Component getBooleanText(boolean value, String key) {
        return Component.translatable(key + (value ? ".on" : ".off"));
    }
    
    private Component getGateTypeText(GateType gateType) {
        return Component.translatable("ticketsystem.gate_type." + gateType.name().toLowerCase());
    }
    
    private void cycleGateType() {
        GateType[] values = GateType.values();
        GateType current = blockEntity.getGateType();
        int nextIndex = (current.ordinal() + 1) % values.length;
        GateType nextType = values[nextIndex];
        blockEntity.setGateType(nextType);
        gateTypeButton.setMessage(getGateTypeText(nextType));
    }
    
    private void toggleBooleanSetting(Button button, String key) {
        boolean currentValue;
        switch (key) {
            case "ticketsystem.gui.allow_reentry":
                currentValue = blockEntity.isAllowReentry();
                blockEntity.setAllowReentry(!currentValue);
                button.setMessage(getBooleanText(!currentValue, key));
                break;
            case "ticketsystem.gui.destroy_ticket":
                currentValue = blockEntity.isDestroyTicket();
                blockEntity.setDestroyTicket(!currentValue);
                button.setMessage(getBooleanText(!currentValue, key));
                break;
        }
    }

    private void toggleEnabled() {
        boolean newValue = !blockEntity.isEnabled();
        blockEntity.setEnabled(newValue);
        enabledButton.setMessage(getBooleanText(newValue, "ticketsystem.gui.enabled"));
    }
    
    private void saveSettings() {
        // 获取控件中的值
        String gateId = gateIdField.getValue();
        String stationId = stationIdField.getValue();
        String gateType = blockEntity.getGateType().name();
        boolean allowReentry = blockEntity.isAllowReentry();
        int maxTravelMinutes;
        try {
            maxTravelMinutes = Integer.parseInt(maxTravelMinutesField.getValue());
        } catch (NumberFormatException e) {
            maxTravelMinutes = blockEntity.getMaxTravelMinutes();
        }
        boolean destroyTicket = blockEntity.isDestroyTicket();
        boolean enabled = blockEntity.isEnabled();

        // 发送更新包到服务器
        NetworkHandler.sendToServer(new UpdateGateConfigPacket(
            blockEntity.getBlockPos(),
            gateId,
            stationId,
            gateType,
            allowReentry,
            maxTravelMinutes,
            destroyTicket,
            enabled
        ));

        // 关闭界面
        onClose();
    }
    
    @Override
    protected void renderBg(GuiGraphics guiGraphics, float partialTicks, int mouseX, int mouseY) {
        // 绘制背景
        guiGraphics.fill(leftPos, topPos, leftPos + imageWidth, topPos + imageHeight, 0xFFC6C6C6);
        guiGraphics.renderOutline(leftPos, topPos, imageWidth, imageHeight, 0xFF000000);
        
        // 绘制标题
        guiGraphics.drawCenteredString(font, title, leftPos + imageWidth / 2, topPos + 5, 0x000000);
    }
    
    @Override
    protected void renderLabels(GuiGraphics guiGraphics, int mouseX, int mouseY) {
        int labelX = 10;
        int y = 30;
        int spacing = 25;
        
        // 绘制标签 - 与新的布局对齐
        guiGraphics.drawString(font, LanguageHelper.translate("gui.gate_id"), labelX, y, 0x000000, false);
        y += spacing;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.station_id"), labelX, y, 0x000000, false);
        y += spacing;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.gate_type"), labelX, y, 0x000000, false);
        y += spacing;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.allow_reentry"), labelX, y, 0x000000, false);
        y += spacing;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.max_travel_minutes"), labelX, y, 0x000000, false);
        y += spacing;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.destroy_ticket"), labelX, y, 0x000000, false);
        y += spacing + 15;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.enabled"), labelX, y, 0x000000, false);
    }
    
    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
        this.renderBackground(guiGraphics);
        super.render(guiGraphics, mouseX, mouseY, partialTicks);
        this.renderTooltip(guiGraphics, mouseX, mouseY);
    }
    
    @Override
    public boolean isPauseScreen() {
        return false;
    }
}
package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.manager.LineManager;
import com.easttown.ticketsystem.manager.NetworkManager;
import com.easttown.ticketsystem.util.IdGenerator;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.*;
import net.minecraft.client.gui.components.AbstractSelectionList;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * 线路管理界面
 * 显示所有线路，支持创建、编辑、删除线路
 * 文档要求：简化线路显示，只在网页终端中导出图片
 */
public class LineManagementScreen extends Screen {
    // GUI组件
    private EditBox searchBox;
    private Button createButton;
    private Button editButton;
    private Button deleteButton;
    private Button backButton;
    private LineList lineList;

    // 线路数据
    private List<Line> allLines = new ArrayList<>();
    private Line selectedLine = null;

    // 位置常量
    private static final int SEARCH_X = 20;
    private static final int SEARCH_Y = 20;
    private static final int SEARCH_WIDTH = 150;
    private static final int SEARCH_HEIGHT = 20;

    private static final int LIST_X = 20;
    private static final int LIST_Y = 50;
    private static final int LIST_WIDTH = 200;
    private static final int LIST_HEIGHT = 150;

    private static final int BUTTON_X = 230;
    private static final int BUTTON_Y_START = 50;
    private static final int BUTTON_WIDTH = 100;
    private static final int BUTTON_HEIGHT = 20;
    private static final int BUTTON_SPACING = 25;

    public LineManagementScreen() {
        super(LanguageHelper.translate("gui.line_management.title"));
    }

    @Override
    protected void init() {
        super.init();

        // 确保数据管理器初始化
        NetworkManager.initialize();

        // 搜索框
        searchBox = new EditBox(font,
                LIST_X, SEARCH_Y,
                SEARCH_WIDTH, SEARCH_HEIGHT,
                Component.translatable("gui.search_lines"));
        searchBox.setResponder(text -> refreshLines());
        addRenderableWidget(searchBox);

        // 线路列表
        lineList = new LineList(
                this,
                LIST_X, LIST_Y,
                LIST_WIDTH, LIST_HEIGHT);
        addRenderableWidget(lineList);

        // 创建按钮
        createButton = Button.builder(
                LanguageHelper.translate("gui.create_line"),
                button -> onCreateLine()
        ).bounds(BUTTON_X, BUTTON_Y_START, BUTTON_WIDTH, BUTTON_HEIGHT).build();
        addRenderableWidget(createButton);

        // 编辑按钮
        editButton = Button.builder(
                LanguageHelper.translate("gui.edit_line"),
                button -> onEditLine()
        ).bounds(BUTTON_X, BUTTON_Y_START + BUTTON_SPACING, BUTTON_WIDTH, BUTTON_HEIGHT).build();
        addRenderableWidget(editButton);
        editButton.active = false; // 初始不可用

        // 删除按钮
        deleteButton = Button.builder(
                LanguageHelper.translate("gui.delete_line"),
                button -> onDeleteLine()
        ).bounds(BUTTON_X, BUTTON_Y_START + BUTTON_SPACING * 2, BUTTON_WIDTH, BUTTON_HEIGHT).build();
        addRenderableWidget(deleteButton);
        deleteButton.active = false; // 初始不可用

        // 返回按钮
        backButton = Button.builder(
                LanguageHelper.translate("gui.back"),
                button -> onBack()
        ).bounds(BUTTON_X, BUTTON_Y_START + BUTTON_SPACING * 4, BUTTON_WIDTH, BUTTON_HEIGHT).build();
        addRenderableWidget(backButton);

        // 刷新线路数据
        refreshLines();
    }

    /**
     * 刷新线路列表
     */
    private void refreshLines() {
        String filter = searchBox.getValue().toLowerCase();
        allLines.clear();

        // 从NetworkManager获取所有线路
        for (Line line : NetworkManager.getAllLines()) {
            if (filter.isEmpty() ||
                    line.getId().toLowerCase().contains(filter) ||
                    line.getName().toLowerCase().contains(filter)) {
                allLines.add(line);
            }
        }

        // 更新列表
        lineList.refreshLines(allLines);

        // 更新按钮状态
        updateButtonStates();
    }

    /**
     * 更新按钮状态
     */
    private void updateButtonStates() {
        boolean hasSelection = selectedLine != null;
        editButton.active = hasSelection;
        deleteButton.active = hasSelection;
    }

    /**
     * 创建新线路
     */
    private void onCreateLine() {
        // 打开创建线路界面
        Minecraft.getInstance().setScreen(new LineEditScreen(null));
    }

    /**
     * 编辑选中线路
     */
    private void onEditLine() {
        if (selectedLine != null) {
            Minecraft.getInstance().setScreen(new LineEditScreen(selectedLine));
        }
    }

    /**
     * 删除选中线路
     */
    private void onDeleteLine() {
        if (selectedLine != null) {
            // 确认对话框
            Minecraft.getInstance().setScreen(new ConfirmScreen(
                    this::onConfirmDelete,
                    LanguageHelper.translate("gui.confirm_delete_line"),
                    LanguageHelper.translate("gui.confirm_delete_line_message", selectedLine.getName())
            ));
        }
    }

    /**
     * 确认删除回调
     */
    private void onConfirmDelete(boolean confirmed) {
        if (confirmed && selectedLine != null) {
            // 删除线路
            boolean success = LineManager.removeLine(selectedLine.getId());
            if (success) {
                Minecraft.getInstance().player.displayClientMessage(
                        LanguageHelper.translate("gui.line_deleted", selectedLine.getName()),
                        true);
                selectedLine = null;
                refreshLines();
            } else {
                Minecraft.getInstance().player.displayClientMessage(
                        LanguageHelper.translate("gui.line_delete_failed"),
                        true);
            }
        }

        // 返回到线路管理界面
        Minecraft.getInstance().setScreen(this);
    }

    /**
     * 返回上一界面
     */
    private void onBack() {
        Minecraft.getInstance().setScreen(null);
    }

    /**
     * 设置选中线路
     */
    public void setSelectedLine(Line line) {
        this.selectedLine = line;
        updateButtonStates();
    }

    /**
     * 获取选中线路
     */
    public Line getSelectedLine() {
        return selectedLine;
    }

    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
        // 渲染背景
        renderBackground(guiGraphics);

        // 渲染标题
        guiGraphics.drawString(font, title, LIST_X, 10, 0xFFFFFF);

        // 渲染选中线路信息
        if (selectedLine != null) {
            int infoX = BUTTON_X;
            int infoY = BUTTON_Y_START + BUTTON_SPACING * 3 + 10;

            guiGraphics.drawString(font,
                    LanguageHelper.translate("gui.selected_line") + ": " + selectedLine.getName(),
                    infoX, infoY, 0xFFFFFF);

            guiGraphics.drawString(font,
                    LanguageHelper.translate("gui.station_count") + ": " + selectedLine.getStationCount(),
                    infoX, infoY + 12, 0xCCCCCC);

            guiGraphics.drawString(font,
                    LanguageHelper.translate("gui.line_color") + ": " + selectedLine.getColor(),
                    infoX, infoY + 24, 0xCCCCCC);
        }

        // 渲染其他组件
        super.render(guiGraphics, mouseX, mouseY, partialTicks);
    }

    // ==================== 线路列表组件 ====================

    /**
     * 线路列表组件
     */
    private static class LineList extends AbstractSelectionList<LineList.LineEntry> {
        private final LineManagementScreen parent;
        private List<Line> lines = new ArrayList<>();

        public LineList(LineManagementScreen parent, int x, int y, int width, int height) {
            super(Minecraft.getInstance(), width, height, y, y + height, 20);
            this.parent = parent;
            this.setLeftPos(x);
        }

        /**
         * 刷新线路列表
         */
        public void refreshLines(List<Line> lines) {
            this.clearEntries();
            this.lines = new ArrayList<>(lines);

            for (Line line : lines) {
                this.addEntry(new LineEntry(line));
            }
        }

        @Override
        public void setSelected(@org.jetbrains.annotations.Nullable LineEntry entry) {
            super.setSelected(entry);
            if (entry != null) {
                parent.setSelectedLine(entry.line);
            }
        }

        @Override
        public int getRowWidth() {
            return width - 10; // 留出滚动条空间
        }

        @Override
        protected int getScrollbarPosition() {
            return this.x0 + this.width - 6;
        }


        @Override
        public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
            // 绘制背景
            guiGraphics.fill(this.x0, this.y0, this.x0 + this.width, this.y0 + this.height, 0x88000000);

            // 绘制边框
            guiGraphics.renderOutline(this.x0, this.y0, this.width, this.height, 0xFF666666);

            // 渲染条目
            super.render(guiGraphics, mouseX, mouseY, partialTicks);
        }

        @Override
        public void updateNarration(NarrationElementOutput narrationElementOutput) {
            // 无障碍功能支持
        }

        /**
         * 线路列表条目
         */
        private class LineEntry extends AbstractSelectionList.Entry<LineEntry> {
            private final Line line;

            public LineEntry(Line line) {
                this.line = line;
            }

            @Override
            public void render(GuiGraphics guiGraphics, int index, int top, int left, int width, int height,
                              int mouseX, int mouseY, boolean isMouseOver, float partialTicks) {
                // 背景色
                int backgroundColor = isMouseOver ? 0x44666666 : (index % 2 == 0 ? 0x44333333 : 0x44222222);
                if (line.equals(parent.getSelectedLine())) {
                    backgroundColor = 0x440099FF; // 选中颜色
                }

                guiGraphics.fill(left, top, left + width, top + height, backgroundColor);

                // 线路信息
                int textY = top + 6;

                // 线路ID和名称
                String displayText = line.getId() + " - " + line.getName();
                guiGraphics.drawString(Minecraft.getInstance().font, displayText,
                        left + 5, textY, 0xFFFFFF);

                // 车站数量和颜色
                String details = line.getStationCount() + "站 | " + line.getColor();
                guiGraphics.drawString(Minecraft.getInstance().font, details,
                        left + 5, textY + 10, 0xCCCCCC);

                // 分隔线
                guiGraphics.hLine(left, left + width - 1, top + height - 1, 0x44FFFFFF);
            }

            @Override
            public boolean mouseClicked(double mouseX, double mouseY, int button) {
                if (button == 0) { // 左键点击
                    LineList.this.setSelected(this);
                    return true;
                }
                return false;
            }

            @Override
            public Component getNarration() {
                return Component.literal("线路 " + line.getName());
            }
        }
    }

    // ==================== 确认对话框 ====================

    /**
     * 简单确认对话框
     */
    private static class ConfirmScreen extends Screen {
        private final java.util.function.Consumer<Boolean> callback;
        private final Component title;
        private final Component message;

        public ConfirmScreen(java.util.function.Consumer<Boolean> callback, Component title, Component message) {
            super(title);
            this.callback = callback;
            this.title = title;
            this.message = message;
        }

        @Override
        protected void init() {
            int centerX = width / 2 - 50;
            int centerY = height / 2;

            // 确认按钮
            addRenderableWidget(Button.builder(Component.literal("确认"), button -> {
                callback.accept(true);
            }).bounds(centerX - 60, centerY + 20, 50, 20).build());

            // 取消按钮
            addRenderableWidget(Button.builder(Component.literal("取消"), button -> {
                callback.accept(false);
            }).bounds(centerX + 10, centerY + 20, 50, 20).build());
        }

        @Override
        public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
            renderBackground(guiGraphics);

            // 标题
            guiGraphics.drawCenteredString(font, title, width / 2, height / 2 - 30, 0xFFFFFF);

            // 消息
            guiGraphics.drawCenteredString(font, message, width / 2, height / 2 - 10, 0xCCCCCC);

            super.render(guiGraphics, mouseX, mouseY, partialTicks);
        }

        @Override
        public void onClose() {
            // 如果直接关闭，视为取消
            callback.accept(false);
            super.onClose();
        }
    }
}package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.block.TicketMachineBlockEntity;
import com.easttown.ticketsystem.init.MenuInit;
import com.easttown.ticketsystem.TicketSystemMod;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.world.entity.player.Inventory;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.inventory.AbstractContainerMenu;
import net.minecraft.world.inventory.ContainerData;
import net.minecraft.world.inventory.Slot;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.common.capabilities.ForgeCapabilities;
import net.minecraftforge.items.IItemHandler;
import net.minecraftforge.items.SlotItemHandler;

public class TicketMachineMenu extends AbstractContainerMenu {
    // 槽位位置常量 - 标准间距 (18像素)
    public static final int PLAYER_INVENTORY_X = 8;
    public static final int PLAYER_INVENTORY_Y = 175; // 调整为更合适的位置
    public static final int HOTBAR_Y = PLAYER_INVENTORY_Y+16*3+6+4; // 标准箱子布局的快捷栏位置
    
    // 输出槽位置 (只用于用户模式)
    public static final int USER_OUTPUT_SLOT_X = 233;
    public static final int USER_OUTPUT_SLOT_Y = 60;
    
    public final TicketMachineBlockEntity blockEntity;
    private final ContainerData data;
    private final boolean adminMode;
    
    public TicketMachineMenu(int containerId, Inventory inventory, FriendlyByteBuf extraData) {
        this(containerId, inventory, 
            (TicketMachineBlockEntity) inventory.player.level().getBlockEntity(extraData.readBlockPos()),
            extraData.readBoolean());
    }
    
    public TicketMachineMenu(int containerId, Inventory inventory, TicketMachineBlockEntity blockEntity, boolean adminMode) {
        super(MenuInit.TICKET_MACHINE_MENU.get(), containerId);
        this.blockEntity = blockEntity;
        this.adminMode = adminMode;
        this.data = new ContainerData() {
            @Override
            public int get(int index) { return 0; }
            @Override
            public void set(int index, int value) {}
            @Override
            public int getCount() { return 0; }
        };
        
        // 添加玩家物品栏槽位 - 使用标准18像素间距
        for (int row = 0; row < 3; row++) {
            for (int col = 0; col < 9; col++) {
                this.addSlot(new Slot(
                    inventory, 
                    col + row * 9 + 9, 
                    PLAYER_INVENTORY_X + col * 18, 
                    PLAYER_INVENTORY_Y + row * 18
                ));
                com.easttown.ticketsystem.util.DebugLogger.info("x:"+PLAYER_INVENTORY_X+"y:"+PLAYER_INVENTORY_Y);
            }
        }
        
        // 添加快捷栏槽位 - 使用标准18像素间距
        for (int col = 0; col < 9; col++) {
            this.addSlot(new Slot(
                inventory, 
                col, 
                PLAYER_INVENTORY_X + col * 18, 
                HOTBAR_Y
            ));
        }
        
        // 只在用户模式下添加输出槽
        if (!adminMode && blockEntity != null) {
            IItemHandler handler = blockEntity.getCapability(ForgeCapabilities.ITEM_HANDLER, null).orElse(null);
            if (handler != null) {
                this.addSlot(new OutputSlot(handler, 0, USER_OUTPUT_SLOT_X, USER_OUTPUT_SLOT_Y));
            }
        }
        
        addDataSlots(data);
    }
    
    // 输出槽专用类
    private static class OutputSlot extends SlotItemHandler {
        public OutputSlot(IItemHandler itemHandler, int index, int x, int y) {
            super(itemHandler, index, x, y);
        }
        
        @Override
        public boolean mayPlace(ItemStack stack) {
            return false;
        }
    }
    
    @Override
    public ItemStack quickMoveStack(Player player, int index) {
        return ItemStack.EMPTY;
    }
    
    @Override
    public boolean stillValid(Player player) {
        return blockEntity != null && 
               !blockEntity.isRemoved() &&
               player.distanceToSqr(
                   blockEntity.getBlockPos().getX() + 0.5, 
                   blockEntity.getBlockPos().getY() + 0.5, 
                   blockEntity.getBlockPos().getZ() + 0.5) <= 64;
    }
    
    public boolean isAdminMode() {
        return adminMode;
    }
}
package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.client.AdminStationList;
import com.easttown.ticketsystem.client.BaseStationList;
import com.easttown.ticketsystem.client.UserStationList;
import net.minecraft.core.BlockPos;
import com.easttown.ticketsystem.manager.CoinSystem;
import com.easttown.ticketsystem.manager.PriceCalculator;
import com.easttown.ticketsystem.network.NetworkHandler;
import com.easttown.ticketsystem.network.PrintTicketPacket;
import com.easttown.ticketsystem.network.SetStartStationPacket;
import com.easttown.ticketsystem.network.WithdrawCoinsPacket;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.EditBox;
import net.minecraft.client.gui.screens.inventory.AbstractContainerScreen;
import net.minecraft.network.chat.Component;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.entity.player.Inventory;

import java.util.Map;

public class TicketMachineScreen extends AbstractContainerScreen<TicketMachineMenu>
        implements BaseStationList.StationListProvider {
    // GUI 尺寸常量
    public static final int ADMIN_IMAGE_WIDTH = 300;
    public static final int ADMIN_IMAGE_HEIGHT = 290;
    public static final int USER_IMAGE_WIDTH = 290;
    public static final int USER_IMAGE_HEIGHT = 270;

    // 列表位置常量
    public static final int ADMIN_LIST_X = 20;
    public static final int ADMIN_LIST_Y = 50;
    public static final int ADMIN_LIST_WIDTH = 120;
    public static final int ADMIN_LIST_HEIGHT = 120;

    public static final int USER_LIST_X = 20;
    public static final int USER_LIST_Y = 50;
    public static final int USER_LIST_WIDTH = 120;
    public static final int USER_LIST_HEIGHT = 120;

    // 搜索框位置
    public static final int SEARCH_X = 75;
    public static final int SEARCH_Y = 5;
    public static final int SEARCH_WIDTH = 150;
    public static final int SEARCH_HEIGHT = 20;

    // 按钮位置
    public static final int ADMIN_ADD_BUTTON_X = 180;
    public static final int ADMIN_ADD_BUTTON_Y = 20;
    public static final int ADMIN_SET_BUTTON_X = 180;
    public static final int ADMIN_SET_BUTTON_Y = 50;
    public static final int ADMIN_DELETE_BUTTON_X = 180;
    public static final int ADMIN_DELETE_BUTTON_Y = 80;

    public static final int USER_PRINT_BUTTON_X = 147;
    public static final int USER_PRINT_BUTTON_Y = 80;

    public static final int BUTTON_WIDTH = 100;
    public static final int BUTTON_HEIGHT = 20;

    // 信息显示位置
    public static final int INFO_X = 20;
    public static final int INFO_Y = 30;
    public static final int INFO_WIDTH = 155;
    public static final int INFO_HEIGHT = 10;

    public static final int PRICE_X = 150;
    public static final int PRICE_Y = 50;
    public static final int PRICE_WIDTH = 110;
    public static final int PRICE_HEIGHT = 20;

    // 硬币信息显示位置
    public static final int COINS_X = 150;
    public static final int COINS_Y = 75;
    public static final int COINS_WIDTH = 110;
    public static final int COINS_HEIGHT = 40;

    // 取款按钮位置
    public static final int WITHDRAW_BUTTON_X = 147;
    public static final int WITHDRAW_BUTTON_Y = 170;

    // 标签位置
    public static final int ADMIN_LABEL_X = 175;
    public static final int ADMIN_LABEL_Y = 5;
    public static final int ADMIN_LABEL_WIDTH = 110;
    public static final int ADMIN_LABEL_HEIGHT = 10;

    public static final int ADMIN_LIST_TITLE_X = 20;
    public static final int ADMIN_LIST_TITLE_Y = 30;
    public static final int ADMIN_LIST_TITLE_WIDTH = 120;
    public static final int ADMIN_LIST_TITLE_HEIGHT = 10;

    public static final int USER_LIST_TITLE_X = 17;
    public static final int USER_LIST_TITLE_Y = 30;
    public static final int USER_LIST_TITLE_WIDTH = 120;
    public static final int USER_LIST_TITLE_HEIGHT = 10;

    // 翻页按钮位置
    public static final int ADMIN_PREV_PAGE_BUTTON_X = 20;
    public static final int ADMIN_NEXT_PAGE_BUTTON_X = 140;
    public static final int ADMIN_PAGE_BUTTON_Y = 175;

    public static final int USER_PREV_PAGE_BUTTON_X = 20;
    public static final int USER_NEXT_PAGE_BUTTON_X = 240;
    public static final int USER_PAGE_BUTTON_Y = 5;

    public static final int PAGE_BUTTON_WIDTH = 40;
    public static final int PAGE_BUTTON_HEIGHT = 20;

    // 纹理资源
    private final ResourceLocation ADMIN_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID,
            "textures/gui/admin_ticket_machine.png");
    private final ResourceLocation USER_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID,
            "textures/gui/user_ticket_machine.png");
    private final ResourceLocation SLOT_TEXTURE = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID,
            "textures/gui/gui_slots/slot.png");
    private final ResourceLocation CREATE_INVENTORY_9X3 = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID,
            "textures/gui/gui_slots/create_inventory_9x3.png");
    private final ResourceLocation CREATE_INVENTORY_9X1 = ResourceLocation.fromNamespaceAndPath(TicketSystemMod.MODID,
            "textures/gui/gui_slots/create_inventory_9x1.png");
    // UI 组件
    private EditBox searchBox;
    private Button printButton, addButton, setStartButton, deleteButton;
    private Button prevPageButton, nextPageButton;
    private final AdminStationList adminStationList;
    private final UserStationList userStationList;
    private Button withdrawButton; // 取款按钮

    // 状态变量
    private String selectedStation = "";
    private int estimatedPrice = 0;
    private final BlockPos machinePos;
    protected boolean debugMode = false;

    // 当前界面尺寸
    private int currentWidth;
    private int currentHeight;

    // 用于跟踪起始站变化
    private String lastStartStation = "";

    public TicketMachineScreen(TicketMachineMenu menu, Inventory inventory, Component title) {
        super(menu, inventory, title);

        this.machinePos = menu.blockEntity.getBlockPos();

        // 初始化车站列表
        this.adminStationList = new AdminStationList(
        this,
        leftPos + ADMIN_LIST_X,
        topPos + ADMIN_LIST_Y,
        ADMIN_LIST_WIDTH,
        ADMIN_LIST_HEIGHT);

        this.userStationList = new UserStationList(
        this,
        leftPos + USER_LIST_X,
        topPos + USER_LIST_Y,
        USER_LIST_WIDTH,
        USER_LIST_HEIGHT);

        // 根据模式设置不同尺寸
        if (menu.isAdminMode()) {
            this.imageWidth = ADMIN_IMAGE_WIDTH;
            this.imageHeight = ADMIN_IMAGE_HEIGHT;
        } else {
            this.imageWidth = USER_IMAGE_WIDTH;
            this.imageHeight = USER_IMAGE_HEIGHT;
        }

        currentWidth = imageWidth;
        currentHeight = imageHeight;
    }

    @Override
    protected void init() {
        super.init();

        // 计算GUI居中位置
        leftPos = (width - currentWidth) / 2;
        topPos = (height - currentHeight) / 2;
        com.easttown.ticketsystem.util.DebugLogger.info(
                String.format("GUI初始化: 屏幕=%dx%d, GUI=%dx%d, 位置=(%d,%d)",
                        this.width, this.height, this.imageWidth, this.imageHeight,
                        this.leftPos, this.topPos)
        );
        // 搜索框
        searchBox = new EditBox(font,
        leftPos + SEARCH_X, topPos + SEARCH_Y,
        SEARCH_WIDTH, SEARCH_HEIGHT,
        Component.translatable("ticketsystem.gui.search_station"));
        searchBox.setResponder(text -> refreshStations());
        addRenderableWidget(searchBox);

        // 管理员按钮
        addButton = Button.builder(Component.translatable("ticketsystem.gui.add_station"), button -> {
            BlockPos playerPos = Minecraft.getInstance().player.blockPosition();
            Minecraft.getInstance().setScreen(new AddStationScreen(playerPos));
        })
                .bounds(leftPos + ADMIN_ADD_BUTTON_X, topPos + ADMIN_ADD_BUTTON_Y, BUTTON_WIDTH, BUTTON_HEIGHT)
                .build();
        addRenderableWidget(addButton);

        setStartButton = Button.builder(Component.translatable("ticketsystem.gui.set_start"), button -> {
            if (!selectedStation.isEmpty()) {
                NetworkHandler.sendToServer(new SetStartStationPacket(machinePos, selectedStation));
                selectedStation = "";
                refreshStations();
            } else {
                Minecraft.getInstance().player.displayClientMessage(
                        Component.translatable("ticketsystem.command.station_not_selected"), true);
            }
        })
                .bounds(leftPos + ADMIN_SET_BUTTON_X, topPos + ADMIN_SET_BUTTON_Y, BUTTON_WIDTH, BUTTON_HEIGHT)
                .build();
        addRenderableWidget(setStartButton);

        deleteButton = Button.builder(Component.translatable("ticketsystem.gui.delete_station"), button -> {
            if (!selectedStation.isEmpty()) {
                Minecraft.getInstance().player.connection.sendCommand(
                        "ticketsystem deletestation " + selectedStation);
                selectedStation = "";
                refreshStations();
            } else {
                Minecraft.getInstance().player.displayClientMessage(
                        Component.translatable("ticketsystem.command.station_not_selected"), true);
            }
        })
                .bounds(leftPos + ADMIN_DELETE_BUTTON_X, topPos + ADMIN_DELETE_BUTTON_Y, BUTTON_WIDTH, BUTTON_HEIGHT)
                .build();
        addRenderableWidget(deleteButton);

        // 用户按钮 - 打印车票按钮
        printButton = Button.builder(Component.translatable("ticketsystem.gui.buy_ticket"), button -> {
            if (!selectedStation.isEmpty()) {
                NetworkHandler.sendToServer(new PrintTicketPacket(machinePos, selectedStation));
            } else {
                Minecraft.getInstance().player.displayClientMessage(
                        Component.translatable("ticketsystem.command.destination_not_selected"), true);
            }
        })
                .bounds(leftPos + USER_PRINT_BUTTON_X, topPos + USER_PRINT_BUTTON_Y, BUTTON_WIDTH, BUTTON_HEIGHT)
                .build();
        addRenderableWidget(printButton);

        // 翻页按钮
        boolean isAdminMode = menu.isAdminMode();
        prevPageButton = Button.builder(Component.literal("◀"), button -> {
            if (isAdminMode) {
                adminStationList.prevPage();
            } else {
                userStationList.prevPage();
            }
        })
                .bounds(
                        leftPos + (isAdminMode ? ADMIN_PREV_PAGE_BUTTON_X : USER_PREV_PAGE_BUTTON_X),
                        topPos + (isAdminMode ? ADMIN_PAGE_BUTTON_Y : USER_PAGE_BUTTON_Y),
                        PAGE_BUTTON_WIDTH, PAGE_BUTTON_HEIGHT)
                .build();
        addRenderableWidget(prevPageButton);

        nextPageButton = Button.builder(Component.literal("▶"), button -> {
            if (isAdminMode) {
                adminStationList.nextPage();
            } else {
                userStationList.nextPage();
            }
        })
                .bounds(
                        leftPos + (isAdminMode ? ADMIN_NEXT_PAGE_BUTTON_X : USER_NEXT_PAGE_BUTTON_X),
                        topPos + (isAdminMode ? ADMIN_PAGE_BUTTON_Y : USER_PAGE_BUTTON_Y),
                        PAGE_BUTTON_WIDTH, PAGE_BUTTON_HEIGHT)
                .build();
        addRenderableWidget(nextPageButton);

        // 添加车站列表组件
        addRenderableWidget(adminStationList);
        addRenderableWidget(userStationList);

        // 添加取款按钮
        withdrawButton = Button.builder(Component.translatable("ticketsystem.gui.withdraw_coins"), button -> {
            NetworkHandler.sendToServer(new WithdrawCoinsPacket(machinePos));
        })
                .bounds(leftPos + WITHDRAW_BUTTON_X, topPos + WITHDRAW_BUTTON_Y, BUTTON_WIDTH, BUTTON_HEIGHT)
                .build();
        addRenderableWidget(withdrawButton);

        // 更新组件可见性
        updateComponentVisibility();
        // 刷新车站数据
        refreshStations();

        // 初始化起始站跟踪
        lastStartStation = getStartStation();
    }

    // 刷新车站数据
    private void refreshStations() {
        String filter = searchBox.getValue();
        adminStationList.refreshStations(filter);
        userStationList.refreshStations(filter);
        updatePriceEstimate();
        updatePageButtons();
    }

    // 更新翻页按钮状态
    private void updatePageButtons() {
        if (menu.isAdminMode()) {
            prevPageButton.active = adminStationList.hasPrevPage();
            nextPageButton.active = adminStationList.hasNextPage();
        } else {
            prevPageButton.active = userStationList.hasPrevPage();
            nextPageButton.active = userStationList.hasNextPage();
        }
    }

    // 更新价格估算
    private void updatePriceEstimate() {
        String startStation = menu.blockEntity.getStartStation();
        if (startStation == null || startStation.isEmpty() ||
                selectedStation.isEmpty() || startStation.equals(selectedStation)) {
            estimatedPrice = 0;
        } else {
            estimatedPrice = PriceCalculator.calculatePrice(startStation, selectedStation);
        }
    }

    // 更新组件可见性
    private void updateComponentVisibility() {
        boolean adminMode = menu.isAdminMode();
        addButton.visible = adminMode;
        setStartButton.visible = adminMode;
        deleteButton.visible = adminMode;
        printButton.visible = !adminMode;
        withdrawButton.visible = adminMode; // 只显示给管理员

        adminStationList.setVisible(adminMode);
        userStationList.setVisible(!adminMode);

        prevPageButton.visible = true;
        nextPageButton.visible = true;
    }

    @Override
    protected void renderBg(GuiGraphics guiGraphics, float partialTicks, int mouseX, int mouseY) {
        // 检查起始站是否变化
        String currentStartStation = getStartStation();
        if (!currentStartStation.equals(lastStartStation)) {
            lastStartStation = currentStartStation;
            updatePriceEstimate();
            refreshStations();
        }

        // 根据模式选择不同纹理
        ResourceLocation texture = menu.isAdminMode() ? ADMIN_TEXTURE : USER_TEXTURE;

        // 渲染背景纹理
        if (texture != null) {
            try {
                guiGraphics.blit(texture,
                        leftPos, topPos,
                        0, 0,
                        currentWidth, currentHeight,
                        currentWidth, currentHeight);
            } catch (Exception e) {
                guiGraphics.fill(leftPos, topPos, leftPos + currentWidth, topPos + currentHeight, 0xFFE0F7FA);
            }
        } else {
            guiGraphics.fill(leftPos, topPos, leftPos + currentWidth, topPos + currentHeight, 0xFFE0F7FA);
        }

        // 获取并显示起始站信息
        String startStation = menu.blockEntity.getStartStation();
        String displayStart = (startStation == null || startStation.isEmpty())
                ? Component.translatable("ticketsystem.gui.not_set").getString()
                : startStation;

        // 绘制起始站信息背景 - 使用更明显的背景
        guiGraphics.fill(
                leftPos + INFO_X, topPos + INFO_Y,
                leftPos + INFO_X + INFO_WIDTH, topPos + INFO_Y + INFO_HEIGHT,
                0xAA000000); // 改为半透明黑色背景

        // 绘制起始站文本 - 使用白色文字
        guiGraphics.drawString(
                font,
                LanguageHelper.translate("gui.start_station", displayStart).getString(),
                leftPos + INFO_X + 5, topPos + INFO_Y + 2,
                0xFFFFFFFF, // 白色
                false);

        // 管理员模式特定渲染
        if (menu.isAdminMode()) {
            // 绘制管理员标签背景
            guiGraphics.fill(
                    leftPos + ADMIN_LABEL_X, topPos + ADMIN_LABEL_Y,
                    leftPos + ADMIN_LABEL_X + ADMIN_LABEL_WIDTH, topPos + ADMIN_LABEL_Y + ADMIN_LABEL_HEIGHT,
                    0xAA000000);

            // 绘制管理员模式文本
            guiGraphics.drawString(
                    font,
                    LanguageHelper.translate("gui.admin_mode").getString(),
                    leftPos + ADMIN_LABEL_X + 5, topPos + ADMIN_LABEL_Y + 2,
                    0xFFFF0000, // 红色
                    false);

            // 绘制车站列表标题背景
            guiGraphics.fill(
                    leftPos + ADMIN_LIST_TITLE_X, topPos + ADMIN_LIST_TITLE_Y,
                    leftPos + ADMIN_LIST_TITLE_X + ADMIN_LIST_TITLE_WIDTH,
                    topPos + ADMIN_LIST_TITLE_Y + ADMIN_LIST_TITLE_HEIGHT,
                    0xAA000000);

            // 绘制车站列表标题
            guiGraphics.drawString(
                    font,
                    LanguageHelper.translate("gui.all_stations").getString(),
                    leftPos + ADMIN_LIST_TITLE_X, topPos + ADMIN_LIST_TITLE_Y + 18,
                    0xFFFFFFFF,
                    false);

            // 绘制页码信息 - 管理员模式
            String pageInfo = LanguageHelper.translate("gui.page_indicator",
                    adminStationList.getCurrentPage() + 1,
                    adminStationList.getTotalPages()).getString();
            guiGraphics.drawString(
                    font,
                    pageInfo,
                    leftPos + ADMIN_PREV_PAGE_BUTTON_X + 20,
                    topPos + ADMIN_PAGE_BUTTON_Y + 6,
                    0x000000,
                    false);

            // 显示硬币存储信息
            int totalValue = menu.blockEntity.getTotalCopperValue();
            Map<String, Integer> storedCoins = menu.blockEntity.getStoredCoins();

            // 硬币存储背景框
            guiGraphics.fill(
                    leftPos + COINS_X, topPos + COINS_Y,
                    leftPos + COINS_X + COINS_WIDTH, topPos + COINS_Y + COINS_HEIGHT,
                    0xAAFFFF00);

            // 显示总价值
            guiGraphics.drawString(
                    font,
                    LanguageHelper.translate("gui.total_coins", totalValue).getString(),
                    leftPos + COINS_X + 5, topPos + COINS_Y + 5,
                    0x000000,
                    false);

            // 显示各种硬币数量
            int yOffset = 20;
            for (Map.Entry<String, Integer> entry : storedCoins.entrySet()) {
                if (entry.getValue() > 0) {
                    String coinName = CoinSystem.getCoinName(entry.getKey());
                    guiGraphics.drawString(
                            font,
                            LanguageHelper.translate("gui.coin_amount", coinName, entry.getValue()).getString(),
                            leftPos + COINS_X + 5, topPos + COINS_Y + yOffset,
                            0x000000,
                            false);
                    yOffset += 10;
                }
            }
        }
        // 用户模式特定渲染
        else {
            // 绘制目的地列表标题背景
            guiGraphics.fill(
                    leftPos + USER_LIST_TITLE_X, topPos + USER_LIST_TITLE_Y,
                    leftPos + USER_LIST_TITLE_X + USER_LIST_TITLE_WIDTH,
                    topPos + USER_LIST_TITLE_Y + USER_LIST_TITLE_HEIGHT,
                    0xAA000000);

            // 绘制目的地列表标题
            guiGraphics.drawString(
                    font,
                    LanguageHelper.translate("gui.select_destination").getString(),
                    leftPos + USER_LIST_TITLE_X, topPos + USER_LIST_TITLE_Y + 20,
                    0xFFFFFFFF,
                    false);

            // 绘制页码信息 - 用户模式
            String pageInfo = LanguageHelper.translate("gui.page_indicator",
                    userStationList.getCurrentPage() + 1,
                    userStationList.getTotalPages()).getString();
            guiGraphics.drawString(
                    font,
                    pageInfo,
                    leftPos + USER_PRINT_BUTTON_X,
                    topPos + USER_PRINT_BUTTON_Y + 30,
                    0x000000,
                    false);

            // 只在用户模式下显示价格估算
            if (estimatedPrice > 0) {
                // 价格背景框
                guiGraphics.fill(
                        leftPos + PRICE_X, topPos + PRICE_Y,
                        leftPos + PRICE_X + PRICE_WIDTH, topPos + PRICE_Y + PRICE_HEIGHT,
                        0xAA00AA00);

                // 价格文本
                guiGraphics.drawString(
                        font,
                        LanguageHelper.translate("gui.estimated_price", estimatedPrice).getString(),
                        leftPos + PRICE_X + 5, topPos + PRICE_Y + 6,
                        0xFFFFFFFF,
                        false);
            } else if (!selectedStation.isEmpty()) {
                // 警告背景框
                guiGraphics.fill(
                        leftPos + PRICE_X, topPos + PRICE_Y,
                        leftPos + PRICE_X + PRICE_WIDTH, topPos + PRICE_Y + PRICE_HEIGHT,
                        0xAAFF0000);

                // 警告文本
                guiGraphics.drawString(
                        font,
                        LanguageHelper.translate("gui.same_station_warning").getString(),
                        leftPos + PRICE_X + 5, topPos + PRICE_Y + 6,
                        0xFFFFFFFF,
                        false);
            }
        }

        // 绘制槽位背景
        renderSlotBackgrounds(guiGraphics, leftPos, topPos);
    }

    // 设置选中的车站
    public void setSelectedStation(String station) {
        this.selectedStation = station;
        updatePriceEstimate();
    }

    // 获取选中的车站
    public String getSelectedStation() {
        return selectedStation;
    }

    // 获取起始站
    public String getStartStation() {
        return menu.blockEntity.getStartStation();
    }

    // 获取搜索文本
    public String getSearchText() {
        return searchBox.getValue();
    }

    // 获取列表位置和尺寸
    public int getAdminListX() {
        return ADMIN_LIST_X;
    }

    public int getAdminListY() {
        return ADMIN_LIST_Y;
    }

    public int getAdminListWidth() {
        return ADMIN_LIST_WIDTH;
    }

    public int getAdminListHeight() {
        return ADMIN_LIST_HEIGHT;
    }

    public int getUserListX() {
        return USER_LIST_X;
    }

    public int getUserListY() {
        return USER_LIST_Y;
    }

    public int getUserListWidth() {
        return USER_LIST_WIDTH;
    }

    public int getUserListHeight() {
        return USER_LIST_HEIGHT;
    }

    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
        // 更新列表位置和尺寸
        adminStationList.setPosition(
                leftPos + getAdminListX(),
                topPos + getAdminListY(),
                getAdminListWidth(),
                getAdminListHeight());

        userStationList.setPosition(
                leftPos + getUserListX(),
                topPos + getUserListY(),
                getUserListWidth(),
                getUserListHeight());

        // 更新翻页按钮状态
        updatePageButtons();

        // 渲染背景
        renderBackground(guiGraphics);
        super.render(guiGraphics, mouseX, mouseY, partialTicks);

        // 渲染工具提示
        renderTooltip(guiGraphics, mouseX, mouseY);
    }

    // 绘制槽位背景
    private void renderSlotBackgrounds(GuiGraphics guiGraphics, int x, int y) {
        // 对于 18×18 纹理，明确指定纹理尺寸
        final int SLOT_SIZE = 18;
        final int TEXTURE_SIZE = 18; // 因为你的纹理就是 18×18
        guiGraphics.blit(CREATE_INVENTORY_9X3,
                TicketMachineMenu.PLAYER_INVENTORY_X - 1 + x, TicketMachineMenu.PLAYER_INVENTORY_Y - 1 + y,
                0, 0,
                18 * 9, 18 * 3,
                18 * 9, 18 * 3);

        guiGraphics.blit(CREATE_INVENTORY_9X1,
                TicketMachineMenu.PLAYER_INVENTORY_X - 1 + x, TicketMachineMenu.HOTBAR_Y - 1 + y,
                0, 0,
                18 * 9, 18 * 1,
                18 * 9, 18 * 1);

        /*    // 玩家物品栏 (3行9列)
                        for (int row = 0; row < 3; row++) {
                            for (int col = 0; col < 9; col++) {
                                int slotX = TicketMachineMenu.PLAYER_INVENTORY_X + col * SLOT_SIZE - 1;
                                int slotY = TicketMachineMenu.PLAYER_INVENTORY_Y + row * SLOT_SIZE - 1;
                                guiGraphics.blit(SLOT_TEXTURE,
                                        x + slotX, y + slotY,
                                        0, 0,
                                        SLOT_SIZE, SLOT_SIZE,
                                        TEXTURE_SIZE, TEXTURE_SIZE);
                                com.easttown.ticketsystem.util.DebugLogger.info("Slot X: " + slotX + ", Slot Y: " + slotY);
                            }
                        }

                // 快捷栏 (9个)
                for (int i = 0; i < 9; i++) {
                    int slotX = TicketMachineMenu.PLAYER_INVENTORY_X + i * 18 - 1;
                    int slotY = TicketMachineMenu.HOTBAR_Y - 1; // HOTBAR_Y - 1
                    guiGraphics.blit(SLOT_TEXTURE,
                            x + slotX, y + slotY,
                            0, 0,
                            SLOT_SIZE, SLOT_SIZE,
                            TEXTURE_SIZE, TEXTURE_SIZE);
                }
        */
        // 用户模式输出槽
        if (!menu.isAdminMode()) {
            int outputSlotX = TicketMachineMenu.USER_OUTPUT_SLOT_X - 1;
            int outputSlotY = TicketMachineMenu.USER_OUTPUT_SLOT_Y - 1;
            guiGraphics.blit(SLOT_TEXTURE,
                    x + outputSlotX, y + outputSlotY,
                    0, 0,
                    SLOT_SIZE, SLOT_SIZE,
                    TEXTURE_SIZE, TEXTURE_SIZE);
        }
    }
}
package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Station;
import com.easttown.ticketsystem.manager.NetworkManager;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.Button;
import net.minecraft.client.gui.components.EditBox;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;
import net.minecraftforge.api.distmarker.Dist;
import net.minecraftforge.api.distmarker.OnlyIn;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

/**
 * 车站管理屏幕
 * 显示所有车站列表，允许添加、删除、编辑车站
 */
@OnlyIn(Dist.CLIENT)
public class StationManagementScreen extends Screen {
    // 组件
    private EditBox searchBox;
    private Button addButton;
    private Button backButton;
    private Button refreshButton;

    // 数据
    private List<Station> allStations = new ArrayList<>();
    private List<Station> filteredStations = new ArrayList<>();

    // 显示区域
    private int scrollOffset = 0;
    private static final int ITEMS_PER_PAGE = 10;
    private static final int ITEM_HEIGHT = 20;

    public StationManagementScreen() {
        super(Component.literal("车站管理"));
    }

    @Override
    protected void init() {
        super.init();

        // 初始化网络管理器
        NetworkManager.initialize();

        // 加载车站数据
        loadStations();

        // 搜索框
        searchBox = new EditBox(
            this.font,
            this.width / 2 - 150, 40, 250, 20,
            Component.literal("搜索车站...")
        );
        searchBox.setResponder(text -> filterStations());
        this.addRenderableWidget(searchBox);

        // 刷新按钮
        refreshButton = Button.builder(
            Component.literal("刷新"),
            button -> {
                loadStations();
                filterStations();
            }
        )
        .pos(this.width / 2 + 110, 40)
        .size(40, 20)
        .build();
        this.addRenderableWidget(refreshButton);

        // 添加车站按钮
        addButton = Button.builder(
            Component.literal("添加车站"),
            button -> {
                Minecraft minecraft = Minecraft.getInstance();
                net.minecraft.core.BlockPos playerPos = minecraft.player != null ?
                    minecraft.player.blockPosition() : net.minecraft.core.BlockPos.ZERO;
                minecraft.setScreen(new AddStationScreen(playerPos));
            }
        )
        .pos(this.width / 2 - 100, this.height - 40)
        .size(100, 20)
        .build();
        this.addRenderableWidget(addButton);

        // 返回按钮
        backButton = Button.builder(
            Component.literal("返回"),
            button -> {
                this.onClose();
            }
        )
        .pos(this.width / 2 + 10, this.height - 40)
        .size(100, 20)
        .build();
        this.addRenderableWidget(backButton);

        // 上下滚动按钮
        Button scrollUpButton = Button.builder(
            Component.literal("↑"),
            button -> {
                if (scrollOffset > 0) scrollOffset--;
            }
        )
        .pos(this.width - 30, 70)
        .size(20, 20)
        .build();
        this.addRenderableWidget(scrollUpButton);

        Button scrollDownButton = Button.builder(
            Component.literal("↓"),
            button -> {
                int maxScroll = Math.max(0, filteredStations.size() - ITEMS_PER_PAGE);
                if (scrollOffset < maxScroll) scrollOffset++;
            }
        )
        .pos(this.width - 30, this.height - 50)
        .size(20, 20)
        .build();
        this.addRenderableWidget(scrollDownButton);
    }

    /**
     * 加载车站数据
     */
    private void loadStations() {
        allStations.clear();
        try {
            allStations.addAll(NetworkManager.getAllStations());
            // 按编码排序
            allStations.sort(Comparator.comparing(Station::getCode));
            TicketSystemMod.LOGGER.debug("Loaded {} stations", allStations.size());
        } catch (Exception e) {
            TicketSystemMod.LOGGER.error("Failed to load stations", e);
        }
        filteredStations = new ArrayList<>(allStations);
    }

    /**
     * 过滤车站列表
     */
    private void filterStations() {
        String query = searchBox.getValue().toLowerCase().trim();
        filteredStations.clear();

        if (query.isEmpty()) {
            filteredStations.addAll(allStations);
        } else {
            for (Station station : allStations) {
                if (station.getCode().toLowerCase().contains(query) ||
                    station.getName().toLowerCase().contains(query) ||
                    (station.getEnName() != null && station.getEnName().toLowerCase().contains(query))) {
                    filteredStations.add(station);
                }
            }
        }
        scrollOffset = 0; // 重置滚动
    }

    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTick) {
        // 渲染背景
        this.renderBackground(guiGraphics);

        // 渲染标题
        guiGraphics.drawCenteredString(this.font, this.title, this.width / 2, 20, 0xFFFFFF);

        // 渲染搜索框标签
        guiGraphics.drawString(this.font, "搜索:", this.width / 2 - 170, 45, 0xFFFFFF, false);

        // 渲染车站列表标题
        int listTop = 70;
        guiGraphics.fill(this.width / 2 - 160, listTop - 5, this.width / 2 + 150, listTop + 15, 0x80000000);
        guiGraphics.drawString(this.font, "车站编码", this.width / 2 - 150, listTop, 0xFFFFFF, false);
        guiGraphics.drawString(this.font, "车站名称", this.width / 2 - 50, listTop, 0xFFFFFF, false);
        guiGraphics.drawString(this.font, "坐标 (X,Y,Z)", this.width / 2 + 50, listTop, 0xFFFFFF, false);
        guiGraphics.drawString(this.font, "操作", this.width / 2 + 150, listTop, 0xFFFFFF, false);

        // 渲染车站列表
        int startIndex = scrollOffset;
        int endIndex = Math.min(startIndex + ITEMS_PER_PAGE, filteredStations.size());

        for (int i = startIndex; i < endIndex; i++) {
            Station station = filteredStations.get(i);
            int yPos = listTop + 20 + (i - startIndex) * ITEM_HEIGHT;

            // 交替行背景色
            if ((i - startIndex) % 2 == 0) {
                guiGraphics.fill(this.width / 2 - 160, yPos - 2, this.width / 2 + 150, yPos + ITEM_HEIGHT - 2, 0x40000000);
            }

            // 车站信息
            guiGraphics.drawString(this.font, station.getCode(), this.width / 2 - 150, yPos, 0xFFFFFF, false);
            guiGraphics.drawString(this.font, station.getName(), this.width / 2 - 50, yPos, 0xFFFFFF, false);
            guiGraphics.drawString(this.font,
                String.format("%d, %d, %d", station.getX(), station.getY(), station.getZ()),
                this.width / 2 + 50, yPos, 0xFFFFFF, false);

            // 操作按钮（在每行渲染时动态创建，但这里简化显示）
            // 实际实现应使用Button组件，但为简化，使用文本按钮
            int buttonWidth = 40;
            int editX = this.width / 2 + 150;
            int deleteX = editX + buttonWidth + 5;

            // 编辑按钮（文本）
            guiGraphics.fill(editX, yPos - 2, editX + buttonWidth, yPos + ITEM_HEIGHT - 2, 0x80008000);
            guiGraphics.drawCenteredString(this.font, "编辑", editX + buttonWidth / 2, yPos, 0xFFFFFF);

            // 删除按钮（文本）
            guiGraphics.fill(deleteX, yPos - 2, deleteX + buttonWidth, yPos + ITEM_HEIGHT - 2, 0x80800000);
            guiGraphics.drawCenteredString(this.font, "删除", deleteX + buttonWidth / 2, yPos, 0xFFFFFF);

            // 检测点击
            if (mouseX >= editX && mouseX <= editX + buttonWidth &&
                mouseY >= yPos - 2 && mouseY <= yPos + ITEM_HEIGHT - 2) {
                // 鼠标悬停在编辑按钮上
                guiGraphics.renderTooltip(this.font, Component.literal("编辑车站"), mouseX, mouseY);
                if (Minecraft.getInstance().mouseHandler.isLeftPressed()) {
                    // 打开编辑屏幕（TODO: 实现）
                    TicketSystemMod.LOGGER.debug("Edit station: {}", station.getCode());
                }
            }

            if (mouseX >= deleteX && mouseX <= deleteX + buttonWidth &&
                mouseY >= yPos - 2 && mouseY <= yPos + ITEM_HEIGHT - 2) {
                // 鼠标悬停在删除按钮上
                guiGraphics.renderTooltip(this.font, Component.literal("删除车站"), mouseX, mouseY);
                if (Minecraft.getInstance().mouseHandler.isLeftPressed()) {
                    // 删除车站（TODO: 通过网络包）
                    TicketSystemMod.LOGGER.debug("Delete station: {}", station.getCode());
                }
            }
        }

        // 显示车站计数
        String countText = String.format("车站: %d/%d", filteredStations.size(), allStations.size());
        guiGraphics.drawString(this.font, countText, this.width / 2 - 150, this.height - 60, 0xFFFFFF, false);

        // 渲染滚动位置
        if (filteredStations.size() > ITEMS_PER_PAGE) {
            String scrollText = String.format("第 %d-%d 项，共 %d 项",
                startIndex + 1, endIndex, filteredStations.size());
            guiGraphics.drawString(this.font, scrollText, this.width / 2 + 50, this.height - 60, 0xFFFFFF, false);
        }

        // 渲染父类组件（按钮等）
        super.render(guiGraphics, mouseX, mouseY, partialTick);
    }

    @Override
    public void tick() {
        super.tick();
        searchBox.tick();
    }

    @Override
    public boolean isPauseScreen() {
        return false;
    }

    @Override
    public void onClose() {
        super.onClose();
        // 返回上级屏幕（如果有）或关闭
    }
}package com.easttown.ticketsystem.screen;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.data.Station;
import com.easttown.ticketsystem.manager.LineManager;
import com.easttown.ticketsystem.manager.NetworkManager;
import com.easttown.ticketsystem.util.IdGenerator;
import com.easttown.ticketsystem.util.LanguageHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiGraphics;
import net.minecraft.client.gui.components.*;
import net.minecraft.client.gui.components.AbstractSelectionList;
import net.minecraft.client.gui.narration.NarrationElementOutput;
import net.minecraft.client.gui.screens.Screen;
import net.minecraft.network.chat.Component;

import java.util.ArrayList;
import java.util.List;

/**
 * 线路编辑界面
 * 用于创建或编辑线路信息
 */
public class LineEditScreen extends Screen {
    private final Line existingLine; // null表示创建新线路
    private final boolean isNewLine;

    // 表单字段
    private EditBox idField;
    private EditBox nameField;
    private EditBox enNameField;
    private EditBox colorField;
    private Button saveButton;
    private Button cancelButton;
    private Button addStationButton;
    private Button removeStationButton;
    private Button moveUpButton;
    private Button moveDownButton;

    // 车站选择组件
    private StationSelector stationSelector;
    private StationList stationList;

    // 车站列表数据
    private List<String> selectedStationCodes = new ArrayList<>();
    private List<Station> availableStations = new ArrayList<>();

    // 位置常量
    private static final int FIELD_WIDTH = 150;
    private static final int FIELD_HEIGHT = 20;
    private static final int FIELD_SPACING = 25;

    private static final int LEFT_COL_X = 20;
    private static final int RIGHT_COL_X = 200;
    private static final int START_Y = 40;

    private static final int STATION_LIST_WIDTH = 180;
    private static final int STATION_LIST_HEIGHT = 120;
    private static final int STATION_SELECTOR_WIDTH = 180;
    private static final int STATION_SELECTOR_HEIGHT = 120;

    public LineEditScreen(Line existingLine) {
        super(LanguageHelper.translate(existingLine == null ? "gui.create_line.title" : "gui.edit_line.title"));
        this.existingLine = existingLine;
        this.isNewLine = existingLine == null;
    }

    @Override
    protected void init() {
        super.init();

        // 确保数据管理器初始化
        NetworkManager.initialize();

        // 加载所有可用车站
        refreshAvailableStations();

        // 初始化表单字段
        int fieldY = START_Y;

        // 线路ID
        String initialId = isNewLine ? IdGenerator.generateLineId() : existingLine.getId();
        idField = new EditBox(font, LEFT_COL_X, fieldY, FIELD_WIDTH, FIELD_HEIGHT,
                Component.translatable("gui.line_id"));
        idField.setValue(initialId);
        idField.setEditable(isNewLine); // 新线路可编辑，已有线路ID不可更改
        addRenderableWidget(idField);
        fieldY += FIELD_SPACING;

        // 线路中文名称
        String initialName = isNewLine ? "" : existingLine.getName();
        nameField = new EditBox(font, LEFT_COL_X, fieldY, FIELD_WIDTH, FIELD_HEIGHT,
                Component.translatable("gui.line_name"));
        nameField.setValue(initialName);
        addRenderableWidget(nameField);
        fieldY += FIELD_SPACING;

        // 线路英文名称（可选）
        String initialEnName = isNewLine ? "" : existingLine.getEnName();
        enNameField = new EditBox(font, LEFT_COL_X, fieldY, FIELD_WIDTH, FIELD_HEIGHT,
                Component.translatable("gui.line_en_name"));
        enNameField.setValue(initialEnName);
        addRenderableWidget(enNameField);
        fieldY += FIELD_SPACING;

        // 线路颜色
        String initialColor = isNewLine ? "#3366CC" : existingLine.getColor();
        colorField = new EditBox(font, LEFT_COL_X, fieldY, FIELD_WIDTH, FIELD_HEIGHT,
                Component.translatable("gui.line_color"));
        colorField.setValue(initialColor);
        addRenderableWidget(colorField);
        fieldY += FIELD_SPACING;

        // 加载已有线路的车站列表
        if (!isNewLine) {
            selectedStationCodes = new ArrayList<>(existingLine.getStationCodes());
        }

        // 车站列表（已选择的车站）
        int listY = START_Y;
        stationList = new StationList(this, LEFT_COL_X, listY + 120,
                STATION_LIST_WIDTH, STATION_LIST_HEIGHT);
        addRenderableWidget(stationList);

        // 车站选择器（可用车站）
        stationSelector = new StationSelector(this, RIGHT_COL_X, listY,
                STATION_SELECTOR_WIDTH, STATION_SELECTOR_HEIGHT);
        addRenderableWidget(stationSelector);

        // 按钮位置
        int buttonY = listY + STATION_LIST_HEIGHT + 10;

        // 添加车站按钮
        addStationButton = Button.builder(
                LanguageHelper.translate("gui.add_station_to_line"),
                button -> onAddStation()
        ).bounds(LEFT_COL_X, buttonY, 120, 20).build();
        addRenderableWidget(addStationButton);

        // 移除车站按钮
        removeStationButton = Button.builder(
                LanguageHelper.translate("gui.remove_station_from_line"),
                button -> onRemoveStation()
        ).bounds(LEFT_COL_X + 125, buttonY, 120, 20).build();
        addRenderableWidget(removeStationButton);
        removeStationButton.active = false;

        // 上移按钮
        moveUpButton = Button.builder(
                Component.literal("▲"),
                button -> onMoveStationUp()
        ).bounds(RIGHT_COL_X, buttonY, 40, 20).build();
        addRenderableWidget(moveUpButton);
        moveUpButton.active = false;

        // 下移按钮
        moveDownButton = Button.builder(
                Component.literal("▼"),
                button -> onMoveStationDown()
        ).bounds(RIGHT_COL_X + 45, buttonY, 40, 20).build();
        addRenderableWidget(moveDownButton);
        moveDownButton.active = false;

        // 底部按钮
        int bottomY = height - 40;

        // 保存按钮
        saveButton = Button.builder(
                LanguageHelper.translate("gui.save"),
                button -> onSave()
        ).bounds(width / 2 - 105, bottomY, 100, 20).build();
        addRenderableWidget(saveButton);

        // 取消按钮
        cancelButton = Button.builder(
                LanguageHelper.translate("gui.cancel"),
                button -> onCancel()
        ).bounds(width / 2 + 5, bottomY, 100, 20).build();
        addRenderableWidget(cancelButton);

        // 刷新列表
        refreshStationList();
        refreshStationSelector();
    }

    /**
     * 刷新可用车站列表
     */
    private void refreshAvailableStations() {
        availableStations.clear();
        for (Station station : NetworkManager.getAllStations()) {
            availableStations.add(station);
        }
    }

    /**
     * 刷新车站列表（已选择的车站）
     */
    private void refreshStationList() {
        stationList.refreshStations(selectedStationCodes);
        updateButtonStates();
    }

    /**
     * 刷新车站选择器（可用车站）
     */
    private void refreshStationSelector() {
        stationSelector.refreshStations(availableStations, selectedStationCodes);
    }

    /**
     * 更新按钮状态
     */
    private void updateButtonStates() {
        boolean hasStationSelected = stationList.getSelectedIndex() >= 0;
        removeStationButton.active = hasStationSelected;
        moveUpButton.active = hasStationSelected && stationList.getSelectedIndex() > 0;
        moveDownButton.active = hasStationSelected && stationList.getSelectedIndex() < selectedStationCodes.size() - 1;
    }

    /**
     * 添加车站到线路
     */
    private void onAddStation() {
        String selectedStationCode = stationSelector.getSelectedStationCode();
        if (selectedStationCode != null && !selectedStationCodes.contains(selectedStationCode)) {
            selectedStationCodes.add(selectedStationCode);
            refreshStationList();
            refreshStationSelector();
        }
    }

    /**
     * 从线路移除车站
     */
    private void onRemoveStation() {
        int selectedIndex = stationList.getSelectedIndex();
        if (selectedIndex >= 0) {
            selectedStationCodes.remove(selectedIndex);
            refreshStationList();
            refreshStationSelector();
        }
    }

    /**
     * 上移车站
     */
    private void onMoveStationUp() {
        int selectedIndex = stationList.getSelectedIndex();
        if (selectedIndex > 0) {
            String station = selectedStationCodes.get(selectedIndex);
            selectedStationCodes.remove(selectedIndex);
            selectedStationCodes.add(selectedIndex - 1, station);
            refreshStationList();
            stationList.setSelectedIndex(selectedIndex - 1);
        }
    }

    /**
     * 下移车站
     */
    private void onMoveStationDown() {
        int selectedIndex = stationList.getSelectedIndex();
        if (selectedIndex >= 0 && selectedIndex < selectedStationCodes.size() - 1) {
            String station = selectedStationCodes.get(selectedIndex);
            selectedStationCodes.remove(selectedIndex);
            selectedStationCodes.add(selectedIndex + 1, station);
            refreshStationList();
            stationList.setSelectedIndex(selectedIndex + 1);
        }
    }

    /**
     * 保存线路
     */
    private void onSave() {
        // 验证输入
        String lineId = idField.getValue().trim();
        String lineName = nameField.getValue().trim();
        String lineColor = colorField.getValue().trim();

        if (lineId.isEmpty() || lineName.isEmpty() || lineColor.isEmpty()) {
            Minecraft.getInstance().player.displayClientMessage(
                    LanguageHelper.translate("gui.missing_required_fields"),
                    true);
            return;
        }

        if (selectedStationCodes.size() < 2) {
            Minecraft.getInstance().player.displayClientMessage(
                    LanguageHelper.translate("gui.line_needs_at_least_2_stations"),
                    true);
            return;
        }

        // 创建或更新线路对象
        Line line;
        if (isNewLine) {
            line = new Line(lineId, lineName, lineColor);
        } else {
            line = new Line(lineId, lineName, existingLine.getEnName(), lineColor);
        }

        line.setEnName(enNameField.getValue().trim());
        line.setStationCodes(new ArrayList<>(selectedStationCodes));

        // TODO: 通过网络包发送到服务器处理
        // 临时直接调用LineManager（仅用于测试）
        boolean success;
        if (isNewLine) {
            success = LineManager.addLine(line);
        } else {
            success = LineManager.updateLine(line);
        }

        if (success) {
            Minecraft.getInstance().player.displayClientMessage(
                    LanguageHelper.translate("gui.line_saved", lineName),
                    true);
            Minecraft.getInstance().setScreen(new LineManagementScreen());
        } else {
            Minecraft.getInstance().player.displayClientMessage(
                    LanguageHelper.translate("gui.line_save_failed"),
                    true);
        }
    }

    /**
     * 取消编辑
     */
    private void onCancel() {
        Minecraft.getInstance().setScreen(new LineManagementScreen());
    }

    @Override
    public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
        renderBackground(guiGraphics);

        // 渲染标题
        guiGraphics.drawString(font, title, LEFT_COL_X, 10, 0xFFFFFF);

        // 渲染字段标签
        int labelY = START_Y - 12;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.line_id") + ":", LEFT_COL_X, labelY, 0xCCCCCC);
        labelY += FIELD_SPACING;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.line_name") + ":", LEFT_COL_X, labelY, 0xCCCCCC);
        labelY += FIELD_SPACING;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.line_en_name") + ":", LEFT_COL_X, labelY, 0xCCCCCC);
        labelY += FIELD_SPACING;
        guiGraphics.drawString(font, LanguageHelper.translate("gui.line_color") + ":", LEFT_COL_X, labelY, 0xCCCCCC);

        // 渲染车站列表标签
        guiGraphics.drawString(font, LanguageHelper.translate("gui.selected_stations") + ":",
                LEFT_COL_X, START_Y + 105, 0xCCCCCC);
        guiGraphics.drawString(font, LanguageHelper.translate("gui.available_stations") + ":",
                RIGHT_COL_X, START_Y - 12, 0xCCCCCC);

        super.render(guiGraphics, mouseX, mouseY, partialTicks);
    }

    // ==================== 车站列表组件 ====================

    /**
     * 已选择车站列表组件
     */
    private static class StationList extends AbstractSelectionList<StationList.StationEntry> {
        private final LineEditScreen parent;
        private List<String> stationCodes = new ArrayList<>();
        private int selectedIndex = -1;

        public StationList(LineEditScreen parent, int x, int y, int width, int height) {
            super(Minecraft.getInstance(), width, height, y, y + height, 20);
            this.parent = parent;
            this.setLeftPos(x);
        }

        public void refreshStations(List<String> stationCodes) {
            this.clearEntries();
            this.stationCodes = new ArrayList<>(stationCodes);

            for (int i = 0; i < stationCodes.size(); i++) {
                String stationCode = stationCodes.get(i);
                this.addEntry(new StationEntry(stationCode, i + 1));
            }

            // 保持选中状态
            if (selectedIndex >= 0 && selectedIndex < stationCodes.size()) {
                setSelectedIndex(selectedIndex);
            } else {
                selectedIndex = -1;
            }
        }

        public int getSelectedIndex() {
            return selectedIndex;
        }

        public void setSelectedIndex(int index) {
            selectedIndex = index;
            if (index >= 0 && index < getItemCount()) {
                setSelected(getEntry(index));
            } else {
                setSelected(null);
            }
        }

        @Override
        public void setSelected(@org.jetbrains.annotations.Nullable StationEntry entry) {
            super.setSelected(entry);
            if (entry != null) {
                selectedIndex = entry.index - 1;
            } else {
                selectedIndex = -1;
            }
            parent.updateButtonStates();
        }

        @Override
        public int getRowWidth() {
            return width - 10;
        }

        @Override
        protected int getScrollbarPosition() {
            return this.x0 + this.width - 6;
        }

        @Override
        public void updateNarration(NarrationElementOutput narrationElementOutput) {
            // 无障碍功能支持
        }

        @Override
        public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
            // 绘制背景
            guiGraphics.fill(this.x0, this.y0, this.x0 + this.width, this.y0 + this.height, 0x88000000);
            // 绘制边框
            guiGraphics.renderOutline(this.x0, this.y0, this.width, this.height, 0xFF666666);
            super.render(guiGraphics, mouseX, mouseY, partialTicks);
        }

        /**
         * 车站列表条目
         */
        private class StationEntry extends AbstractSelectionList.Entry<StationEntry> {
            private final String stationCode;
            private final int index;

            public StationEntry(String stationCode, int index) {
                this.stationCode = stationCode;
                this.index = index;
            }

            @Override
            public void render(GuiGraphics guiGraphics, int entryIndex, int top, int left, int width, int height,
                              int mouseX, int mouseY, boolean isMouseOver, float partialTicks) {
                // 背景色
                int backgroundColor = isMouseOver ? 0x44666666 : (entryIndex % 2 == 0 ? 0x44333333 : 0x44222222);
                if (entryIndex == selectedIndex) {
                    backgroundColor = 0x440099FF; // 选中颜色
                }

                guiGraphics.fill(left, top, left + width, top + height, backgroundColor);

                // 车站信息
                Station station = NetworkManager.getStation(stationCode);
                String displayText = index + ". ";
                if (station != null) {
                    displayText += station.getName() + " (" + stationCode + ")";
                } else {
                    displayText += stationCode + " (未找到)";
                }

                guiGraphics.drawString(Minecraft.getInstance().font, displayText,
                        left + 5, top + 6, 0xFFFFFF);
            }

            @Override
            public boolean mouseClicked(double mouseX, double mouseY, int button) {
                if (button == 0) { // 左键点击
                    StationList.this.setSelected(this);
                    return true;
                }
                return false;
            }

            @Override
            public Component getNarration() {
                return Component.literal("车站 " + stationCode);
            }
        }
    }

    // ==================== 车站选择器组件 ====================

    /**
     * 可用车站选择器组件
     */
    private static class StationSelector extends AbstractSelectionList<StationSelector.StationEntry> {
        private final LineEditScreen parent;
        private List<Station> stations = new ArrayList<>();
        private List<String> selectedStationCodes = new ArrayList<>();
        private int selectedIndex = -1;

        public StationSelector(LineEditScreen parent, int x, int y, int width, int height) {
            super(Minecraft.getInstance(), width, height, y, y + height, 20);
            this.parent = parent;
            this.setLeftPos(x);
        }

        public void refreshStations(List<Station> stations, List<String> selectedStationCodes) {
            this.clearEntries();
            this.stations = new ArrayList<>(stations);
            this.selectedStationCodes = new ArrayList<>(selectedStationCodes);

            for (Station station : stations) {
                this.addEntry(new StationEntry(station));
            }

            // 重置选中状态
            selectedIndex = -1;
        }

        public String getSelectedStationCode() {
            if (selectedIndex >= 0 && selectedIndex < stations.size()) {
                return stations.get(selectedIndex).getCode();
            }
            return null;
        }

        @Override
        public void setSelected(@org.jetbrains.annotations.Nullable StationEntry entry) {
            super.setSelected(entry);
            if (entry != null) {
                selectedIndex = stations.indexOf(entry.station);
            } else {
                selectedIndex = -1;
            }
        }

        @Override
        public int getRowWidth() {
            return width - 10;
        }

        @Override
        protected int getScrollbarPosition() {
            return this.x0 + this.width - 6;
        }

        @Override
        public void updateNarration(NarrationElementOutput narrationElementOutput) {
            // 无障碍功能支持
        }

        @Override
        public void render(GuiGraphics guiGraphics, int mouseX, int mouseY, float partialTicks) {
            // 绘制背景
            guiGraphics.fill(this.x0, this.y0, this.x0 + this.width, this.y0 + this.height, 0x88000000);
            // 绘制边框
            guiGraphics.renderOutline(this.x0, this.y0, this.width, this.height, 0xFF666666);
            super.render(guiGraphics, mouseX, mouseY, partialTicks);
        }

        /**
         * 车站选择器条目
         */
        private class StationEntry extends AbstractSelectionList.Entry<StationEntry> {
            private final Station station;

            public StationEntry(Station station) {
                this.station = station;
            }

            @Override
            public void render(GuiGraphics guiGraphics, int entryIndex, int top, int left, int width, int height,
                              int mouseX, int mouseY, boolean isMouseOver, float partialTicks) {
                // 检查是否已选择
                boolean alreadySelected = selectedStationCodes.contains(station.getCode());

                // 背景色
                int backgroundColor;
                if (alreadySelected) {
                    backgroundColor = 0x44444444; // 已选择，灰色
                } else if (isMouseOver) {
                    backgroundColor = 0x44666666; // 鼠标悬停
                } else {
                    backgroundColor = entryIndex % 2 == 0 ? 0x44333333 : 0x44222222;
                }

                if (entryIndex == selectedIndex) {
                    backgroundColor = 0x440099FF; // 选中颜色
                }

                guiGraphics.fill(left, top, left + width, top + height, backgroundColor);

                // 车站信息
                String displayText = station.getName() + " (" + station.getCode() + ")";
                int textColor = alreadySelected ? 0x888888 : 0xFFFFFF;

                guiGraphics.drawString(Minecraft.getInstance().font, displayText,
                        left + 5, top + 6, textColor);

                // 如果已选择，显示提示
                if (alreadySelected) {
                    guiGraphics.drawString(Minecraft.getInstance().font, "已选择",
                            left + width - 45, top + 6, 0x888888);
                }
            }

            @Override
            public boolean mouseClicked(double mouseX, double mouseY, int button) {
                if (button == 0) { // 左键点击
                    StationSelector.this.setSelected(this);
                    return true;
                }
                return false;
            }

            @Override
            public Component getNarration() {
                return Component.literal("车站 " + station.getName());
            }
        }
    }
}package com.easttown.ticketsystem.util;

import net.minecraft.nbt.CompoundTag;

import java.util.UUID;

public class GateUtil {
    public static UUID getTicketId(CompoundTag ticketTag) {
        if (ticketTag.contains("TicketId")) {
            return UUID.fromString(ticketTag.getString("TicketId"));
        }
        return null;
    }
}
package com.easttown.ticketsystem.util;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.config.TicketSystemConfig;

public class DebugLogger {

    public static void info(String message, Object... params) {
        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info(message, params);
        }
    }

    public static void debug(String message, Object... params) {
        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.debug(message, params);
        }
    }

    public static void warn(String message, Object... params) {
        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.warn(message, params);
        }
    }

    public static void error(String message, Object... params) {
        // 错误日志总是显示，不受配置影响
        TicketSystemMod.LOGGER.error(message, params);
    }

    public static void error(String message, Throwable throwable) {
        // 错误日志总是显示，不受配置影响
        TicketSystemMod.LOGGER.error(message, throwable);
    }
}package com.easttown.ticketsystem.util;

import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;

public class LanguageHelper {
    public static MutableComponent translate(String key) {
        return Component.translatable("ticketsystem." + key);
    }
    
    public static MutableComponent translate(String key, Object... args) {
        return Component.translatable("ticketsystem." + key, args);
    }
}
package com.easttown.ticketsystem.util;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.config.TicketSystemConfig;
import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class TicketSystemLogger {

    private static final String LOG_FILE_PATH = "logs/ticketsystem.log";
    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    // 日志级别
    public enum LogLevel {
        INFO,
        WARN,
        ERROR
    }

    // 日志类型
    public enum LogType {
        TICKET_PURCHASE("Ticket Purchase", "购买车票"),
        GATE_PASSAGE("Gate Passage", "通过闸机"),
        REFUND("Refund", "退票"),
        SYSTEM("System", "系统"),
        COIN("Coin", "硬币"),
        ADMIN("Admin", "管理");

        private final String englishName;
        private final String chineseName;

        LogType(String englishName, String chineseName) {
            this.englishName = englishName;
            this.chineseName = chineseName;
        }

        public String getEnglishName() {
            return englishName;
        }

        public String getChineseName() {
            return chineseName;
        }
    }

    /**
     * 记录购买车票日志
     */
    public static void logTicketPurchase(Player player, String startStation, String destination, int price,
                                        String ticketId, String paymentMethod) {
        String message = String.format(
            "[Ticket Purchase] Player: %s, Start: %s, Destination: %s, Price: %d, Ticket ID: %s, Payment: %s | " +
            "[购买车票] 玩家: %s, 起点: %s, 终点: %s, 价格: %d, 车票ID: %s, 支付方式: %s",
            player.getName().getString(), startStation, destination, price, ticketId, paymentMethod,
            player.getName().getString(), startStation, destination, price, ticketId, paymentMethod
        );
        logToFile(LogType.TICKET_PURCHASE, LogLevel.INFO, message);

        // 同时输出到控制台（如果启用了调试日志）
        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info("[Ticket Purchase] Player: {}, Start: {}, Destination: {}, Price: {}, Ticket ID: {}, Payment: {}",
                player.getName().getString(), startStation, destination, price, ticketId, paymentMethod);
        }
    }

    /**
     * 记录通过闸机日志
     */
    public static void logGatePassage(Player player, String station, String ticketId, boolean success,
                                     String reason, String gateType) {
        String status = success ? "SUCCESS" : "FAILED";
        String statusCn = success ? "成功" : "失败";

        String message = String.format(
            "[Gate Passage] Player: %s, Station: %s, Ticket ID: %s, Status: %s, Reason: %s, Gate Type: %s | " +
            "[通过闸机] 玩家: %s, 站点: %s, 车票ID: %s, 状态: %s, 原因: %s, 闸机类型: %s",
            player.getName().getString(), station, ticketId, status, reason, gateType,
            player.getName().getString(), station, ticketId, statusCn, reason, gateType
        );
        logToFile(LogType.GATE_PASSAGE, LogLevel.INFO, message);

        // 同时输出到控制台（如果启用了调试日志）
        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info("[Gate Passage] Player: {}, Station: {}, Ticket ID: {}, Status: {}, Reason: {}, Gate Type: {}",
                player.getName().getString(), station, ticketId, status, reason, gateType);
        }
    }

    /**
     * 记录退票日志
     */
    public static void logRefund(Player player, String ticketId, int originalPrice, int refundAmount,
                                String refundReason) {
        String message = String.format(
            "[Refund] Player: %s, Ticket ID: %s, Original Price: %d, Refund Amount: %d, Reason: %s | " +
            "[退票] 玩家: %s, 车票ID: %s, 原价: %d, 退款金额: %d, 原因: %s",
            player.getName().getString(), ticketId, originalPrice, refundAmount, refundReason,
            player.getName().getString(), ticketId, originalPrice, refundAmount, refundReason
        );
        logToFile(LogType.REFUND, LogLevel.INFO, message);

        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info("[Refund] Player: {}, Ticket ID: {}, Original Price: {}, Refund Amount: {}, Reason: {}",
                player.getName().getString(), ticketId, originalPrice, refundAmount, refundReason);
        }
    }

    /**
     * 记录硬币操作日志
     */
    public static void logCoinOperation(Player player, String operation, int amount, String coinType,
                                      String details) {
        String message = String.format(
            "[Coin Operation] Player: %s, Operation: %s, Amount: %d, Coin Type: %s, Details: %s | " +
            "[硬币操作] 玩家: %s, 操作: %s, 金额: %d, 硬币类型: %s, 详情: %s",
            player.getName().getString(), operation, amount, coinType, details,
            player.getName().getString(), operation, amount, coinType, details
        );
        logToFile(LogType.COIN, LogLevel.INFO, message);

        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info("[Coin Operation] Player: {}, Operation: {}, Amount: {}, Coin Type: {}, Details: {}",
                player.getName().getString(), operation, amount, coinType, details);
        }
    }

    /**
     * 记录管理员操作日志
     */
    public static void logAdminOperation(Player admin, String operation, String target, String details) {
        String message = String.format(
            "[Admin Operation] Admin: %s, Operation: %s, Target: %s, Details: %s | " +
            "[管理员操作] 管理员: %s, 操作: %s, 目标: %s, 详情: %s",
            admin.getName().getString(), operation, target, details,
            admin.getName().getString(), operation, target, details
        );
        logToFile(LogType.ADMIN, LogLevel.INFO, message);

        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info("[Admin Operation] Admin: {}, Operation: {}, Target: {}, Details: {}",
                admin.getName().getString(), operation, target, details);
        }
    }

    /**
     * 记录系统日志
     */
    public static void logSystem(String component, String action, String details) {
        String message = String.format(
            "[System] Component: %s, Action: %s, Details: %s | " +
            "[系统] 组件: %s, 操作: %s, 详情: %s",
            component, action, details,
            component, action, details
        );
        logToFile(LogType.SYSTEM, LogLevel.INFO, message);

        if (TicketSystemConfig.showDebugLogs()) {
            TicketSystemMod.LOGGER.info("[System] Component: {}, Action: {}, Details: {}",
                component, action, details);
        }
    }

    /**
     * 记录警告日志
     */
    public static void logWarning(LogType type, String message) {
        String fullMessage = String.format(
            "[%s] WARNING: %s | " +
            "[%s] 警告: %s",
            type.getEnglishName(), message,
            type.getChineseName(), message
        );
        logToFile(type, LogLevel.WARN, fullMessage);

        TicketSystemMod.LOGGER.warn("[{}] {}", type.getEnglishName(), message);
    }

    /**
     * 记录错误日志
     */
    public static void logError(LogType type, String message, Throwable throwable) {
        String fullMessage = String.format(
            "[%s] ERROR: %s | " +
            "[%s] 错误: %s",
            type.getEnglishName(), message,
            type.getChineseName(), message
        );
        logToFile(type, LogLevel.ERROR, fullMessage);

        TicketSystemMod.LOGGER.error("[{}] {}", type.getEnglishName(), message, throwable);
    }

    /**
     * 记录错误日志（无异常）
     */
    public static void logError(LogType type, String message) {
        String fullMessage = String.format(
            "[%s] ERROR: %s | " +
            "[%s] 错误: %s",
            type.getEnglishName(), message,
            type.getChineseName(), message
        );
        logToFile(type, LogLevel.ERROR, fullMessage);

        TicketSystemMod.LOGGER.error("[{}] {}", type.getEnglishName(), message);
    }

    /**
     * 将日志写入文件
     */
    private static synchronized void logToFile(LogType type, LogLevel level, String message) {
        try {
            File logFile = new File(LOG_FILE_PATH);
            File parentDir = logFile.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                parentDir.mkdirs();
            }

            try (PrintWriter writer = new PrintWriter(new FileWriter(logFile, true))) {
                String timestamp = DATE_FORMAT.format(new Date());
                String logEntry = String.format("[%s] [%s] [%s] %s",
                    timestamp, level.name(), type.getEnglishName(), message);
                writer.println(logEntry);
            }
        } catch (IOException e) {
            // 如果文件写入失败，只输出到控制台
            TicketSystemMod.LOGGER.error("Failed to write to ticket system log file: {}", e.getMessage());
        }
    }

    /**
     * 初始化日志系统
     */
    public static void initialize() {
        try {
            File logFile = new File(LOG_FILE_PATH);
            File parentDir = logFile.getParentFile();
            if (parentDir != null && !parentDir.exists()) {
                parentDir.mkdirs();
            }

            // 写入初始化信息
            String timestamp = DATE_FORMAT.format(new Date());
            String initMessage = String.format(
                "[%s] [INFO] [System] Ticket System Logger initialized | " +
                "[%s] [INFO] [系统] 车票系统日志记录器已初始化",
                timestamp, timestamp
            );

            try (PrintWriter writer = new PrintWriter(new FileWriter(logFile, true))) {
                writer.println("=" .repeat(80));
                writer.println(initMessage);
                writer.println("=" .repeat(80));
            }

            TicketSystemMod.LOGGER.info("Ticket System Logger initialized successfully");
        } catch (IOException e) {
            TicketSystemMod.LOGGER.error("Failed to initialize ticket system log file: {}", e.getMessage());
        }
    }
}package com.easttown.ticketsystem.util;

import net.minecraft.world.entity.player.Player;
import net.minecraft.world.item.ItemStack;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.effect.MobEffectInstance;
import net.minecraft.world.effect.MobEffects;
import net.minecraft.sounds.SoundEvents;
import net.minecraft.sounds.SoundSource;

public class EasterEggHandler {

    public static boolean checkForEasterEgg(String message, Player player) {
        // 直接检查消息内容
        if (message.equals("Colo9875 is 0!")) {
            triggerEasterEgg(player);
            return true;
        }

        return false;
    }

    private static void triggerEasterEgg(Player player) {
        if (player instanceof ServerPlayer serverPlayer) {
            // 给予铜币奖励 - 使用ItemInit中的注册对象
            ItemStack copperCoin = new ItemStack(
                com.easttown.ticketsystem.init.ItemInit.COPPER_COIN.get()
            );

            if (!player.getInventory().add(copperCoin)) {
                player.drop(copperCoin, false);
            }

            // 给予生命恢复效果
            serverPlayer.addEffect(new MobEffectInstance(
                MobEffects.REGENERATION,
                300, // 15秒 * 20 ticks/秒 = 300 ticks
                1
            ));

            // 播放音效
            serverPlayer.level().playSound(
                null,
                serverPlayer.getX(),
                serverPlayer.getY(),
                serverPlayer.getZ(),
                SoundEvents.PLAYER_LEVELUP,
                SoundSource.PLAYERS,
                1.0f,
                1.0f
            );
        }
    }
}package com.easttown.ticketsystem.util;

import java.security.SecureRandom;
import java.util.HashSet;
import java.util.Set;

/**
 * ID生成器 - 生成由26个小写字母和数字组合的唯一值
 * 用于生成线路ID、车站编码等唯一标识符
 */
public class IdGenerator {
    // 字符集：26个小写字母 + 10个数字 = 36个字符
    private static final char[] CHARSET = "abcdefghijklmnopqrstuvwxyz0123456789".toCharArray();
    private static final int CHARSET_SIZE = CHARSET.length;

    // 随机数生成器
    private static final SecureRandom random = new SecureRandom();

    // 已生成的ID缓存（避免冲突）
    private static final Set<String> generatedIds = new HashSet<>();

    /**
     * 生成指定长度的随机ID
     * @param length ID长度
     * @return 唯一的随机ID
     */
    public static String generateRandomId(int length) {
        if (length <= 0) {
            length = 8; // 默认长度
        }

        String id;
        int attempts = 0;
        final int MAX_ATTEMPTS = 100;

        do {
            // 生成随机ID
            StringBuilder sb = new StringBuilder(length);
            for (int i = 0; i < length; i++) {
                int index = random.nextInt(CHARSET_SIZE);
                sb.append(CHARSET[index]);
            }
            id = sb.toString();

            attempts++;
            if (attempts >= MAX_ATTEMPTS) {
                // 增加时间戳以避免无限循环
                id = id + System.currentTimeMillis() % 10000;
                break;
            }

        } while (generatedIds.contains(id));

        generatedIds.add(id);
        return id;
    }

    /**
     * 生成线路ID（默认长度8）
     */
    public static String generateLineId() {
        return "l_" + generateRandomId(6); // 如 "l_a1b2c3"
    }

    /**
     * 生成车站编码（默认长度8）
     */
    public static String generateStationCode() {
        return "s_" + generateRandomId(6); // 如 "s_x9y8z7"
    }

    /**
     * 生成短ID（用于显示）
     */
    public static String generateShortId() {
        return generateRandomId(4); // 如 "a1b2"
    }

    /**
     * 生成带有前缀的ID
     */
    public static String generatePrefixedId(String prefix, int randomLength) {
        return prefix + "_" + generateRandomId(randomLength);
    }

    /**
     * 基于时间戳生成ID（确保唯一性）
     */
    public static String generateTimestampId() {
        long timestamp = System.currentTimeMillis();
        // 转换为36进制（使用小写字母和数字）
        String base36 = Long.toString(timestamp, 36);

        // 确保只包含小写字母和数字
        base36 = base36.toLowerCase();

        // 添加随机后缀避免冲突
        String randomSuffix = generateRandomId(2);
        return base36 + randomSuffix;
    }

    /**
     * 验证ID是否符合格式（只包含小写字母和数字）
     */
    public static boolean isValidId(String id) {
        if (id == null || id.isEmpty()) {
            return false;
        }

        for (char c : id.toCharArray()) {
            if (!((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')) {
                return false;
            }
        }

        return true;
    }

    /**
     * 规范化ID（转换为小写，移除非法字符）
     */
    public static String normalizeId(String id) {
        if (id == null) {
            return generateRandomId(8);
        }

        // 转换为小写
        id = id.toLowerCase();

        // 移除非法字符，用下划线替换
        StringBuilder sb = new StringBuilder();
        for (char c : id.toCharArray()) {
            if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_') {
                sb.append(c);
            } else {
                sb.append('_');
            }
        }

        String normalized = sb.toString();

        // 如果结果为空，生成随机ID
        if (normalized.isEmpty() || normalized.equals("_")) {
            return generateRandomId(8);
        }

        return normalized;
    }

    /**
     * 生成人类可读的ID（字母开头，避免纯数字）
     */
    public static String generateHumanReadableId() {
        // 确保以字母开头
        char firstChar = CHARSET[random.nextInt(26)]; // 0-25是小写字母
        String rest = generateRandomId(5); // 剩余部分

        return firstChar + rest;
    }

    /**
     * 清除已生成的ID缓存
     */
    public static void clearCache() {
        generatedIds.clear();
    }

    /**
     * 注册已存在的ID（避免生成重复ID）
     */
    public static void registerExistingId(String id) {
        if (id != null && !id.isEmpty()) {
            generatedIds.add(id);
        }
    }

    /**
     * 批量注册已存在的ID
     */
    public static void registerExistingIds(Iterable<String> ids) {
        for (String id : ids) {
            registerExistingId(id);
        }
    }

    /**
     * 检查ID是否已存在
     */
    public static boolean idExists(String id) {
        return generatedIds.contains(id);
    }

    /**
     * 获取ID生成统计
     */
    public static String getStats() {
        return String.format("已生成ID数量: %d, 字符集大小: %d",
                generatedIds.size(), CHARSET_SIZE);
    }
}package com.easttown.ticketsystem;

import com.easttown.ticketsystem.command.TicketCommand;
import com.easttown.ticketsystem.config.TicketSystemConfig;
import com.easttown.ticketsystem.init.*;
import com.easttown.ticketsystem.network.NetworkHandler;
import com.easttown.ticketsystem.util.EasterEggHandler;
import com.easttown.ticketsystem.web.WebServer;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.RegisterCommandsEvent;
import net.minecraftforge.event.ServerChatEvent;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import net.minecraftforge.fml.ModLoadingContext;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.config.ModConfig;
import net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;
import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;

@Mod(TicketSystemMod.MODID)
public class TicketSystemMod {
    public static final String MODID = "ticketsystem";
    public static final Logger LOGGER = LogManager.getLogger();
    
    public TicketSystemMod() {
        // 使用新的API获取上下文
        IEventBus modEventBus = FMLJavaModLoadingContext.get().getModEventBus();
        ModLoadingContext modContext = ModLoadingContext.get();

        modContext.registerConfig(
            ModConfig.Type.COMMON,
            TicketSystemConfig.SPEC,
            "ticketsystem-common.toml"
        );

        BlockInit.BLOCKS.register(modEventBus);
        ItemInit.ITEMS.register(modEventBus);
        BlockEntityInit.BLOCK_ENTITIES.register(modEventBus);
        MenuInit.MENUS.register(modEventBus);
        TicketSystemTab.register(modEventBus);

        modEventBus.addListener(this::onCommonSetup);

        MinecraftForge.EVENT_BUS.register(this);

        new File("mods/" + MODID).mkdirs();

        // 初始化日志系统
        com.easttown.ticketsystem.util.TicketSystemLogger.initialize();

        LOGGER.info("TicketSystem Mod initialized");
    }
    
    private void onCommonSetup(final FMLCommonSetupEvent event) {
        event.enqueueWork(() -> {
            NetworkHandler.register();

            // 启动Web服务器（仅在服务器端）
            try {
                WebServer.start();
                LOGGER.info("Web server started on port {}", WebServer.getPort());
            } catch (Exception e) {
                LOGGER.error("Failed to start web server", e);
            }
        });
    }
    
    @SubscribeEvent
    public void onCommandRegister(RegisterCommandsEvent event) {
        TicketCommand.register(event.getDispatcher());
        LOGGER.info("Registered commands");
    }

    @SubscribeEvent
    public void onServerChat(ServerChatEvent event) {
        String message = event.getRawText();
        LOGGER.info("收到聊天消息: " + message);
        if (EasterEggHandler.checkForEasterEgg(message, event.getPlayer())) {
            LOGGER.info("彩蛋已触发!");
        }
    }
}
// TicketSystemTab.java
package com.easttown.ticketsystem;

import com.easttown.ticketsystem.init.ItemInit;
import net.minecraft.core.registries.Registries;
import net.minecraft.network.chat.Component;
import net.minecraft.world.item.CreativeModeTab;
import net.minecraft.world.item.ItemStack;
import net.minecraftforge.eventbus.api.IEventBus;
import net.minecraftforge.registries.DeferredRegister;
import net.minecraftforge.registries.RegistryObject;

public class TicketSystemTab {
    private static final DeferredRegister<CreativeModeTab> TABS = DeferredRegister.create(Registries.CREATIVE_MODE_TAB,
            TicketSystemMod.MODID);

    public static final RegistryObject<CreativeModeTab> TICKET_TAB = TABS.register("ticket_tab",
            () -> CreativeModeTab.builder()
                    .title(Component.translatable("itemGroup.ticketsystem"))
                    .icon(() -> new ItemStack(ItemInit.TICKET.get()))
                    .displayItems((params, output) -> {
                        output.accept(ItemInit.TICKET_MACHINE_ITEM.get());
                        output.accept(ItemInit.TICKET.get());
                        output.accept(ItemInit.ADMIN_KEY.get());
                        output.accept(ItemInit.COPPER_COIN.get());
                        output.accept(ItemInit.IRON_COIN.get());
                        output.accept(ItemInit.DIAMOND_COIN.get());
                        output.accept(ItemInit.GOLD_COIN.get());
                        output.accept(ItemInit.NETHERITE_COIN.get());
                        output.accept(ItemInit.EMERALD_COIN.get());
                        output.accept(ItemInit.GATE_ITEM.get());
                        output.accept(ItemInit.ITEM9875IS0.get());
                        output.accept(ItemInit.REISSUE_MACHINE_ITEM.get());
                        output.accept(ItemInit.REIMBURSEMENT_VOUCHER.get());
                        output.accept(ItemInit.CUSTOM_CAKE_ITEM.get());
                    })
                    .build());

    public static void register(IEventBus eventBus) {
        TABS.register(eventBus);
    }
}package com.easttown.ticketsystem.web;

import com.easttown.ticketsystem.TicketSystemMod;
import com.easttown.ticketsystem.config.TicketSystemConfig;
import com.easttown.ticketsystem.manager.NetworkManager;
import com.easttown.ticketsystem.data.Station;
import com.easttown.ticketsystem.data.Line;
import com.easttown.ticketsystem.data.Fare;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpExchange;

import java.io.*;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.Executors;

/**
 * Web服务器 - 提供类似web项目的API接口
 * 在配置的端口上运行HTTP服务器，提供车站/线路/票价数据管理
 */
public class WebServer {
    private static HttpServer server;
    private static int port;
    private static boolean running = false;

    // Gson实例（线程安全）
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    // 数据目录（与NetworkManager一致）
    private static final String DATA_BASE_PATH = "mods/" + TicketSystemMod.MODID + "/";

    /**
     * 启动Web服务器
     */
    public static void start() {
        if (running) {
            TicketSystemMod.LOGGER.warn("Web server is already running");
            return;
        }

        port = TicketSystemConfig.getWebServerPort();

        try {
            // 创建服务器，绑定端口，设置并发处理
            server = HttpServer.create(new InetSocketAddress("0.0.0.0", port), 0);
            server.setExecutor(Executors.newCachedThreadPool());

            // 注册API路由
            registerRoutes();

            server.start();
            running = true;

            TicketSystemMod.LOGGER.info("Web server started on port {}", port);
            TicketSystemMod.LOGGER.info("Access URL: http://localhost:{}/", port);

        } catch (IOException e) {
            TicketSystemMod.LOGGER.error("Failed to start web server on port {}", port, e);
        }
    }

    /**
     * 停止Web服务器
     */
    public static void stop() {
        if (server != null) {
            server.stop(0);
            running = false;
            TicketSystemMod.LOGGER.info("Web server stopped");
        }
    }

    /**
     * 检查服务器是否在运行
     */
    public static boolean isRunning() {
        return running;
    }

    /**
     * 获取服务器端口
     */
    public static int getPort() {
        return port;
    }

    /**
     * 注册API路由
     */
    private static void registerRoutes() {
        // 静态文件服务（HTML、CSS、JS）
        server.createContext("/", new StaticFileHandler());

        // API根路径
        server.createContext("/api", new ApiHandler());

        // 具体API端点
        server.createContext("/api/stations", new StationsHandler());
        server.createContext("/api/lines", new LinesHandler());
        server.createContext("/api/fares", new FaresHandler());
        server.createContext("/api/config", new ConfigHandler());
        server.createContext("/api/export", new ExportHandler());
        server.createContext("/api/health", new HealthHandler());

        // 更多端点可以按需添加
    }

    // ==================== 请求处理工具方法 ====================

    private static void sendJsonResponse(HttpExchange exchange, int statusCode, Object data) throws IOException {
        String json = GSON.toJson(data);
        byte[] bytes = json.getBytes(StandardCharsets.UTF_8);

        exchange.getResponseHeaders().set("Content-Type", "application/json; charset=UTF-8");
        exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
        exchange.sendResponseHeaders(statusCode, bytes.length);

        try (OutputStream os = exchange.getResponseBody()) {
            os.write(bytes);
        }
    }

    private static void sendTextResponse(HttpExchange exchange, int statusCode, String text) throws IOException {
        byte[] bytes = text.getBytes(StandardCharsets.UTF_8);

        exchange.getResponseHeaders().set("Content-Type", "text/plain; charset=UTF-8");
        exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
        exchange.sendResponseHeaders(statusCode, bytes.length);

        try (OutputStream os = exchange.getResponseBody()) {
            os.write(bytes);
        }
    }

    private static void sendError(HttpExchange exchange, int statusCode, String message) throws IOException {
        Map<String, Object> error = new HashMap<>();
        error.put("ok", false);
        error.put("error", message);
        sendJsonResponse(exchange, statusCode, error);
    }

    private static Map<String, Object> parseRequestBody(HttpExchange exchange) throws IOException {
        try (InputStream is = exchange.getRequestBody();
             BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {

            StringBuilder body = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                body.append(line);
            }

            if (body.length() == 0) {
                return new HashMap<>();
            }

            return GSON.fromJson(body.toString(), new TypeToken<Map<String, Object>>() {}.getType());
        }
    }

    // ==================== 静态文件处理器 ====================

    private static class StaticFileHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            String path = exchange.getRequestURI().getPath();

            // 默认返回index.html
            if (path.equals("/") || path.equals("")) {
                path = "/index.html";
            }

            // 从资源文件夹读取文件
            String resourcePath = "assets/ticketsystem/html" + path;
            InputStream is = getClass().getClassLoader().getResourceAsStream(resourcePath);

            if (is == null) {
                // 文件未找到
                sendError(exchange, 404, "File not found: " + path);
                return;
            }

            // 根据文件扩展名设置Content-Type
            String contentType = "text/html";
            if (path.endsWith(".css")) {
                contentType = "text/css";
            } else if (path.endsWith(".js")) {
                contentType = "application/javascript";
            } else if (path.endsWith(".png")) {
                contentType = "image/png";
            } else if (path.endsWith(".jpg") || path.endsWith(".jpeg")) {
                contentType = "image/jpeg";
            }

            // 读取文件内容
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = is.read(buffer)) != -1) {
                baos.write(buffer, 0, bytesRead);
            }
            byte[] data = baos.toByteArray();

            // 发送响应
            exchange.getResponseHeaders().set("Content-Type", contentType);
            exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
            exchange.sendResponseHeaders(200, data.length);

            try (OutputStream os = exchange.getResponseBody()) {
                os.write(data);
            }
        }
    }

    // ==================== API处理器 ====================

    private static class ApiHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            Map<String, Object> info = new HashMap<>();
            info.put("ok", true);
            info.put("service", "FTC Ticketing System API");
            info.put("version", "1.0");
            info.put("endpoints", Arrays.asList(
                "/api/stations",
                "/api/lines",
                "/api/fares",
                "/api/config",
                "/api/export",
                "/api/health"
            ));

            sendJsonResponse(exchange, 200, info);
        }
    }

    private static class StationsHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            try {
                NetworkManager.initialize();

                switch (exchange.getRequestMethod().toUpperCase()) {
                    case "GET":
                        handleGetStations(exchange);
                        break;
                    case "POST":
                        handlePostStation(exchange);
                        break;
                    case "PUT":
                        handlePutStation(exchange);
                        break;
                    case "DELETE":
                        handleDeleteStation(exchange);
                        break;
                    default:
                        sendError(exchange, 405, "Method not allowed");
                }
            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Error in stations handler", e);
                sendError(exchange, 500, "Internal server error: " + e.getMessage());
            }
        }

        private void handleGetStations(HttpExchange exchange) throws IOException {
            Collection<Station> stations = NetworkManager.getAllStations();

            // 转换为web格式
            List<Map<String, Object>> stationList = new ArrayList<>();
            for (Station station : stations) {
                Map<String, Object> stationData = new HashMap<>();
                stationData.put("code", station.getCode());
                stationData.put("name", station.getName());
                stationData.put("en_name", station.getEnName());
                // 坐标可选返回
                if (station.getX() != 0 || station.getY() != 0 || station.getZ() != 0) {
                    stationData.put("x", station.getX());
                    stationData.put("y", station.getY());
                    stationData.put("z", station.getZ());
                }
                stationList.add(stationData);
            }

            sendJsonResponse(exchange, 200, stationList);
        }

        private void handlePostStation(HttpExchange exchange) throws IOException {
            Map<String, Object> body = parseRequestBody(exchange);

            String code = (String) body.get("code");
            String name = (String) body.get("name");
            String enName = (String) body.getOrDefault("en_name", "");

            if (code == null || code.isEmpty() || name == null || name.isEmpty()) {
                sendError(exchange, 400, "Missing required fields: code, name");
                return;
            }

            // 创建车站（坐标可选）
            int x = ((Number) body.getOrDefault("x", 0)).intValue();
            int y = ((Number) body.getOrDefault("y", 0)).intValue();
            int z = ((Number) body.getOrDefault("z", 0)).intValue();

            Station station = new Station(code, name, enName, x, y, z);
            boolean success = NetworkManager.addStation(station);

            if (success) {
                Map<String, Object> response = new HashMap<>();
                response.put("ok", true);
                response.put("message", "Station added successfully");
                sendJsonResponse(exchange, 201, response);
            } else {
                sendError(exchange, 400, "Failed to add station (may already exist)");
            }
        }

        private void handlePutStation(HttpExchange exchange) throws IOException {
            // 从路径提取车站编码
            String path = exchange.getRequestURI().getPath();
            String[] parts = path.split("/");
            if (parts.length < 4) {
                sendError(exchange, 400, "Missing station code");
                return;
            }

            String stationCode = parts[3];
            Map<String, Object> body = parseRequestBody(exchange);

            // 获取现有车站
            Station existingStation = NetworkManager.getStation(stationCode);
            if (existingStation == null) {
                sendError(exchange, 404, "Station not found");
                return;
            }

            // 更新字段
            String name = (String) body.get("name");
            String enName = (String) body.get("en_name");
            Integer x = body.containsKey("x") ? ((Number) body.get("x")).intValue() : null;
            Integer y = body.containsKey("y") ? ((Number) body.get("y")).intValue() : null;
            Integer z = body.containsKey("z") ? ((Number) body.get("z")).intValue() : null;

            if (name != null && !name.isEmpty()) {
                existingStation.setName(name);
            }
            if (enName != null) {
                existingStation.setEnName(enName);
            }
            if (x != null) {
                existingStation.setX(x);
            }
            if (y != null) {
                existingStation.setY(y);
            }
            if (z != null) {
                existingStation.setZ(z);
            }

            // 更新车站（先删除再添加，简化实现）
            NetworkManager.removeStation(stationCode);
            boolean success = NetworkManager.addStation(existingStation);

            if (success) {
                Map<String, Object> response = new HashMap<>();
                response.put("ok", true);
                response.put("message", "Station updated successfully");
                sendJsonResponse(exchange, 200, response);
            } else {
                sendError(exchange, 500, "Failed to update station");
            }
        }

        private void handleDeleteStation(HttpExchange exchange) throws IOException {
            String path = exchange.getRequestURI().getPath();
            String[] parts = path.split("/");
            if (parts.length < 4) {
                sendError(exchange, 400, "Missing station code");
                return;
            }

            String stationCode = parts[3];
            boolean success = NetworkManager.removeStation(stationCode);

            if (success) {
                Map<String, Object> response = new HashMap<>();
                response.put("ok", true);
                response.put("message", "Station deleted successfully");
                sendJsonResponse(exchange, 200, response);
            } else {
                sendError(exchange, 404, "Station not found");
            }
        }
    }

    private static class LinesHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            try {
                NetworkManager.initialize();

                String path = exchange.getRequestURI().getPath();
                String[] parts = path.split("/");

                // 判断是操作集合还是单个线路
                // /api/lines 或 /api/lines/{id}
                boolean isSingleLine = parts.length >= 4 && !parts[3].isEmpty();
                String lineId = isSingleLine ? parts[3] : null;

                switch (exchange.getRequestMethod().toUpperCase()) {
                    case "GET":
                        if (isSingleLine) {
                            handleGetLine(exchange, lineId);
                        } else {
                            handleGetLines(exchange);
                        }
                        break;
                    case "POST":
                        if (isSingleLine) {
                            sendError(exchange, 405, "Method not allowed for single line");
                        } else {
                            handlePostLine(exchange);
                        }
                        break;
                    case "PUT":
                        if (isSingleLine) {
                            handlePutLine(exchange, lineId);
                        } else {
                            sendError(exchange, 405, "Method not allowed for line collection");
                        }
                        break;
                    case "DELETE":
                        if (isSingleLine) {
                            handleDeleteLine(exchange, lineId);
                        } else {
                            sendError(exchange, 405, "Method not allowed for line collection");
                        }
                        break;
                    default:
                        sendError(exchange, 405, "Method not allowed");
                }
            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Error in lines handler", e);
                sendError(exchange, 500, "Internal server error: " + e.getMessage());
            }
        }

        private void handleGetLines(HttpExchange exchange) throws IOException {
            Collection<Line> lines = NetworkManager.getAllLines();

            List<Map<String, Object>> lineList = new ArrayList<>();
            for (Line line : lines) {
                Map<String, Object> lineData = new HashMap<>();
                lineData.put("id", line.getId());
                lineData.put("name", line.getName());
                lineData.put("en_name", line.getEnName());
                lineData.put("color", line.getColor());
                lineData.put("stations", line.getStationCodes());
                lineList.add(lineData);
            }

            sendJsonResponse(exchange, 200, lineList);
        }

        private void handleGetLine(HttpExchange exchange, String lineId) throws IOException {
            Line line = NetworkManager.getLine(lineId);
            if (line == null) {
                sendError(exchange, 404, "Line not found");
                return;
            }

            Map<String, Object> lineData = new HashMap<>();
            lineData.put("id", line.getId());
            lineData.put("name", line.getName());
            lineData.put("en_name", line.getEnName());
            lineData.put("color", line.getColor());
            lineData.put("stations", line.getStationCodes());

            sendJsonResponse(exchange, 200, lineData);
        }

        private void handlePostLine(HttpExchange exchange) throws IOException {
            Map<String, Object> body = parseRequestBody(exchange);

            String id = (String) body.get("id");
            String name = (String) body.get("name");
            String color = (String) body.getOrDefault("color", "#3366CC");

            // stations字段可能是车站编码列表
            List<String> stationCodes = new ArrayList<>();
            Object stationsObj = body.get("stations");
            if (stationsObj instanceof List) {
                for (Object item : (List<?>) stationsObj) {
                    if (item instanceof String) {
                        stationCodes.add((String) item);
                    }
                }
            }

            if (id == null || id.isEmpty() || name == null || name.isEmpty()) {
                sendError(exchange, 400, "Missing required fields: id, name");
                return;
            }

            Line line = new Line(id, name, color);
            if (!stationCodes.isEmpty()) {
                line.setStationCodes(stationCodes);
            }

            boolean success = NetworkManager.addLine(line);
            if (success) {
                Map<String, Object> response = new HashMap<>();
                response.put("ok", true);
                response.put("message", "Line added successfully");
                sendJsonResponse(exchange, 201, response);
            } else {
                sendError(exchange, 400, "Failed to add line (may already exist)");
            }
        }

        private void handlePutLine(HttpExchange exchange, String lineId) throws IOException {
            Map<String, Object> body = parseRequestBody(exchange);

            Line existingLine = NetworkManager.getLine(lineId);
            if (existingLine == null) {
                sendError(exchange, 404, "Line not found");
                return;
            }

            // 更新字段
            String name = (String) body.get("name");
            String color = (String) body.get("color");

            // stations字段可能是车站编码列表
            List<String> stationCodes = new ArrayList<>();
            Object stationsObj = body.get("stations");
            if (stationsObj instanceof List) {
                for (Object item : (List<?>) stationsObj) {
                    if (item instanceof String) {
                        stationCodes.add((String) item);
                    }
                }
            }

            if (name != null && !name.isEmpty()) {
                existingLine.setName(name);
            }
            if (color != null && !color.isEmpty()) {
                existingLine.setColor(color);
            }
            if (!stationCodes.isEmpty()) {
                existingLine.setStationCodes(stationCodes);
            }

            // 更新线路（先删除再添加，简化实现）
            NetworkManager.removeLine(lineId);
            boolean success = NetworkManager.addLine(existingLine);

            if (success) {
                Map<String, Object> response = new HashMap<>();
                response.put("ok", true);
                response.put("message", "Line updated successfully");
                sendJsonResponse(exchange, 200, response);
            } else {
                sendError(exchange, 500, "Failed to update line");
            }
        }

        private void handleDeleteLine(HttpExchange exchange, String lineId) throws IOException {
            boolean success = NetworkManager.removeLine(lineId);
            if (success) {
                Map<String, Object> response = new HashMap<>();
                response.put("ok", true);
                response.put("message", "Line deleted successfully");
                sendJsonResponse(exchange, 200, response);
            } else {
                sendError(exchange, 404, "Line not found");
            }
        }
    }

    private static class FaresHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            try {
                NetworkManager.initialize();

                if ("GET".equals(exchange.getRequestMethod())) {
                    Collection<Fare> fares = NetworkManager.getAllFares();

                    List<Map<String, Object>> fareList = new ArrayList<>();
                    for (Fare fare : fares) {
                        Map<String, Object> fareData = new HashMap<>();
                        fareData.put("from", fare.getFromStation());
                        fareData.put("to", fare.getToStation());
                        fareData.put("cost", fare.getPrice());
                        // 注意：web版本有cost_regular和cost_express，这里简化
                        fareData.put("cost_regular", fare.getPrice());
                        fareData.put("cost_express", fare.getPrice());
                        fareList.add(fareData);
                    }

                    sendJsonResponse(exchange, 200, fareList);
                } else {
                    sendError(exchange, 405, "Method not allowed");
                }
            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Error in fares handler", e);
                sendError(exchange, 500, "Internal server error");
            }
        }
    }

    private static class ConfigHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if ("GET".equals(exchange.getRequestMethod())) {
                Map<String, Object> config = new HashMap<>();
                config.put("api_base", "http://localhost:" + port + "/api");
                config.put("current_station", Map.of("name", "Station1", "code", "01-01"));
                config.put("transfers", new ArrayList<>());
                config.put("promotion", Map.of("name", "", "discount", 1.0));

                sendJsonResponse(exchange, 200, config);
            } else {
                sendError(exchange, 405, "Method not allowed");
            }
        }
    }

    private static class ExportHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            try {
                NetworkManager.initialize();

                Map<String, Object> export = new HashMap<>();

                // 车站数据
                List<Map<String, Object>> stations = new ArrayList<>();
                for (Station station : NetworkManager.getAllStations()) {
                    stations.add(Map.of(
                        "code", station.getCode(),
                        "name", station.getName(),
                        "en_name", station.getEnName()
                    ));
                }
                export.put("stations", stations);

                // 线路数据
                List<Map<String, Object>> lines = new ArrayList<>();
                for (Line line : NetworkManager.getAllLines()) {
                    lines.add(Map.of(
                        "id", line.getId(),
                        "name", line.getName(),
                        "en_name", line.getEnName(),
                        "color", line.getColor(),
                        "stations", line.getStationCodes()
                    ));
                }
                export.put("lines", lines);

                // 票价数据
                List<Map<String, Object>> fares = new ArrayList<>();
                for (Fare fare : NetworkManager.getAllFares()) {
                    fares.add(Map.of(
                        "from", fare.getFromStation(),
                        "to", fare.getToStation(),
                        "cost", fare.getPrice(),
                        "cost_regular", fare.getPrice(),
                        "cost_express", fare.getPrice()
                    ));
                }
                export.put("fares", fares);

                // 配置
                export.put("config", Map.of(
                    "api_base", "http://localhost:" + port + "/api",
                    "promotion", Map.of("name", "", "discount", 1.0)
                ));

                sendJsonResponse(exchange, 200, export);

            } catch (Exception e) {
                TicketSystemMod.LOGGER.error("Error in export handler", e);
                sendError(exchange, 500, "Internal server error");
            }
        }
    }

    private static class HealthHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            Map<String, Object> health = new HashMap<>();
            health.put("ok", true);
            health.put("service", "ticketsystem");
            health.put("timestamp", System.currentTimeMillis());
            health.put("port", port);
            health.put("running", running);

            sendJsonResponse(exchange, 200, health);
        }
    }
}这个是第二个版本
