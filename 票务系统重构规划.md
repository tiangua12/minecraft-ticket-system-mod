# 票务系统重构规划

## 修改摘要（基于新要求）

**用户提出的新要求**：
1. **删除双票价系统**：只保留单票价，不区分普通/特急票价
2. **简化线路显示**：车站不要用SVG实时绘制，因为不是真正的线路图，没有方向性，只是显示哪条线路上有哪些车站
3. **实现逻辑参考**：参考/storage/emulated/0/临时/ticketsystemweb/的实现
4. **添加线路管理**：需要线路管理功能

**对应修改点**：
- **票价系统**：改为单票价表系统（类似Web版本，但去掉双票价）
- **线路显示**：改为简单列表显示，使用Minecraft GUI组件，不实现SVG图形
- **线路管理**：添加线路管理GUI和命令，支持线路创建、车站分配
- **数据模型**：借鉴Web版本的数据结构，但简化实现
- **实现范围**：专注于游戏内功能，不实现Web终端

## 项目背景

现有票务系统基于简单的欧几里得距离计算票价，车站数据仅存储坐标信息。需要重构为基于线路网络和票价表的新系统。

## 需求理解

### 1. 数据模型重构（基于参考项目）
- **线路（Line）**：包含线路ID、名称、颜色，车站有序排列（参考lines.json）
- **车站（Station）**：包含车站编码、名称、坐标位置（参考stations.json）
- **票价表（Fare）**：车站区间预定义价格，单票价系统（参考fares.json，但去掉特急票价）
- **线路归属**：显示车站属于哪些线路，不强调复杂的线路图拓扑

### 2. 票价计算逻辑
- **票价表查询**：基于预定义的票价表查询，不基于距离计算
- **单票价系统**：每个区间只有一个价格，删除双票价（特急/普通）区分
- **简单累计**：同一条线路上按车站顺序累计区间票价
- **简化显示**：线路显示只需表明车站归属关系，不绘制SVG线路图

### 3. 需要修复的bug
1. **未使用的price字段**：`StationData`类中的`price`字段在代码中未被使用
2. **数据存储位置bug**：在专用服务器环境中，GUI添加数据保存到客户端，指令添加数据保存到服务器端，导致数据不一致

## 与现有系统对比

| 方面 | 现有系统 | 新系统 |
|------|----------|--------|
| 票价计算 | 基于欧几里得距离 | 基于票价表查询（单票价） |
| 车站数据 | 仅坐标信息 | 编码、名称、坐标、线路归属 |
| 线路支持 | 无线路概念 | 线路管理（车站顺序，非复杂拓扑） |
| 换乘支持 | 不支持 | 可选支持（简化实现） |
| 线路显示 | 无 | 简单列表/图形显示，非SVG实时绘制 |
| 票价系统 | 单票价 | 单票价表（删除双票价系统） |
| 实现复杂度 | 简单 | 中等（添加线路和票价表管理） |

## 新增功能需求

### 1. 游戏内线路管理功能

#### 1.1 线路数据管理
- **线路创建/编辑**：管理员可创建新线路，设置名称、颜色
- **车站分配**：将现有车站分配到线路，设置车站顺序
- **线路删除**：删除线路（不影响车站数据）
- **数据持久化**：JSON文件存储，与现有车站数据兼容

#### 1.2 票价表管理系统
- **区间票价设置**：为相邻车站设置固定票价
- **票价查询**：快速查询任意两个车站间的票价
- **票价验证**：确保票价表完整性和一致性
- **票价生成**：基于现有车站自动生成基础票价表

#### 1.3 线路图显示
- **简化显示**：不使用SVG，使用Minecraft GUI组件
- **水平布局**：每条线路一行，车站等距显示
- **颜色编码**：线路颜色标识
- **车站标签**：显示车站编码和名称
- **交互功能**：点击车站选择为目的地

#### 1.4 数据存储分离
- **线路数据**：存储在专门的文件夹中，与车站数据分开
- **车站数据**：独立存储，支持单独管理
- **票价数据**：独立存储，支持单独管理
- **文件结构**：
  ```
  mods/ticketsystem/
  ├── stations/          # 车站数据目录
  │   └── stations.json
  ├── lines/             # 线路数据目录
  │   └── lines.json
  ├── fares/             # 票价数据目录
  │   └── fares.json
  └── config/            # 配置文件目录
  ```

### 2. Bug修复项
- **数据存储位置bug**：在专用服务器环境中，GUI添加数据保存到客户端，指令添加数据保存到服务器端，导致数据不一致
- **未使用的price字段**：`StationData`类中的`price`字段在代码中未被使用
- **解决方案**：所有数据操作统一在服务器端执行，客户端通过网络包发送请求

## 详细规划

### 第一阶段：数据结构设计（2-3天）

#### 1.1 核心数据类设计
```java
// 线路类
public class Line {
    private String id;           // 线路ID（唯一）
    private String name;         // 线路名称（显示用）
    private String color;        // 线路颜色（十六进制）
    private List<String> stations; // 车站编码列表（有序）
}

// 票价数据类
public class Fare {
    private String fromStation;  // 起点车站编码
    private String toStation;    // 终点车站编码
    private int price;           // 票价（铜币）
}
```

#### 1.2 数据管理器设计
- **LineManager.java**：线路数据加载/保存，线路CRUD操作
- **FareManager.java**：票价数据加载/保存，票价查询/更新
- **StationManager扩展**：添加车站编码和线路归属信息

#### 1.3 数据存储格式
- **stations.json**：车站基本数据（编码、名称、坐标）
- **lines.json**：线路数据（ID、名称、颜色、车站顺序）
- **fares.json**：票价表数据（起点、终点、价格）

### 第二阶段：线路管理功能实现（3-4天）

#### 2.1 线路管理GUI
- **LineManagementScreen.java**：线路列表和编辑界面
- **线路列表**：显示所有线路（名称、颜色、车站数）
- **线路编辑**：添加/删除线路，设置名称和颜色
- **车站分配**：从现有车站选择分配到线路，调整顺序

#### 2.2 线路管理命令
- `/ticketsystem addline <id> <名称> <颜色>`
- `/ticketsystem editline <id> addstation <车站>`
- `/ticketsystem editline <id> removestation <车站>`
- `/ticketsystem deleteline <id>`
- `/ticketsystem listlines`：列出所有线路

#### 2.3 票价管理GUI
- **FareManagementScreen.java**：票价表编辑界面
- **票价表显示**：类似Web版本的简单表格显示
- **票价编辑**：添加/编辑/删除区间票价
- **批量操作**：支持票价批量设置和导入导出

### 第三阶段：线路图显示实现（3-4天）

#### 3.1 线路图GUI组件
- **LineDiagramComponent.java**：自定义GUI组件
- **水平布局**：每条线路单行显示
- **车站节点**：使用彩色矩形表示，显示车站编码
- **线路条**：线路颜色背景条，连接车站
- **标签显示**：鼠标悬停显示车站详细信息

#### 3.2 线路图集成
- **售票机界面**：添加线路图显示标签页
- **管理员界面**：线路图预览和编辑模式
- **用户模式**：简化显示，突出当前起始站和目的地

#### 3.3 交互功能
- **车站选择**：点击车站选择为目的地
- **线路筛选**：按线路筛选显示的车站
- **搜索功能**：在图中高亮搜索的车站
- **缩放支持**：简单的缩放控制（如果线路过多）

### 第四阶段：票价计算逻辑更新（2-3天）

#### 4.1 PriceCalculator重构
- **票价表查询**：优先查询票价表，如果不存在则使用原距离计算
- **票价验证**：确保票价合理性和完整性
- **缓存优化**：频繁查询的票价结果缓存

#### 4.2 票价生成工具
- **自动生成**：基于现有车站距离自动生成基础票价
- **票价导入**：支持从CSV/JSON文件导入票价表
- **票价验证**：检查票价表完整性和对称性

#### 4.3 系统集成
- **售票机更新**：使用新的票价计算逻辑
- **退票机更新**：票价表查询支持
- **闸机系统**：保持兼容，使用车票中的价格字段

### 第二阶段：数据模型设计（简化版）

#### 2.1 数据结构设计（基于参考项目）
```java
// 车站类 - 参考stations.json结构
public class Station {
    private final String code;        // 车站编码，如"01-01"（唯一标识）
    private String name;             // 车站名称（中文）
    private String enName;           // 英文名称（可选）
    private int x, y, z;             // 坐标（用于地图显示）

    public Station(String code, String name) {
        this.code = code;
        this.name = name;
        this.enName = "";
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }

    // Getter和Setter方法...
}

// 线路类 - 参考lines.json结构（简化）
public class Line {
    private final String id;          // 线路ID，如"1"（唯一）
    private String name;             // 线路名称，如"1号线"
    private String color;            // 线路颜色，如"#FF0000"
    private List<String> stationCodes; // 车站编码列表（有序）

    public Line(String id, String name, String color) {
        this.id = id;
        this.name = name;
        this.color = color;
        this.stationCodes = new ArrayList<>();
    }

    // 方法：添加车站、移除车站、获取车站顺序等
}

// 票价类 - 参考fares.json结构（单票价）
public class Fare {
    private final String fromStation;  // 起点车站编码
    private final String toStation;    // 终点车站编码
    private final int price;           // 票价（铜币）

    public Fare(String fromStation, String toStation, int price) {
        this.fromStation = fromStation;
        this.toStation = toStation;
        this.price = price;
    }

    // Getter方法...
}

// 路径计算结果
public class Route {
    private List<String> stationPath;   // 经过的车站ID列表
    private List<String> linePath;      // 经过的线路ID列表（用于换乘显示）
    private int totalPrice;             // 总价格（铜币）
    private int transferCount;          // 换乘次数
}
```

#### 2.2 数据关系设计
- 一条线路包含有序的车站序列（A→B→C→D）
- 相邻车站之间构成区间，每个区间有独立定价
- 一个车站可以属于多条线路（换乘站），实现线路间转乘
- 票价计算基于区间价格累加，选择最短（最便宜）路径

### 第三阶段：存储系统重构（2-3天）

#### 3.1 存储格式设计
- **JSON结构**：保持与现有系统的兼容性
- **数据文件分离**：
  - 车站数据：`mods/ticketsystem/stations/stations.json`
  - 线路数据：`mods/ticketsystem/lines/lines.json`
- **文件结构**：
  ```
  mods/ticketsystem/
  ├── stations/          # 车站数据目录
  │   └── stations.json
  ├── lines/             # 线路数据目录
  │   └── lines.json
  └── config/            # 配置文件目录
  ```
- **迁移工具**：将现有坐标数据转换为新格式

#### 3.2 数据管理器（NetworkManager）
- 替换现有的`StationManager`
- 支持线路、车站的CRUD操作，以及区间价格设置
- 统一的数据持久化和加载（解决服务器/客户端数据不一致问题）
- 提供网络同步机制：客户端操作通过网络包发送到服务器处理

#### 3.3 修复数据存储位置bug
**问题分析**：
- 当前`StationManager`使用相对路径`"mods/ticketsystem/stations.json"`
- 在专用服务器环境中：
  - 指令执行在服务器端 → 保存到服务器目录
  - GUI操作在客户端 → 保存到客户端目录
  - 导致数据不一致

**解决方案**：
1. 使用Forge的配置系统或专用服务器数据目录
2. 确保所有数据操作都在服务器端执行
3. 客户端GUI操作通过网络包发送到服务器处理

### 第四阶段：核心算法实现（2-3天）

#### 4.1 最短路径算法（Dijkstra）
```java
public class RouteCalculator {
    // 构建图：节点=车站，边=区间（价格作为权重）
    // 计算起点到终点的最低价格路径
    public Route findCheapestRoute(String startStationId, String endStationId);

    // 支持换乘站的特殊处理
    // 支持多种搜索策略（最少换乘、最少站点等）
}
```

#### 4.2 票价计算器
- 替换现有的`PriceCalculator`
- 基于区间价格而非距离
- 支持换乘路径计算

### 第五阶段：用户界面更新（3-4天）

#### 5.1 管理员界面
- **线路管理界面**：添加/编辑/删除线路
- **车站管理界面**：管理车站基本信息（ID、名称、坐标）
- **区间定价界面**：设置每个区间的价格
- **网络可视化**：显示线路网络图（可选）

#### 5.2 用户界面
- **车票购买**：显示可选路线和价格
- **路线展示**：显示换乘方案和总价

### 第六阶段：系统集成和测试（2-3天）

#### 6.1 系统集成
- 更新售票机（`TicketMachineBlockEntity`）
- 更新闸机系统（`GateBlockEntity`）
- 更新补票机（`ReissueMachineBlockEntity`）

#### 6.2 bug修复
1. **移除未使用的price字段**：清理`StationData`类
2. **修复数据存储位置bug**：实现统一的服务器端数据存储
3. **坐标验证**：在`AddStationScreen`中添加坐标范围验证

#### 6.3 测试
- 单元测试：最短路径算法
- 集成测试：完整购票流程
- 数据迁移测试：现有车站数据转换

### 第七阶段：文档和部署（1-2天）

#### 7.1 文档更新
- 更新`退票机器开发规划.md`
- 添加新系统的使用说明
- API文档（如果需要）

#### 8.2 部署准备
- 版本号更新（1.4.0）
- 多语言文本更新
- 配置文件模板

## 技术实现细节

### 数据存储方案

#### 车站数据文件 (`stations/stations.json`)
```json
{
  "version": "1.0",
  "stations": {
    "beijing_station": {
      "name_zh": "北京站",
      "name_en": "Beijing Station",
      "x": 100,
      "y": 64,
      "z": 200
    },
    "shanghai_station": {
      "name_zh": "上海站",
      "name_en": "Shanghai Station",
      "x": 500,
      "y": 70,
      "z": 300
    }
  }
}
```

#### 线路数据文件 (`lines/lines.json`)

**方案A：简单明了，使用平行数组（备选）**
```json
{
  "version": "1.0",
  "lines": {
    "line_1": {
      "name_zh": "1号线",
      "name_en": "Line 1",
      "color": "#FF0000",
      "stations": ["beijing_station", "tiananmen_station", "wangfujing_station"],
      "prices": [100, 150]  // beijing->tiananmen:100, tiananmen->wangfujing:150
    },
    "line_2": {
      "name_zh": "2号线",
      "name_en": "Line 2",
      "color": "#0000FF",
      "stations": ["shanghai_station", "people_square_station", "nanjing_road_station"],
      "prices": [120, 130]  // shanghai->people_square:120, people_square->nanjing_road:130
    }
  }
}
```

**方案B：更严谨的对象数组（推荐）**
```json
{
  "version": "1.0",
  "lines": {
    "line_1": {
      "name_zh": "1号线",
      "name_en": "Line 1",
      "color": "#FF0000",
      "segments": [
        {
          "from": "beijing_station",
          "to": "tiananmen_station",
          "price": 100,
          "order": 1
        },
        {
          "from": "tiananmen_station",
          "to": "wangfujing_station",
          "price": 150,
          "order": 2
        }
      ]
    }
  }
}
```

**方案C：车站数组带价格（备选）**
```json
{
  "version": "1.0",
  "lines": {
    "line_1": {
      "name_zh": "1号线",
      "name_en": "Line 1",
      "color": "#FF0000",
      "stations_with_price": [
        {"id": "beijing_station", "order": 1},
        {"id": "tiananmen_station", "order": 2, "price_from_prev": 100},
        {"id": "wangfujing_station", "order": 3, "price_from_prev": 150}
      ]
    }
  }
}
```

**各方案比较：**

| 方案 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| **方案A（平行数组）** | 1. 最简单明了<br>2. 数据量最小<br>3. 数组索引对应明确<br>4. 易于理解和修改 | 1. 需要确保stations和prices数组长度对应<br>2. 价格数组比stations少一个元素 | ★★★☆☆ |
| **方案B（对象数组）** | 1. **结构最严谨**<br>2. **每条区间信息完整独立**<br>3. **易于扩展额外字段**<br>4. **车站ID明确记录**（from/to字段都是车站唯一标识符）<br>5. **数据完整性好** | 1. 数据冗余（重复存储车站ID）<br>2. JSON文件体积较大 | ★★★★★（推荐） |
| **方案C（车站带价）** | 1. 车站和价格一体化<br>2. 每个车站记录到前一站的价格 | 1. 第一个车站没有price_from_prev字段<br>2. 逻辑稍复杂 | ★★☆☆☆ |

**建议采用方案B（对象数组）**，原因：
1. **结构最严谨**：每条区间信息完整独立，包含from/to/price/order等完整字段
2. **车站ID明确**：每个segment明确记录起点和终点的车站唯一标识符（车站ID）
3. **易于扩展**：可以方便地添加额外字段（如距离、运行时间等）
4. **逻辑清晰**：每条区间都是独立的对象，易于理解和维护
5. **数据完整性**：每条区间信息自包含，不依赖数组索引对应关系

### 网络同步机制
- 客户端所有数据修改操作通过网络包发送到服务器
- 服务器处理数据存储并广播更新
- 客户端定期从服务器同步最新数据

### 向后兼容性处理
1. **数据迁移**：提供工具将现有`stations.json`转换为新格式
2. **API兼容**：保持现有命令和API的兼容性
3. **逐步迁移**：支持新旧系统并行运行

## 关键决策点

1. **向后兼容性**：保留坐标位置信息，用于地图显示和现有功能
2. **换乘逻辑**：换乘是否额外收费（建议可配置，默认免费）
3. **UI复杂度**：先实现基本功能，图形化线路编辑器作为后续优化
4. **性能考虑**：线路网络较大时使用缓存和优化算法

## 预计影响的文件

### 需要重写的核心文件
- `StationData.java` → 简化为新的`Station`类（移除未使用的price字段）
- `StationManager.java` → 重构为`NetworkManager`（支持线路和分开的数据存储）
- `PriceCalculator.java` → 完全重写算法（基于区间价格和最短路径）
- `TicketMachineScreen.java` → 更新UI逻辑（支持线路选择和换乘显示）

### 需要修改的文件
- `TicketMachineBlockEntity.java`
- `ReissueMachineBlockEntity.java`
- `GateBlockEntity.java`
- `AddStationScreen.java`（扩展功能）
- 各种配置和命令类

### 新增文件
- `Station.java`、`Line.java`、`Route.java`（新的数据类）
- `NetworkManager.java`（统一的数据管理器）
- `RouteCalculator.java`（最短路径算法实现）
- `WebTerminalManager.java`（Web终端管理器）
- `LineManagementScreen.java`、`StationManagementScreen.java`等新UI界面

## 风险评估

### 技术风险
1. **算法性能**：大规模线路网络的最短路径计算性能
   - 缓解：使用缓存、限制搜索深度、异步计算
2. **数据迁移**：现有车站数据转换可能丢失信息
   - 缓解：提供备份和回滚机制
3. **网络同步**：多客户端数据一致性
   - 缓解：严格的服务器端验证和冲突解决

### 项目风险
1. **开发时间**：重构规模较大，可能超出预期
   - 缓解：分阶段实施，优先核心功能
2. **测试覆盖率**：新算法需要充分测试
   - 缓解：编写单元测试和集成测试

## 成功标准

1. **功能完整**：实现所有需求功能
2. **性能达标**：票价计算响应时间小于100ms（正常网络规模）
3. **数据一致**：修复数据存储位置bug，确保服务器/客户端数据一致
4. **向后兼容**：现有世界数据可以平滑迁移
5. **用户体验**：新界面直观易用

## 时间估算

| 阶段 | 时间 | 里程碑 |
|------|------|--------|
| 第零阶段：Java Web服务器与基础API开发 | 3-4天 | HTTP服务器运行 API可用 |
| 第一阶段：前端管理界面开发 | 3-4天 | 可视化线路编辑器，票价图导出功能 |
| 第二阶段：数据模型设计 | 2-3天 | 完成Station/Line/Route数据类设计 |
| 第三阶段：存储系统重构 | 2-3天 | 修复存储bug，实现NetworkManager |
| 第四阶段：核心算法实现 | 2-3天 | 实现Dijkstra最短路径算法 |
| 第五阶段：用户界面更新 | 3-4天 | 更新售票机、闸机、补票机界面 |
| 第六阶段：系统集成测试 | 2-3天 | 完整功能测试，数据迁移验证 |
| 第七阶段：文档和部署 | 1-2天 | 版本发布，文档更新 |
| **总计** | **18-25天** | |

## 下一步行动

1. **确认需求**：与产品负责人确认换乘规则和Web终端具体功能
2. **开始实施**：按规划分阶段开发
3. **持续沟通**：定期汇报进度和问题

---
*文档版本：1.4*
*创建日期：2025-12-06*
*最后更新：2025-12-06*